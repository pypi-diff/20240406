# Comparing `tmp/celldega-0.0.0.tar.gz` & `tmp/celldega-0.1.0.tar.gz`

## Comparing `celldega-0.0.0.tar` & `celldega-0.1.0.tar`

### file list

```diff
@@ -1,7 +1,7 @@
--rw-r--r--   0        0        0      430 2020-02-02 00:00:00.000000 celldega-0.0.0/src/celldega/__init__.py
--rw-r--r--   0        0        0      325 2020-02-02 00:00:00.000000 celldega-0.0.0/src/celldega/static/widget.css
--rw-r--r--   0        0        0   527212 2020-02-02 00:00:00.000000 celldega-0.0.0/src/celldega/static/widget.js
--rw-r--r--   0        0        0      346 2020-02-02 00:00:00.000000 celldega-0.0.0/.gitignore
--rw-r--r--   0        0        0      558 2020-02-02 00:00:00.000000 celldega-0.0.0/README.md
--rw-r--r--   0        0        0      773 2020-02-02 00:00:00.000000 celldega-0.0.0/pyproject.toml
--rw-r--r--   0        0        0      780 2020-02-02 00:00:00.000000 celldega-0.0.0/PKG-INFO
+-rw-r--r--   0        0        0      777 2020-02-02 00:00:00.000000 celldega-0.1.0/src/celldega/__init__.py
+-rw-r--r--   0        0        0      325 2020-02-02 00:00:00.000000 celldega-0.1.0/src/celldega/static/widget.css
+-rw-r--r--   0        0        0   528281 2020-02-02 00:00:00.000000 celldega-0.1.0/src/celldega/static/widget.js
+-rw-r--r--   0        0        0      346 2020-02-02 00:00:00.000000 celldega-0.1.0/.gitignore
+-rw-r--r--   0        0        0      558 2020-02-02 00:00:00.000000 celldega-0.1.0/README.md
+-rw-r--r--   0        0        0      773 2020-02-02 00:00:00.000000 celldega-0.1.0/pyproject.toml
+-rw-r--r--   0        0        0      780 2020-02-02 00:00:00.000000 celldega-0.1.0/PKG-INFO
```

### Comparing `celldega-0.0.0/src/celldega/static/widget.js` & `celldega-0.1.0/src/celldega/static/widget.js`

 * *Files 6% similar despite different names*

#### js-beautify {}

```diff
@@ -1,1352 +1,1352 @@
-var Z_ = Object.create;
+var Jg = Object.create;
 var vn = Object.defineProperty;
-var Q_ = Object.getOwnPropertyDescriptor;
-var J_ = Object.getOwnPropertyNames;
-var G_ = Object.getPrototypeOf,
-    em = Object.prototype.hasOwnProperty;
-var tm = (t, e, r) => e in t ? vn(t, e, {
+var Gg = Object.getOwnPropertyDescriptor;
+var tm = Object.getOwnPropertyNames;
+var em = Object.getPrototypeOf,
+    rm = Object.prototype.hasOwnProperty;
+var sm = (e, t, r) => t in e ? vn(e, t, {
     enumerable: !0,
     configurable: !0,
     writable: !0,
     value: r
-}) : t[e] = r;
-var rm = (t, e) => () => (e || t((e = {
+}) : e[t] = r;
+var im = (e, t) => () => (t || e((t = {
         exports: {}
-    }).exports, e), e.exports),
-    Us = (t, e) => {
-        for (var r in e) vn(t, r, {
-            get: e[r],
+    }).exports, t), t.exports),
+    Us = (e, t) => {
+        for (var r in t) vn(e, r, {
+            get: t[r],
             enumerable: !0
         })
     },
-    sm = (t, e, r, s) => {
-        if (e && typeof e == "object" || typeof e == "function")
-            for (let i of J_(e)) !em.call(t, i) && i !== r && vn(t, i, {
-                get: () => e[i],
-                enumerable: !(s = Q_(e, i)) || s.enumerable
+    nm = (e, t, r, s) => {
+        if (t && typeof t == "object" || typeof t == "function")
+            for (let i of tm(t)) !rm.call(e, i) && i !== r && vn(e, i, {
+                get: () => t[i],
+                enumerable: !(s = Gg(t, i)) || s.enumerable
             });
-        return t
+        return e
     };
-var im = (t, e, r) => (r = t != null ? Z_(G_(t)) : {}, sm(e || !t || !t.__esModule ? vn(r, "default", {
-    value: t,
+var om = (e, t, r) => (r = e != null ? Jg(em(e)) : {}, nm(t || !e || !e.__esModule ? vn(r, "default", {
+    value: e,
     enumerable: !0
-}) : r, t));
-var f = (t, e, r) => (tm(t, typeof e != "symbol" ? e + "" : e, r), r);
-var Ag = rm((CU, xa) => {
-    (function(t, e, r, s) {
+}) : r, e));
+var h = (e, t, r) => (sm(e, typeof t != "symbol" ? t + "" : t, r), r);
+var E_ = im((NU, Ea) => {
+    (function(e, t, r, s) {
         "use strict";
         var i = ["", "webkit", "Moz", "MS", "ms", "o"],
-            n = e.createElement("div"),
+            n = t.createElement("div"),
             o = "function",
             a = Math.round,
             c = Math.abs,
             l = Date.now;
 
-        function h(u, g, T) {
-            return setTimeout(R(u, T), g)
+        function f(u, _, b) {
+            return setTimeout(R(u, b), _)
         }
 
-        function d(u, g, T) {
-            return Array.isArray(u) ? (p(u, T[g], T), !0) : !1
+        function d(u, _, b) {
+            return Array.isArray(u) ? (p(u, b[_], b), !0) : !1
         }
 
-        function p(u, g, T) {
-            var S;
+        function p(u, _, b) {
+            var x;
             if (u)
-                if (u.forEach) u.forEach(g, T);
+                if (u.forEach) u.forEach(_, b);
                 else if (u.length !== s)
-                for (S = 0; S < u.length;) g.call(T, u[S], S, u), S++;
+                for (x = 0; x < u.length;) _.call(b, u[x], x, u), x++;
             else
-                for (S in u) u.hasOwnProperty(S) && g.call(T, u[S], S, u)
+                for (x in u) u.hasOwnProperty(x) && _.call(b, u[x], x, u)
         }
 
-        function m(u, g, T) {
-            var S = "DEPRECATED METHOD: " + g + `
-` + T + ` AT 
+        function m(u, _, b) {
+            var x = "DEPRECATED METHOD: " + _ + `
+` + b + ` AT 
 `;
             return function() {
                 var I = new Error("get-stack-trace"),
-                    D = I && I.stack ? I.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
-                    H = t.console && (t.console.warn || t.console.log);
-                return H && H.call(t.console, S, D), u.apply(this, arguments)
+                    k = I && I.stack ? I.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
+                    j = e.console && (e.console.warn || e.console.log);
+                return j && j.call(e.console, x, k), u.apply(this, arguments)
             }
         }
         var y;
-        typeof Object.assign != "function" ? y = function(g) {
-            if (g === s || g === null) throw new TypeError("Cannot convert undefined or null to object");
-            for (var T = Object(g), S = 1; S < arguments.length; S++) {
-                var I = arguments[S];
+        typeof Object.assign != "function" ? y = function(_) {
+            if (_ === s || _ === null) throw new TypeError("Cannot convert undefined or null to object");
+            for (var b = Object(_), x = 1; x < arguments.length; x++) {
+                var I = arguments[x];
                 if (I !== s && I !== null)
-                    for (var D in I) I.hasOwnProperty(D) && (T[D] = I[D])
+                    for (var k in I) I.hasOwnProperty(k) && (b[k] = I[k])
             }
-            return T
+            return b
         } : y = Object.assign;
-        var x = m(function(g, T, S) {
-                for (var I = Object.keys(T), D = 0; D < I.length;)(!S || S && g[I[D]] === s) && (g[I[D]] = T[I[D]]), D++;
-                return g
+        var E = m(function(_, b, x) {
+                for (var I = Object.keys(b), k = 0; k < I.length;)(!x || x && _[I[k]] === s) && (_[I[k]] = b[I[k]]), k++;
+                return _
             }, "extend", "Use `assign`."),
-            b = m(function(g, T) {
-                return x(g, T, !0)
+            T = m(function(_, b) {
+                return E(_, b, !0)
             }, "merge", "Use `assign`.");
 
-        function w(u, g, T) {
-            var S = g.prototype,
+        function S(u, _, b) {
+            var x = _.prototype,
                 I;
-            I = u.prototype = Object.create(S), I.constructor = u, I._super = S, T && y(I, T)
+            I = u.prototype = Object.create(x), I.constructor = u, I._super = x, b && y(I, b)
         }
 
-        function R(u, g) {
+        function R(u, _) {
             return function() {
-                return u.apply(g, arguments)
+                return u.apply(_, arguments)
             }
         }
 
-        function v(u, g) {
-            return typeof u == o ? u.apply(g && g[0] || s, g) : u
+        function v(u, _) {
+            return typeof u == o ? u.apply(_ && _[0] || s, _) : u
         }
 
-        function C(u, g) {
-            return u === s ? g : u
+        function C(u, _) {
+            return u === s ? _ : u
         }
 
-        function O(u, g, T) {
-            p(B(g), function(S) {
-                u.addEventListener(S, T, !1)
+        function O(u, _, b) {
+            p(B(_), function(x) {
+                u.addEventListener(x, b, !1)
             })
         }
 
-        function N(u, g, T) {
-            p(B(g), function(S) {
-                u.removeEventListener(S, T, !1)
+        function N(u, _, b) {
+            p(B(_), function(x) {
+                u.removeEventListener(x, b, !1)
             })
         }
 
-        function U(u, g) {
+        function U(u, _) {
             for (; u;) {
-                if (u == g) return !0;
+                if (u == _) return !0;
                 u = u.parentNode
             }
             return !1
         }
 
-        function k(u, g) {
-            return u.indexOf(g) > -1
+        function D(u, _) {
+            return u.indexOf(_) > -1
         }
 
         function B(u) {
             return u.trim().split(/\s+/g)
         }
 
-        function F(u, g, T) {
-            if (u.indexOf && !T) return u.indexOf(g);
-            for (var S = 0; S < u.length;) {
-                if (T && u[S][T] == g || !T && u[S] === g) return S;
-                S++
+        function F(u, _, b) {
+            if (u.indexOf && !b) return u.indexOf(_);
+            for (var x = 0; x < u.length;) {
+                if (b && u[x][b] == _ || !b && u[x] === _) return x;
+                x++
             }
             return -1
         }
 
         function L(u) {
             return Array.prototype.slice.call(u, 0)
         }
 
-        function Y(u, g, T) {
-            for (var S = [], I = [], D = 0; D < u.length;) {
-                var H = g ? u[D][g] : u[D];
-                F(I, H) < 0 && S.push(u[D]), I[D] = H, D++
-            }
-            return T && (g ? S = S.sort(function(le, ye) {
-                return le[g] > ye[g]
-            }) : S = S.sort()), S
+        function Y(u, _, b) {
+            for (var x = [], I = [], k = 0; k < u.length;) {
+                var j = _ ? u[k][_] : u[k];
+                F(I, j) < 0 && x.push(u[k]), I[k] = j, k++
+            }
+            return b && (_ ? x = x.sort(function(lt, yt) {
+                return lt[_] > yt[_]
+            }) : x = x.sort()), x
         }
 
-        function $(u, g) {
-            for (var T, S, I = g[0].toUpperCase() + g.slice(1), D = 0; D < i.length;) {
-                if (T = i[D], S = T ? T + I : g, S in u) return S;
-                D++
+        function $(u, _) {
+            for (var b, x, I = _[0].toUpperCase() + _.slice(1), k = 0; k < i.length;) {
+                if (b = i[k], x = b ? b + I : _, x in u) return x;
+                k++
             }
             return s
         }
-        var j = 1;
+        var H = 1;
 
-        function de() {
-            return j++
+        function dt() {
+            return H++
         }
 
-        function Nt(u) {
-            var g = u.ownerDocument || u;
-            return g.defaultView || g.parentWindow || t
+        function Ne(u) {
+            var _ = u.ownerDocument || u;
+            return _.defaultView || _.parentWindow || e
         }
         var ar = /mobile|tablet|ip(ad|hone|od)|android/i,
-            Ps = "ontouchstart" in t,
-            _n = $(t, "PointerEvent") !== s,
-            y_ = Ps && ar.test(navigator.userAgent),
+            Ps = "ontouchstart" in e,
+            gn = $(e, "PointerEvent") !== s,
+            wg = Ps && ar.test(navigator.userAgent),
             Cs = "touch",
-            b_ = "pen",
+            Ag = "pen",
             Ba = "mouse",
-            E_ = "kinect",
-            A_ = 25,
-            Te = 1,
+            Eg = "kinect",
+            xg = 25,
+            bt = 1,
             cr = 2,
-            te = 4,
-            xe = 8,
+            et = 4,
+            Et = 8,
             mn = 1,
             Is = 2,
             Os = 4,
             Ns = 8,
             Fs = 16,
-            Ge = Is | Os,
+            Gt = Is | Os,
             lr = Ns | Fs,
-            ef = Ge | lr,
-            tf = ["x", "y"],
-            Tn = ["clientX", "clientY"];
-
-        function Ce(u, g) {
-            var T = this;
-            this.manager = u, this.callback = g, this.element = u.element, this.target = u.options.inputTarget, this.domHandler = function(S) {
-                v(u.options.enable, [u]) && T.handler(S)
+            rh = Gt | lr,
+            sh = ["x", "y"],
+            bn = ["clientX", "clientY"];
+
+        function Ct(u, _) {
+            var b = this;
+            this.manager = u, this.callback = _, this.element = u.element, this.target = u.options.inputTarget, this.domHandler = function(x) {
+                v(u.options.enable, [u]) && b.handler(x)
             }, this.init()
         }
-        Ce.prototype = {
+        Ct.prototype = {
             handler: function() {},
             init: function() {
-                this.evEl && O(this.element, this.evEl, this.domHandler), this.evTarget && O(this.target, this.evTarget, this.domHandler), this.evWin && O(Nt(this.element), this.evWin, this.domHandler)
+                this.evEl && O(this.element, this.evEl, this.domHandler), this.evTarget && O(this.target, this.evTarget, this.domHandler), this.evWin && O(Ne(this.element), this.evWin, this.domHandler)
             },
             destroy: function() {
-                this.evEl && N(this.element, this.evEl, this.domHandler), this.evTarget && N(this.target, this.evTarget, this.domHandler), this.evWin && N(Nt(this.element), this.evWin, this.domHandler)
+                this.evEl && N(this.element, this.evEl, this.domHandler), this.evTarget && N(this.target, this.evTarget, this.domHandler), this.evWin && N(Ne(this.element), this.evWin, this.domHandler)
             }
         };
 
-        function x_(u) {
-            var g, T = u.options.inputClass;
-            return T ? g = T : _n ? g = La : y_ ? g = En : Ps ? g = Va : g = bn, new g(u, S_)
-        }
-
-        function S_(u, g, T) {
-            var S = T.pointers.length,
-                I = T.changedPointers.length,
-                D = g & Te && S - I === 0,
-                H = g & (te | xe) && S - I === 0;
-            T.isFirst = !!D, T.isFinal = !!H, D && (u.session = {}), T.eventType = g, w_(u, T), u.emit("hammer.input", T), u.recognize(T), u.session.prevInput = T
-        }
-
-        function w_(u, g) {
-            var T = u.session,
-                S = g.pointers,
-                I = S.length;
-            T.firstInput || (T.firstInput = rf(g)), I > 1 && !T.firstMultiple ? T.firstMultiple = rf(g) : I === 1 && (T.firstMultiple = !1);
-            var D = T.firstInput,
-                H = T.firstMultiple,
-                oe = H ? H.center : D.center,
-                le = g.center = sf(S);
-            g.timeStamp = l(), g.deltaTime = g.timeStamp - D.timeStamp, g.angle = Ua(oe, le), g.distance = yn(oe, le), R_(T, g), g.offsetDirection = of(g.deltaX, g.deltaY);
-            var ye = nf(g.deltaTime, g.deltaX, g.deltaY);
-            g.overallVelocityX = ye.x, g.overallVelocityY = ye.y, g.overallVelocity = c(ye.x) > c(ye.y) ? ye.x : ye.y, g.scale = H ? P_(H.pointers, S) : 1, g.rotation = H ? M_(H.pointers, S) : 0, g.maxPointers = T.prevInput ? g.pointers.length > T.prevInput.maxPointers ? g.pointers.length : T.prevInput.maxPointers : g.pointers.length, v_(T, g);
-            var tt = u.element;
-            U(g.srcEvent.target, tt) && (tt = g.srcEvent.target), g.target = tt
-        }
-
-        function R_(u, g) {
-            var T = g.center,
-                S = u.offsetDelta || {},
+        function Sg(u) {
+            var _, b = u.options.inputClass;
+            return b ? _ = b : gn ? _ = La : wg ? _ = wn : Ps ? _ = Va : _ = Tn, new _(u, Rg)
+        }
+
+        function Rg(u, _, b) {
+            var x = b.pointers.length,
+                I = b.changedPointers.length,
+                k = _ & bt && x - I === 0,
+                j = _ & (et | Et) && x - I === 0;
+            b.isFirst = !!k, b.isFinal = !!j, k && (u.session = {}), b.eventType = _, vg(u, b), u.emit("hammer.input", b), u.recognize(b), u.session.prevInput = b
+        }
+
+        function vg(u, _) {
+            var b = u.session,
+                x = _.pointers,
+                I = x.length;
+            b.firstInput || (b.firstInput = ih(_)), I > 1 && !b.firstMultiple ? b.firstMultiple = ih(_) : I === 1 && (b.firstMultiple = !1);
+            var k = b.firstInput,
+                j = b.firstMultiple,
+                ot = j ? j.center : k.center,
+                lt = _.center = nh(x);
+            _.timeStamp = l(), _.deltaTime = _.timeStamp - k.timeStamp, _.angle = Ua(ot, lt), _.distance = yn(ot, lt), Mg(b, _), _.offsetDirection = ah(_.deltaX, _.deltaY);
+            var yt = oh(_.deltaTime, _.deltaX, _.deltaY);
+            _.overallVelocityX = yt.x, _.overallVelocityY = yt.y, _.overallVelocity = c(yt.x) > c(yt.y) ? yt.x : yt.y, _.scale = j ? Ig(j.pointers, x) : 1, _.rotation = j ? Cg(j.pointers, x) : 0, _.maxPointers = b.prevInput ? _.pointers.length > b.prevInput.maxPointers ? _.pointers.length : b.prevInput.maxPointers : _.pointers.length, Pg(b, _);
+            var ee = u.element;
+            U(_.srcEvent.target, ee) && (ee = _.srcEvent.target), _.target = ee
+        }
+
+        function Mg(u, _) {
+            var b = _.center,
+                x = u.offsetDelta || {},
                 I = u.prevDelta || {},
-                D = u.prevInput || {};
-            (g.eventType === Te || D.eventType === te) && (I = u.prevDelta = {
-                x: D.deltaX || 0,
-                y: D.deltaY || 0
-            }, S = u.offsetDelta = {
-                x: T.x,
-                y: T.y
-            }), g.deltaX = I.x + (T.x - S.x), g.deltaY = I.y + (T.y - S.y)
-        }
-
-        function v_(u, g) {
-            var T = u.lastInterval || g,
-                S = g.timeStamp - T.timeStamp,
-                I, D, H, oe;
-            if (g.eventType != xe && (S > A_ || T.velocity === s)) {
-                var le = g.deltaX - T.deltaX,
-                    ye = g.deltaY - T.deltaY,
-                    tt = nf(S, le, ye);
-                D = tt.x, H = tt.y, I = c(tt.x) > c(tt.y) ? tt.x : tt.y, oe = of(le, ye), u.lastInterval = g
-            } else I = T.velocity, D = T.velocityX, H = T.velocityY, oe = T.direction;
-            g.velocity = I, g.velocityX = D, g.velocityY = H, g.direction = oe
-        }
-
-        function rf(u) {
-            for (var g = [], T = 0; T < u.pointers.length;) g[T] = {
-                clientX: a(u.pointers[T].clientX),
-                clientY: a(u.pointers[T].clientY)
-            }, T++;
+                k = u.prevInput || {};
+            (_.eventType === bt || k.eventType === et) && (I = u.prevDelta = {
+                x: k.deltaX || 0,
+                y: k.deltaY || 0
+            }, x = u.offsetDelta = {
+                x: b.x,
+                y: b.y
+            }), _.deltaX = I.x + (b.x - x.x), _.deltaY = I.y + (b.y - x.y)
+        }
+
+        function Pg(u, _) {
+            var b = u.lastInterval || _,
+                x = _.timeStamp - b.timeStamp,
+                I, k, j, ot;
+            if (_.eventType != Et && (x > xg || b.velocity === s)) {
+                var lt = _.deltaX - b.deltaX,
+                    yt = _.deltaY - b.deltaY,
+                    ee = oh(x, lt, yt);
+                k = ee.x, j = ee.y, I = c(ee.x) > c(ee.y) ? ee.x : ee.y, ot = ah(lt, yt), u.lastInterval = _
+            } else I = b.velocity, k = b.velocityX, j = b.velocityY, ot = b.direction;
+            _.velocity = I, _.velocityX = k, _.velocityY = j, _.direction = ot
+        }
+
+        function ih(u) {
+            for (var _ = [], b = 0; b < u.pointers.length;) _[b] = {
+                clientX: a(u.pointers[b].clientX),
+                clientY: a(u.pointers[b].clientY)
+            }, b++;
             return {
                 timeStamp: l(),
-                pointers: g,
-                center: sf(g),
+                pointers: _,
+                center: nh(_),
                 deltaX: u.deltaX,
                 deltaY: u.deltaY
             }
         }
 
-        function sf(u) {
-            var g = u.length;
-            if (g === 1) return {
+        function nh(u) {
+            var _ = u.length;
+            if (_ === 1) return {
                 x: a(u[0].clientX),
                 y: a(u[0].clientY)
             };
-            for (var T = 0, S = 0, I = 0; I < g;) T += u[I].clientX, S += u[I].clientY, I++;
+            for (var b = 0, x = 0, I = 0; I < _;) b += u[I].clientX, x += u[I].clientY, I++;
             return {
-                x: a(T / g),
-                y: a(S / g)
+                x: a(b / _),
+                y: a(x / _)
             }
         }
 
-        function nf(u, g, T) {
+        function oh(u, _, b) {
             return {
-                x: g / u || 0,
-                y: T / u || 0
+                x: _ / u || 0,
+                y: b / u || 0
             }
         }
 
-        function of(u, g) {
-            return u === g ? mn : c(u) >= c(g) ? u < 0 ? Is : Os : g < 0 ? Ns : Fs
+        function ah(u, _) {
+            return u === _ ? mn : c(u) >= c(_) ? u < 0 ? Is : Os : _ < 0 ? Ns : Fs
         }
 
-        function yn(u, g, T) {
-            T || (T = tf);
-            var S = g[T[0]] - u[T[0]],
-                I = g[T[1]] - u[T[1]];
-            return Math.sqrt(S * S + I * I)
+        function yn(u, _, b) {
+            b || (b = sh);
+            var x = _[b[0]] - u[b[0]],
+                I = _[b[1]] - u[b[1]];
+            return Math.sqrt(x * x + I * I)
         }
 
-        function Ua(u, g, T) {
-            T || (T = tf);
-            var S = g[T[0]] - u[T[0]],
-                I = g[T[1]] - u[T[1]];
-            return Math.atan2(I, S) * 180 / Math.PI
+        function Ua(u, _, b) {
+            b || (b = sh);
+            var x = _[b[0]] - u[b[0]],
+                I = _[b[1]] - u[b[1]];
+            return Math.atan2(I, x) * 180 / Math.PI
         }
 
-        function M_(u, g) {
-            return Ua(g[1], g[0], Tn) + Ua(u[1], u[0], Tn)
+        function Cg(u, _) {
+            return Ua(_[1], _[0], bn) + Ua(u[1], u[0], bn)
         }
 
-        function P_(u, g) {
-            return yn(g[0], g[1], Tn) / yn(u[0], u[1], Tn)
+        function Ig(u, _) {
+            return yn(_[0], _[1], bn) / yn(u[0], u[1], bn)
         }
-        var C_ = {
-                mousedown: Te,
+        var Og = {
+                mousedown: bt,
                 mousemove: cr,
-                mouseup: te
+                mouseup: et
             },
-            I_ = "mousedown",
-            O_ = "mousemove mouseup";
+            Ng = "mousedown",
+            Fg = "mousemove mouseup";
 
-        function bn() {
-            this.evEl = I_, this.evWin = O_, this.pressed = !1, Ce.apply(this, arguments)
+        function Tn() {
+            this.evEl = Ng, this.evWin = Fg, this.pressed = !1, Ct.apply(this, arguments)
         }
-        w(bn, Ce, {
-            handler: function(g) {
-                var T = C_[g.type];
-                T & Te && g.button === 0 && (this.pressed = !0), T & cr && g.which !== 1 && (T = te), this.pressed && (T & te && (this.pressed = !1), this.callback(this.manager, T, {
-                    pointers: [g],
-                    changedPointers: [g],
+        S(Tn, Ct, {
+            handler: function(_) {
+                var b = Og[_.type];
+                b & bt && _.button === 0 && (this.pressed = !0), b & cr && _.which !== 1 && (b = et), this.pressed && (b & et && (this.pressed = !1), this.callback(this.manager, b, {
+                    pointers: [_],
+                    changedPointers: [_],
                     pointerType: Ba,
-                    srcEvent: g
+                    srcEvent: _
                 }))
             }
         });
-        var N_ = {
-                pointerdown: Te,
+        var kg = {
+                pointerdown: bt,
                 pointermove: cr,
-                pointerup: te,
-                pointercancel: xe,
-                pointerout: xe
+                pointerup: et,
+                pointercancel: Et,
+                pointerout: Et
             },
-            F_ = {
+            Dg = {
                 2: Cs,
-                3: b_,
+                3: Ag,
                 4: Ba,
-                5: E_
+                5: Eg
             },
-            af = "pointerdown",
-            cf = "pointermove pointerup pointercancel";
-        t.MSPointerEvent && !t.PointerEvent && (af = "MSPointerDown", cf = "MSPointerMove MSPointerUp MSPointerCancel");
+            ch = "pointerdown",
+            lh = "pointermove pointerup pointercancel";
+        e.MSPointerEvent && !e.PointerEvent && (ch = "MSPointerDown", lh = "MSPointerMove MSPointerUp MSPointerCancel");
 
         function La() {
-            this.evEl = af, this.evWin = cf, Ce.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
+            this.evEl = ch, this.evWin = lh, Ct.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
         }
-        w(La, Ce, {
-            handler: function(g) {
-                var T = this.store,
-                    S = !1,
-                    I = g.type.toLowerCase().replace("ms", ""),
-                    D = N_[I],
-                    H = F_[g.pointerType] || g.pointerType,
-                    oe = H == Cs,
-                    le = F(T, g.pointerId, "pointerId");
-                D & Te && (g.button === 0 || oe) ? le < 0 && (T.push(g), le = T.length - 1) : D & (te | xe) && (S = !0), !(le < 0) && (T[le] = g, this.callback(this.manager, D, {
-                    pointers: T,
-                    changedPointers: [g],
-                    pointerType: H,
-                    srcEvent: g
-                }), S && T.splice(le, 1))
+        S(La, Ct, {
+            handler: function(_) {
+                var b = this.store,
+                    x = !1,
+                    I = _.type.toLowerCase().replace("ms", ""),
+                    k = kg[I],
+                    j = Dg[_.pointerType] || _.pointerType,
+                    ot = j == Cs,
+                    lt = F(b, _.pointerId, "pointerId");
+                k & bt && (_.button === 0 || ot) ? lt < 0 && (b.push(_), lt = b.length - 1) : k & (et | Et) && (x = !0), !(lt < 0) && (b[lt] = _, this.callback(this.manager, k, {
+                    pointers: b,
+                    changedPointers: [_],
+                    pointerType: j,
+                    srcEvent: _
+                }), x && b.splice(lt, 1))
             }
         });
-        var D_ = {
-                touchstart: Te,
+        var Bg = {
+                touchstart: bt,
                 touchmove: cr,
-                touchend: te,
-                touchcancel: xe
+                touchend: et,
+                touchcancel: Et
             },
-            k_ = "touchstart",
-            B_ = "touchstart touchmove touchend touchcancel";
+            Ug = "touchstart",
+            Lg = "touchstart touchmove touchend touchcancel";
 
-        function lf() {
-            this.evTarget = k_, this.evWin = B_, this.started = !1, Ce.apply(this, arguments)
+        function fh() {
+            this.evTarget = Ug, this.evWin = Lg, this.started = !1, Ct.apply(this, arguments)
         }
-        w(lf, Ce, {
-            handler: function(g) {
-                var T = D_[g.type];
-                if (T === Te && (this.started = !0), !!this.started) {
-                    var S = U_.call(this, g, T);
-                    T & (te | xe) && S[0].length - S[1].length === 0 && (this.started = !1), this.callback(this.manager, T, {
-                        pointers: S[0],
-                        changedPointers: S[1],
+        S(fh, Ct, {
+            handler: function(_) {
+                var b = Bg[_.type];
+                if (b === bt && (this.started = !0), !!this.started) {
+                    var x = Vg.call(this, _, b);
+                    b & (et | Et) && x[0].length - x[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {
+                        pointers: x[0],
+                        changedPointers: x[1],
                         pointerType: Cs,
-                        srcEvent: g
+                        srcEvent: _
                     })
                 }
             }
         });
 
-        function U_(u, g) {
-            var T = L(u.touches),
-                S = L(u.changedTouches);
-            return g & (te | xe) && (T = Y(T.concat(S), "identifier", !0)), [T, S]
+        function Vg(u, _) {
+            var b = L(u.touches),
+                x = L(u.changedTouches);
+            return _ & (et | Et) && (b = Y(b.concat(x), "identifier", !0)), [b, x]
         }
-        var L_ = {
-                touchstart: Te,
+        var Wg = {
+                touchstart: bt,
                 touchmove: cr,
-                touchend: te,
-                touchcancel: xe
+                touchend: et,
+                touchcancel: Et
             },
-            V_ = "touchstart touchmove touchend touchcancel";
+            zg = "touchstart touchmove touchend touchcancel";
 
-        function En() {
-            this.evTarget = V_, this.targetIds = {}, Ce.apply(this, arguments)
+        function wn() {
+            this.evTarget = zg, this.targetIds = {}, Ct.apply(this, arguments)
         }
-        w(En, Ce, {
-            handler: function(g) {
-                var T = L_[g.type],
-                    S = W_.call(this, g, T);
-                S && this.callback(this.manager, T, {
-                    pointers: S[0],
-                    changedPointers: S[1],
+        S(wn, Ct, {
+            handler: function(_) {
+                var b = Wg[_.type],
+                    x = jg.call(this, _, b);
+                x && this.callback(this.manager, b, {
+                    pointers: x[0],
+                    changedPointers: x[1],
                     pointerType: Cs,
-                    srcEvent: g
+                    srcEvent: _
                 })
             }
         });
 
-        function W_(u, g) {
-            var T = L(u.touches),
-                S = this.targetIds;
-            if (g & (Te | cr) && T.length === 1) return S[T[0].identifier] = !0, [T, T];
-            var I, D, H = L(u.changedTouches),
-                oe = [],
-                le = this.target;
-            if (D = T.filter(function(ye) {
-                    return U(ye.target, le)
-                }), g === Te)
-                for (I = 0; I < D.length;) S[D[I].identifier] = !0, I++;
-            for (I = 0; I < H.length;) S[H[I].identifier] && oe.push(H[I]), g & (te | xe) && delete S[H[I].identifier], I++;
-            if (oe.length) return [Y(D.concat(oe), "identifier", !0), oe]
+        function jg(u, _) {
+            var b = L(u.touches),
+                x = this.targetIds;
+            if (_ & (bt | cr) && b.length === 1) return x[b[0].identifier] = !0, [b, b];
+            var I, k, j = L(u.changedTouches),
+                ot = [],
+                lt = this.target;
+            if (k = b.filter(function(yt) {
+                    return U(yt.target, lt)
+                }), _ === bt)
+                for (I = 0; I < k.length;) x[k[I].identifier] = !0, I++;
+            for (I = 0; I < j.length;) x[j[I].identifier] && ot.push(j[I]), _ & (et | Et) && delete x[j[I].identifier], I++;
+            if (ot.length) return [Y(k.concat(ot), "identifier", !0), ot]
         }
-        var z_ = 2500,
-            hf = 25;
+        var Hg = 2500,
+            hh = 25;
 
         function Va() {
-            Ce.apply(this, arguments);
+            Ct.apply(this, arguments);
             var u = R(this.handler, this);
-            this.touch = new En(this.manager, u), this.mouse = new bn(this.manager, u), this.primaryTouch = null, this.lastTouches = []
+            this.touch = new wn(this.manager, u), this.mouse = new Tn(this.manager, u), this.primaryTouch = null, this.lastTouches = []
         }
-        w(Va, Ce, {
-            handler: function(g, T, S) {
-                var I = S.pointerType == Cs,
-                    D = S.pointerType == Ba;
-                if (!(D && S.sourceCapabilities && S.sourceCapabilities.firesTouchEvents)) {
-                    if (I) H_.call(this, T, S);
-                    else if (D && j_.call(this, S)) return;
-                    this.callback(g, T, S)
+        S(Va, Ct, {
+            handler: function(_, b, x) {
+                var I = x.pointerType == Cs,
+                    k = x.pointerType == Ba;
+                if (!(k && x.sourceCapabilities && x.sourceCapabilities.firesTouchEvents)) {
+                    if (I) Xg.call(this, b, x);
+                    else if (k && $g.call(this, x)) return;
+                    this.callback(_, b, x)
                 }
             },
             destroy: function() {
                 this.touch.destroy(), this.mouse.destroy()
             }
         });
 
-        function H_(u, g) {
-            u & Te ? (this.primaryTouch = g.changedPointers[0].identifier, ff.call(this, g)) : u & (te | xe) && ff.call(this, g)
+        function Xg(u, _) {
+            u & bt ? (this.primaryTouch = _.changedPointers[0].identifier, uh.call(this, _)) : u & (et | Et) && uh.call(this, _)
         }
 
-        function ff(u) {
-            var g = u.changedPointers[0];
-            if (g.identifier === this.primaryTouch) {
-                var T = {
-                    x: g.clientX,
-                    y: g.clientY
+        function uh(u) {
+            var _ = u.changedPointers[0];
+            if (_.identifier === this.primaryTouch) {
+                var b = {
+                    x: _.clientX,
+                    y: _.clientY
                 };
-                this.lastTouches.push(T);
-                var S = this.lastTouches,
+                this.lastTouches.push(b);
+                var x = this.lastTouches,
                     I = function() {
-                        var D = S.indexOf(T);
-                        D > -1 && S.splice(D, 1)
+                        var k = x.indexOf(b);
+                        k > -1 && x.splice(k, 1)
                     };
-                setTimeout(I, z_)
+                setTimeout(I, Hg)
             }
         }
 
-        function j_(u) {
-            for (var g = u.srcEvent.clientX, T = u.srcEvent.clientY, S = 0; S < this.lastTouches.length; S++) {
-                var I = this.lastTouches[S],
-                    D = Math.abs(g - I.x),
-                    H = Math.abs(T - I.y);
-                if (D <= hf && H <= hf) return !0
+        function $g(u) {
+            for (var _ = u.srcEvent.clientX, b = u.srcEvent.clientY, x = 0; x < this.lastTouches.length; x++) {
+                var I = this.lastTouches[x],
+                    k = Math.abs(_ - I.x),
+                    j = Math.abs(b - I.y);
+                if (k <= hh && j <= hh) return !0
             }
             return !1
         }
-        var uf = $(n.style, "touchAction"),
-            df = uf !== s,
-            pf = "compute",
-            gf = "auto",
+        var dh = $(n.style, "touchAction"),
+            ph = dh !== s,
+            _h = "compute",
+            gh = "auto",
             Wa = "manipulation",
-            hr = "none",
-            Ds = "pan-x",
-            ks = "pan-y",
-            An = $_();
+            fr = "none",
+            ks = "pan-x",
+            Ds = "pan-y",
+            An = qg();
 
-        function za(u, g) {
-            this.manager = u, this.set(g)
+        function za(u, _) {
+            this.manager = u, this.set(_)
         }
         za.prototype = {
             set: function(u) {
-                u == pf && (u = this.compute()), df && this.manager.element.style && An[u] && (this.manager.element.style[uf] = u), this.actions = u.toLowerCase().trim()
+                u == _h && (u = this.compute()), ph && this.manager.element.style && An[u] && (this.manager.element.style[dh] = u), this.actions = u.toLowerCase().trim()
             },
             update: function() {
                 this.set(this.manager.options.touchAction)
             },
             compute: function() {
                 var u = [];
-                return p(this.manager.recognizers, function(g) {
-                    v(g.options.enable, [g]) && (u = u.concat(g.getTouchAction()))
-                }), X_(u.join(" "))
+                return p(this.manager.recognizers, function(_) {
+                    v(_.options.enable, [_]) && (u = u.concat(_.getTouchAction()))
+                }), Yg(u.join(" "))
             },
             preventDefaults: function(u) {
-                var g = u.srcEvent,
-                    T = u.offsetDirection;
+                var _ = u.srcEvent,
+                    b = u.offsetDirection;
                 if (this.manager.session.prevented) {
-                    g.preventDefault();
+                    _.preventDefault();
                     return
                 }
-                var S = this.actions,
-                    I = k(S, hr) && !An[hr],
-                    D = k(S, ks) && !An[ks],
-                    H = k(S, Ds) && !An[Ds];
+                var x = this.actions,
+                    I = D(x, fr) && !An[fr],
+                    k = D(x, Ds) && !An[Ds],
+                    j = D(x, ks) && !An[ks];
                 if (I) {
-                    var oe = u.pointers.length === 1,
-                        le = u.distance < 2,
-                        ye = u.deltaTime < 250;
-                    if (oe && le && ye) return
+                    var ot = u.pointers.length === 1,
+                        lt = u.distance < 2,
+                        yt = u.deltaTime < 250;
+                    if (ot && lt && yt) return
                 }
-                if (!(H && D) && (I || D && T & Ge || H && T & lr)) return this.preventSrc(g)
+                if (!(j && k) && (I || k && b & Gt || j && b & lr)) return this.preventSrc(_)
             },
             preventSrc: function(u) {
                 this.manager.session.prevented = !0, u.preventDefault()
             }
         };
 
-        function X_(u) {
-            if (k(u, hr)) return hr;
-            var g = k(u, Ds),
-                T = k(u, ks);
-            return g && T ? hr : g || T ? g ? Ds : ks : k(u, Wa) ? Wa : gf
+        function Yg(u) {
+            if (D(u, fr)) return fr;
+            var _ = D(u, ks),
+                b = D(u, Ds);
+            return _ && b ? fr : _ || b ? _ ? ks : Ds : D(u, Wa) ? Wa : gh
         }
 
-        function $_() {
-            if (!df) return !1;
+        function qg() {
+            if (!ph) return !1;
             var u = {},
-                g = t.CSS && t.CSS.supports;
-            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(T) {
-                u[T] = g ? t.CSS.supports("touch-action", T) : !0
+                _ = e.CSS && e.CSS.supports;
+            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(b) {
+                u[b] = _ ? e.CSS.supports("touch-action", b) : !0
             }), u
         }
-        var xn = 1,
-            Ie = 2,
-            Hr = 4,
-            Ft = 8,
-            Tt = Ft,
+        var En = 1,
+            It = 2,
+            jr = 4,
+            Fe = 8,
+            be = Fe,
             Bs = 16,
-            et = 32;
+            te = 32;
 
-        function yt(u) {
-            this.options = y({}, this.defaults, u || {}), this.id = de(), this.manager = null, this.options.enable = C(this.options.enable, !0), this.state = xn, this.simultaneous = {}, this.requireFail = []
+        function ye(u) {
+            this.options = y({}, this.defaults, u || {}), this.id = dt(), this.manager = null, this.options.enable = C(this.options.enable, !0), this.state = En, this.simultaneous = {}, this.requireFail = []
         }
-        yt.prototype = {
+        ye.prototype = {
             defaults: {},
             set: function(u) {
                 return y(this.options, u), this.manager && this.manager.touchAction.update(), this
             },
             recognizeWith: function(u) {
                 if (d(u, "recognizeWith", this)) return this;
-                var g = this.simultaneous;
-                return u = Sn(u, this), g[u.id] || (g[u.id] = u, u.recognizeWith(this)), this
+                var _ = this.simultaneous;
+                return u = xn(u, this), _[u.id] || (_[u.id] = u, u.recognizeWith(this)), this
             },
             dropRecognizeWith: function(u) {
-                return d(u, "dropRecognizeWith", this) ? this : (u = Sn(u, this), delete this.simultaneous[u.id], this)
+                return d(u, "dropRecognizeWith", this) ? this : (u = xn(u, this), delete this.simultaneous[u.id], this)
             },
             requireFailure: function(u) {
                 if (d(u, "requireFailure", this)) return this;
-                var g = this.requireFail;
-                return u = Sn(u, this), F(g, u) === -1 && (g.push(u), u.requireFailure(this)), this
+                var _ = this.requireFail;
+                return u = xn(u, this), F(_, u) === -1 && (_.push(u), u.requireFailure(this)), this
             },
             dropRequireFailure: function(u) {
                 if (d(u, "dropRequireFailure", this)) return this;
-                u = Sn(u, this);
-                var g = F(this.requireFail, u);
-                return g > -1 && this.requireFail.splice(g, 1), this
+                u = xn(u, this);
+                var _ = F(this.requireFail, u);
+                return _ > -1 && this.requireFail.splice(_, 1), this
             },
             hasRequireFailures: function() {
                 return this.requireFail.length > 0
             },
             canRecognizeWith: function(u) {
                 return !!this.simultaneous[u.id]
             },
             emit: function(u) {
-                var g = this,
-                    T = this.state;
+                var _ = this,
+                    b = this.state;
 
-                function S(I) {
-                    g.manager.emit(I, u)
+                function x(I) {
+                    _.manager.emit(I, u)
                 }
-                T < Ft && S(g.options.event + _f(T)), S(g.options.event), u.additionalEvent && S(u.additionalEvent), T >= Ft && S(g.options.event + _f(T))
+                b < Fe && x(_.options.event + mh(b)), x(_.options.event), u.additionalEvent && x(u.additionalEvent), b >= Fe && x(_.options.event + mh(b))
             },
             tryEmit: function(u) {
                 if (this.canEmit()) return this.emit(u);
-                this.state = et
+                this.state = te
             },
             canEmit: function() {
                 for (var u = 0; u < this.requireFail.length;) {
-                    if (!(this.requireFail[u].state & (et | xn))) return !1;
+                    if (!(this.requireFail[u].state & (te | En))) return !1;
                     u++
                 }
                 return !0
             },
             recognize: function(u) {
-                var g = y({}, u);
-                if (!v(this.options.enable, [this, g])) {
-                    this.reset(), this.state = et;
+                var _ = y({}, u);
+                if (!v(this.options.enable, [this, _])) {
+                    this.reset(), this.state = te;
                     return
                 }
-                this.state & (Tt | Bs | et) && (this.state = xn), this.state = this.process(g), this.state & (Ie | Hr | Ft | Bs) && this.tryEmit(g)
+                this.state & (be | Bs | te) && (this.state = En), this.state = this.process(_), this.state & (It | jr | Fe | Bs) && this.tryEmit(_)
             },
             process: function(u) {},
             getTouchAction: function() {},
             reset: function() {}
         };
 
-        function _f(u) {
-            return u & Bs ? "cancel" : u & Ft ? "end" : u & Hr ? "move" : u & Ie ? "start" : ""
+        function mh(u) {
+            return u & Bs ? "cancel" : u & Fe ? "end" : u & jr ? "move" : u & It ? "start" : ""
         }
 
-        function mf(u) {
+        function bh(u) {
             return u == Fs ? "down" : u == Ns ? "up" : u == Is ? "left" : u == Os ? "right" : ""
         }
 
-        function Sn(u, g) {
-            var T = g.manager;
-            return T ? T.get(u) : u
+        function xn(u, _) {
+            var b = _.manager;
+            return b ? b.get(u) : u
         }
 
-        function je() {
-            yt.apply(this, arguments)
+        function Ht() {
+            ye.apply(this, arguments)
         }
-        w(je, yt, {
+        S(Ht, ye, {
             defaults: {
                 pointers: 1
             },
             attrTest: function(u) {
-                var g = this.options.pointers;
-                return g === 0 || u.pointers.length === g
+                var _ = this.options.pointers;
+                return _ === 0 || u.pointers.length === _
             },
             process: function(u) {
-                var g = this.state,
-                    T = u.eventType,
-                    S = g & (Ie | Hr),
+                var _ = this.state,
+                    b = u.eventType,
+                    x = _ & (It | jr),
                     I = this.attrTest(u);
-                return S && (T & xe || !I) ? g | Bs : S || I ? T & te ? g | Ft : g & Ie ? g | Hr : Ie : et
+                return x && (b & Et || !I) ? _ | Bs : x || I ? b & et ? _ | Fe : _ & It ? _ | jr : It : te
             }
         });
 
-        function wn() {
-            je.apply(this, arguments), this.pX = null, this.pY = null
+        function Sn() {
+            Ht.apply(this, arguments), this.pX = null, this.pY = null
         }
-        w(wn, je, {
+        S(Sn, Ht, {
             defaults: {
                 event: "pan",
                 threshold: 10,
                 pointers: 1,
-                direction: ef
+                direction: rh
             },
             getTouchAction: function() {
                 var u = this.options.direction,
-                    g = [];
-                return u & Ge && g.push(ks), u & lr && g.push(Ds), g
+                    _ = [];
+                return u & Gt && _.push(Ds), u & lr && _.push(ks), _
             },
             directionTest: function(u) {
-                var g = this.options,
-                    T = !0,
-                    S = u.distance,
+                var _ = this.options,
+                    b = !0,
+                    x = u.distance,
                     I = u.direction,
-                    D = u.deltaX,
-                    H = u.deltaY;
-                return I & g.direction || (g.direction & Ge ? (I = D === 0 ? mn : D < 0 ? Is : Os, T = D != this.pX, S = Math.abs(u.deltaX)) : (I = H === 0 ? mn : H < 0 ? Ns : Fs, T = H != this.pY, S = Math.abs(u.deltaY))), u.direction = I, T && S > g.threshold && I & g.direction
+                    k = u.deltaX,
+                    j = u.deltaY;
+                return I & _.direction || (_.direction & Gt ? (I = k === 0 ? mn : k < 0 ? Is : Os, b = k != this.pX, x = Math.abs(u.deltaX)) : (I = j === 0 ? mn : j < 0 ? Ns : Fs, b = j != this.pY, x = Math.abs(u.deltaY))), u.direction = I, b && x > _.threshold && I & _.direction
             },
             attrTest: function(u) {
-                return je.prototype.attrTest.call(this, u) && (this.state & Ie || !(this.state & Ie) && this.directionTest(u))
+                return Ht.prototype.attrTest.call(this, u) && (this.state & It || !(this.state & It) && this.directionTest(u))
             },
             emit: function(u) {
                 this.pX = u.deltaX, this.pY = u.deltaY;
-                var g = mf(u.direction);
-                g && (u.additionalEvent = this.options.event + g), this._super.emit.call(this, u)
+                var _ = bh(u.direction);
+                _ && (u.additionalEvent = this.options.event + _), this._super.emit.call(this, u)
             }
         });
 
-        function Ha() {
-            je.apply(this, arguments)
+        function ja() {
+            Ht.apply(this, arguments)
         }
-        w(Ha, je, {
+        S(ja, Ht, {
             defaults: {
                 event: "pinch",
                 threshold: 0,
                 pointers: 2
             },
             getTouchAction: function() {
-                return [hr]
+                return [fr]
             },
             attrTest: function(u) {
-                return this._super.attrTest.call(this, u) && (Math.abs(u.scale - 1) > this.options.threshold || this.state & Ie)
+                return this._super.attrTest.call(this, u) && (Math.abs(u.scale - 1) > this.options.threshold || this.state & It)
             },
             emit: function(u) {
                 if (u.scale !== 1) {
-                    var g = u.scale < 1 ? "in" : "out";
-                    u.additionalEvent = this.options.event + g
+                    var _ = u.scale < 1 ? "in" : "out";
+                    u.additionalEvent = this.options.event + _
                 }
                 this._super.emit.call(this, u)
             }
         });
 
-        function ja() {
-            yt.apply(this, arguments), this._timer = null, this._input = null
+        function Ha() {
+            ye.apply(this, arguments), this._timer = null, this._input = null
         }
-        w(ja, yt, {
+        S(Ha, ye, {
             defaults: {
                 event: "press",
                 pointers: 1,
                 time: 251,
                 threshold: 9
             },
             getTouchAction: function() {
-                return [gf]
+                return [gh]
             },
             process: function(u) {
-                var g = this.options,
-                    T = u.pointers.length === g.pointers,
-                    S = u.distance < g.threshold,
-                    I = u.deltaTime > g.time;
-                if (this._input = u, !S || !T || u.eventType & (te | xe) && !I) this.reset();
-                else if (u.eventType & Te) this.reset(), this._timer = h(function() {
-                    this.state = Tt, this.tryEmit()
-                }, g.time, this);
-                else if (u.eventType & te) return Tt;
-                return et
+                var _ = this.options,
+                    b = u.pointers.length === _.pointers,
+                    x = u.distance < _.threshold,
+                    I = u.deltaTime > _.time;
+                if (this._input = u, !x || !b || u.eventType & (et | Et) && !I) this.reset();
+                else if (u.eventType & bt) this.reset(), this._timer = f(function() {
+                    this.state = be, this.tryEmit()
+                }, _.time, this);
+                else if (u.eventType & et) return be;
+                return te
             },
             reset: function() {
                 clearTimeout(this._timer)
             },
             emit: function(u) {
-                this.state === Tt && (u && u.eventType & te ? this.manager.emit(this.options.event + "up", u) : (this._input.timeStamp = l(), this.manager.emit(this.options.event, this._input)))
+                this.state === be && (u && u.eventType & et ? this.manager.emit(this.options.event + "up", u) : (this._input.timeStamp = l(), this.manager.emit(this.options.event, this._input)))
             }
         });
 
         function Xa() {
-            je.apply(this, arguments)
+            Ht.apply(this, arguments)
         }
-        w(Xa, je, {
+        S(Xa, Ht, {
             defaults: {
                 event: "rotate",
                 threshold: 0,
                 pointers: 2
             },
             getTouchAction: function() {
-                return [hr]
+                return [fr]
             },
             attrTest: function(u) {
-                return this._super.attrTest.call(this, u) && (Math.abs(u.rotation) > this.options.threshold || this.state & Ie)
+                return this._super.attrTest.call(this, u) && (Math.abs(u.rotation) > this.options.threshold || this.state & It)
             }
         });
 
         function $a() {
-            je.apply(this, arguments)
+            Ht.apply(this, arguments)
         }
-        w($a, je, {
+        S($a, Ht, {
             defaults: {
                 event: "swipe",
                 threshold: 10,
                 velocity: .3,
-                direction: Ge | lr,
+                direction: Gt | lr,
                 pointers: 1
             },
             getTouchAction: function() {
-                return wn.prototype.getTouchAction.call(this)
+                return Sn.prototype.getTouchAction.call(this)
             },
             attrTest: function(u) {
-                var g = this.options.direction,
-                    T;
-                return g & (Ge | lr) ? T = u.overallVelocity : g & Ge ? T = u.overallVelocityX : g & lr && (T = u.overallVelocityY), this._super.attrTest.call(this, u) && g & u.offsetDirection && u.distance > this.options.threshold && u.maxPointers == this.options.pointers && c(T) > this.options.velocity && u.eventType & te
+                var _ = this.options.direction,
+                    b;
+                return _ & (Gt | lr) ? b = u.overallVelocity : _ & Gt ? b = u.overallVelocityX : _ & lr && (b = u.overallVelocityY), this._super.attrTest.call(this, u) && _ & u.offsetDirection && u.distance > this.options.threshold && u.maxPointers == this.options.pointers && c(b) > this.options.velocity && u.eventType & et
             },
             emit: function(u) {
-                var g = mf(u.offsetDirection);
-                g && this.manager.emit(this.options.event + g, u), this.manager.emit(this.options.event, u)
+                var _ = bh(u.offsetDirection);
+                _ && this.manager.emit(this.options.event + _, u), this.manager.emit(this.options.event, u)
             }
         });
 
         function Rn() {
-            yt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
+            ye.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
         }
-        w(Rn, yt, {
+        S(Rn, ye, {
             defaults: {
                 event: "tap",
                 pointers: 1,
                 taps: 1,
                 interval: 300,
                 time: 250,
                 threshold: 9,
                 posThreshold: 10
             },
             getTouchAction: function() {
                 return [Wa]
             },
             process: function(u) {
-                var g = this.options,
-                    T = u.pointers.length === g.pointers,
-                    S = u.distance < g.threshold,
-                    I = u.deltaTime < g.time;
-                if (this.reset(), u.eventType & Te && this.count === 0) return this.failTimeout();
-                if (S && I && T) {
-                    if (u.eventType != te) return this.failTimeout();
-                    var D = this.pTime ? u.timeStamp - this.pTime < g.interval : !0,
-                        H = !this.pCenter || yn(this.pCenter, u.center) < g.posThreshold;
-                    this.pTime = u.timeStamp, this.pCenter = u.center, !H || !D ? this.count = 1 : this.count += 1, this._input = u;
-                    var oe = this.count % g.taps;
-                    if (oe === 0) return this.hasRequireFailures() ? (this._timer = h(function() {
-                        this.state = Tt, this.tryEmit()
-                    }, g.interval, this), Ie) : Tt
+                var _ = this.options,
+                    b = u.pointers.length === _.pointers,
+                    x = u.distance < _.threshold,
+                    I = u.deltaTime < _.time;
+                if (this.reset(), u.eventType & bt && this.count === 0) return this.failTimeout();
+                if (x && I && b) {
+                    if (u.eventType != et) return this.failTimeout();
+                    var k = this.pTime ? u.timeStamp - this.pTime < _.interval : !0,
+                        j = !this.pCenter || yn(this.pCenter, u.center) < _.posThreshold;
+                    this.pTime = u.timeStamp, this.pCenter = u.center, !j || !k ? this.count = 1 : this.count += 1, this._input = u;
+                    var ot = this.count % _.taps;
+                    if (ot === 0) return this.hasRequireFailures() ? (this._timer = f(function() {
+                        this.state = be, this.tryEmit()
+                    }, _.interval, this), It) : be
                 }
-                return et
+                return te
             },
             failTimeout: function() {
-                return this._timer = h(function() {
-                    this.state = et
-                }, this.options.interval, this), et
+                return this._timer = f(function() {
+                    this.state = te
+                }, this.options.interval, this), te
             },
             reset: function() {
                 clearTimeout(this._timer)
             },
             emit: function() {
-                this.state == Tt && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
+                this.state == be && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
             }
         });
 
-        function Dt(u, g) {
-            return g = g || {}, g.recognizers = C(g.recognizers, Dt.defaults.preset), new Ya(u, g)
+        function ke(u, _) {
+            return _ = _ || {}, _.recognizers = C(_.recognizers, ke.defaults.preset), new Ya(u, _)
         }
-        Dt.VERSION = "2.0.7", Dt.defaults = {
+        ke.VERSION = "2.0.7", ke.defaults = {
             domEvents: !1,
-            touchAction: pf,
+            touchAction: _h,
             enable: !0,
             inputTarget: null,
             inputClass: null,
             preset: [
                 [Xa, {
                     enable: !1
                 }],
-                [Ha, {
+                [ja, {
                         enable: !1
                     },
                     ["rotate"]
                 ],
                 [$a, {
-                    direction: Ge
+                    direction: Gt
                 }],
-                [wn, {
-                        direction: Ge
+                [Sn, {
+                        direction: Gt
                     },
                     ["swipe"]
                 ],
                 [Rn],
                 [Rn, {
                         event: "doubletap",
                         taps: 2
                     },
                     ["tap"]
                 ],
-                [ja]
+                [Ha]
             ],
             cssProps: {
                 userSelect: "none",
                 touchSelect: "none",
                 touchCallout: "none",
                 contentZooming: "none",
                 userDrag: "none",
                 tapHighlightColor: "rgba(0,0,0,0)"
             }
         };
-        var Y_ = 1,
-            Tf = 2;
+        var Kg = 1,
+            yh = 2;
 
-        function Ya(u, g) {
-            this.options = y({}, Dt.defaults, g || {}), this.options.inputTarget = this.options.inputTarget || u, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = u, this.input = x_(this), this.touchAction = new za(this, this.options.touchAction), yf(this, !0), p(this.options.recognizers, function(T) {
-                var S = this.add(new T[0](T[1]));
-                T[2] && S.recognizeWith(T[2]), T[3] && S.requireFailure(T[3])
+        function Ya(u, _) {
+            this.options = y({}, ke.defaults, _ || {}), this.options.inputTarget = this.options.inputTarget || u, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = u, this.input = Sg(this), this.touchAction = new za(this, this.options.touchAction), Th(this, !0), p(this.options.recognizers, function(b) {
+                var x = this.add(new b[0](b[1]));
+                b[2] && x.recognizeWith(b[2]), b[3] && x.requireFailure(b[3])
             }, this)
         }
         Ya.prototype = {
             set: function(u) {
                 return y(this.options, u), u.touchAction && this.touchAction.update(), u.inputTarget && (this.input.destroy(), this.input.target = u.inputTarget, this.input.init()), this
             },
             stop: function(u) {
-                this.session.stopped = u ? Tf : Y_
+                this.session.stopped = u ? yh : Kg
             },
             recognize: function(u) {
-                var g = this.session;
-                if (!g.stopped) {
+                var _ = this.session;
+                if (!_.stopped) {
                     this.touchAction.preventDefaults(u);
-                    var T, S = this.recognizers,
-                        I = g.curRecognizer;
-                    (!I || I && I.state & Tt) && (I = g.curRecognizer = null);
-                    for (var D = 0; D < S.length;) T = S[D], g.stopped !== Tf && (!I || T == I || T.canRecognizeWith(I)) ? T.recognize(u) : T.reset(), !I && T.state & (Ie | Hr | Ft) && (I = g.curRecognizer = T), D++
+                    var b, x = this.recognizers,
+                        I = _.curRecognizer;
+                    (!I || I && I.state & be) && (I = _.curRecognizer = null);
+                    for (var k = 0; k < x.length;) b = x[k], _.stopped !== yh && (!I || b == I || b.canRecognizeWith(I)) ? b.recognize(u) : b.reset(), !I && b.state & (It | jr | Fe) && (I = _.curRecognizer = b), k++
                 }
             },
             get: function(u) {
-                if (u instanceof yt) return u;
-                for (var g = this.recognizers, T = 0; T < g.length; T++)
-                    if (g[T].options.event == u) return g[T];
+                if (u instanceof ye) return u;
+                for (var _ = this.recognizers, b = 0; b < _.length; b++)
+                    if (_[b].options.event == u) return _[b];
                 return null
             },
             add: function(u) {
                 if (d(u, "add", this)) return this;
-                var g = this.get(u.options.event);
-                return g && this.remove(g), this.recognizers.push(u), u.manager = this, this.touchAction.update(), u
+                var _ = this.get(u.options.event);
+                return _ && this.remove(_), this.recognizers.push(u), u.manager = this, this.touchAction.update(), u
             },
             remove: function(u) {
                 if (d(u, "remove", this)) return this;
                 if (u = this.get(u), u) {
-                    var g = this.recognizers,
-                        T = F(g, u);
-                    T !== -1 && (g.splice(T, 1), this.touchAction.update())
+                    var _ = this.recognizers,
+                        b = F(_, u);
+                    b !== -1 && (_.splice(b, 1), this.touchAction.update())
                 }
                 return this
             },
-            on: function(u, g) {
-                if (u !== s && g !== s) {
-                    var T = this.handlers;
-                    return p(B(u), function(S) {
-                        T[S] = T[S] || [], T[S].push(g)
+            on: function(u, _) {
+                if (u !== s && _ !== s) {
+                    var b = this.handlers;
+                    return p(B(u), function(x) {
+                        b[x] = b[x] || [], b[x].push(_)
                     }), this
                 }
             },
-            off: function(u, g) {
+            off: function(u, _) {
                 if (u !== s) {
-                    var T = this.handlers;
-                    return p(B(u), function(S) {
-                        g ? T[S] && T[S].splice(F(T[S], g), 1) : delete T[S]
+                    var b = this.handlers;
+                    return p(B(u), function(x) {
+                        _ ? b[x] && b[x].splice(F(b[x], _), 1) : delete b[x]
                     }), this
                 }
             },
-            emit: function(u, g) {
-                this.options.domEvents && q_(u, g);
-                var T = this.handlers[u] && this.handlers[u].slice();
-                if (!(!T || !T.length)) {
-                    g.type = u, g.preventDefault = function() {
-                        g.srcEvent.preventDefault()
+            emit: function(u, _) {
+                this.options.domEvents && Zg(u, _);
+                var b = this.handlers[u] && this.handlers[u].slice();
+                if (!(!b || !b.length)) {
+                    _.type = u, _.preventDefault = function() {
+                        _.srcEvent.preventDefault()
                     };
-                    for (var S = 0; S < T.length;) T[S](g), S++
+                    for (var x = 0; x < b.length;) b[x](_), x++
                 }
             },
             destroy: function() {
-                this.element && yf(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
+                this.element && Th(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
             }
         };
 
-        function yf(u, g) {
-            var T = u.element;
-            if (T.style) {
-                var S;
-                p(u.options.cssProps, function(I, D) {
-                    S = $(T.style, D), g ? (u.oldCssProps[S] = T.style[S], T.style[S] = I) : T.style[S] = u.oldCssProps[S] || ""
-                }), g || (u.oldCssProps = {})
+        function Th(u, _) {
+            var b = u.element;
+            if (b.style) {
+                var x;
+                p(u.options.cssProps, function(I, k) {
+                    x = $(b.style, k), _ ? (u.oldCssProps[x] = b.style[x], b.style[x] = I) : b.style[x] = u.oldCssProps[x] || ""
+                }), _ || (u.oldCssProps = {})
             }
         }
 
-        function q_(u, g) {
-            var T = e.createEvent("Event");
-            T.initEvent(u, !0, !0), T.gesture = g, g.target.dispatchEvent(T)
+        function Zg(u, _) {
+            var b = t.createEvent("Event");
+            b.initEvent(u, !0, !0), b.gesture = _, _.target.dispatchEvent(b)
         }
-        y(Dt, {
-            INPUT_START: Te,
+        y(ke, {
+            INPUT_START: bt,
             INPUT_MOVE: cr,
-            INPUT_END: te,
-            INPUT_CANCEL: xe,
-            STATE_POSSIBLE: xn,
-            STATE_BEGAN: Ie,
-            STATE_CHANGED: Hr,
-            STATE_ENDED: Ft,
-            STATE_RECOGNIZED: Tt,
+            INPUT_END: et,
+            INPUT_CANCEL: Et,
+            STATE_POSSIBLE: En,
+            STATE_BEGAN: It,
+            STATE_CHANGED: jr,
+            STATE_ENDED: Fe,
+            STATE_RECOGNIZED: be,
             STATE_CANCELLED: Bs,
-            STATE_FAILED: et,
+            STATE_FAILED: te,
             DIRECTION_NONE: mn,
             DIRECTION_LEFT: Is,
             DIRECTION_RIGHT: Os,
             DIRECTION_UP: Ns,
             DIRECTION_DOWN: Fs,
-            DIRECTION_HORIZONTAL: Ge,
+            DIRECTION_HORIZONTAL: Gt,
             DIRECTION_VERTICAL: lr,
-            DIRECTION_ALL: ef,
+            DIRECTION_ALL: rh,
             Manager: Ya,
-            Input: Ce,
+            Input: Ct,
             TouchAction: za,
-            TouchInput: En,
-            MouseInput: bn,
+            TouchInput: wn,
+            MouseInput: Tn,
             PointerEventInput: La,
             TouchMouseInput: Va,
-            SingleTouchInput: lf,
-            Recognizer: yt,
-            AttrRecognizer: je,
+            SingleTouchInput: fh,
+            Recognizer: ye,
+            AttrRecognizer: Ht,
             Tap: Rn,
-            Pan: wn,
+            Pan: Sn,
             Swipe: $a,
-            Pinch: Ha,
+            Pinch: ja,
             Rotate: Xa,
-            Press: ja,
+            Press: Ha,
             on: O,
             off: N,
             each: p,
-            merge: b,
-            extend: x,
+            merge: T,
+            extend: E,
             assign: y,
-            inherit: w,
+            inherit: S,
             bindFn: R,
             prefixed: $
         });
-        var K_ = typeof t < "u" ? t : typeof self < "u" ? self : {};
-        K_.Hammer = Dt, typeof xa < "u" && xa.exports ? xa.exports = Dt : t[r] = Dt
+        var Qg = typeof e < "u" ? e : typeof self < "u" ? self : {};
+        Qg.Hammer = ke, typeof Ea < "u" && Ea.exports ? Ea.exports = ke : e[r] = ke
     })(window, document, "Hammer")
 });
 
-function kt(t, e) {
-    if (!t) throw new Error(e || "loader assertion failed.")
+function De(e, t) {
+    if (!e) throw new Error(t || "loader assertion failed.")
 }
-var rt = {
+var re = {
         self: typeof self < "u" && self,
         window: typeof window < "u" && window,
         global: typeof global < "u" && global,
         document: typeof document < "u" && document
     },
-    nm = rt.self || rt.window || rt.global || {},
-    om = rt.window || rt.self || rt.global || {},
-    am = rt.global || rt.self || rt.window || {},
-    cm = rt.document || {};
-var fr = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser);
-var bf = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
-    lm = bf && parseFloat(bf[1]) || 0;
+    am = re.self || re.window || re.global || {},
+    cm = re.window || re.self || re.global || {},
+    lm = re.global || re.self || re.window || {},
+    fm = re.document || {};
+var hr = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser);
+var wh = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
+    hm = wh && parseFloat(wh[1]) || 0;
 
-function qa(t, e) {
-    return Ef(t || {}, e)
+function qa(e, t) {
+    return Ah(e || {}, t)
 }
 
-function Ef(t, e) {
+function Ah(e, t) {
     let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
-    if (r > 3) return e;
+    if (r > 3) return t;
     let s = {
-        ...t
+        ...e
     };
-    for (let [i, n] of Object.entries(e)) n && typeof n == "object" && !Array.isArray(n) ? s[i] = Ef(s[i] || {}, e[i], r + 1) : s[i] = e[i];
+    for (let [i, n] of Object.entries(t)) n && typeof n == "object" && !Array.isArray(n) ? s[i] = Ah(s[i] || {}, t[i], r + 1) : s[i] = t[i];
     return s
 }
-var Af = "latest";
+var Eh = "latest";
 
-function hm() {
-    var t;
-    return (t = globalThis._loadersgl_) !== null && t !== void 0 && t.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.1.4"), globalThis._loadersgl_.version
+function um() {
+    var e;
+    return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.1.4"), globalThis._loadersgl_.version
 }
-var Ka = hm();
+var Ka = um();
 
-function be(t, e) {
-    if (!t) throw new Error(e || "loaders.gl assertion failed.")
+function Tt(e, t) {
+    if (!e) throw new Error(t || "loaders.gl assertion failed.")
 }
-var st = {
+var se = {
         self: typeof self < "u" && self,
         window: typeof window < "u" && window,
         global: typeof global < "u" && global,
         document: typeof document < "u" && document
     },
-    pS = st.self || st.window || st.global || {},
-    gS = st.window || st.self || st.global || {},
-    _S = st.global || st.self || st.window || {},
-    mS = st.document || {};
-var Oe = typeof process != "object" || String(process) !== "[object process]" || process.browser;
-var Sf = typeof window < "u" && typeof window.orientation < "u",
-    xf = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
-    TS = xf && parseFloat(xf[1]) || 0;
+    mx = se.self || se.window || se.global || {},
+    bx = se.window || se.self || se.global || {},
+    yx = se.global || se.self || se.window || {},
+    Tx = se.document || {};
+var Ot = typeof process != "object" || String(process) !== "[object process]" || process.browser;
+var Sh = typeof window < "u" && typeof window.orientation < "u",
+    xh = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
+    wx = xh && parseFloat(xh[1]) || 0;
 var Ls = class {
-    constructor(e, r) {
-        this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = e, this.workerThread = r, this.result = new Promise((s, i) => {
+    constructor(t, r) {
+        this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = t, this.workerThread = r, this.result = new Promise((s, i) => {
             this._resolve = s, this._reject = i
         })
     }
-    postMessage(e, r) {
+    postMessage(t, r) {
         this.workerThread.postMessage({
             source: "loaders.gl",
-            type: e,
+            type: t,
             payload: r
         })
     }
-    done(e) {
-        be(this.isRunning), this.isRunning = !1, this._resolve(e)
+    done(t) {
+        Tt(this.isRunning), this.isRunning = !1, this._resolve(t)
     }
-    error(e) {
-        be(this.isRunning), this.isRunning = !1, this._reject(e)
+    error(t) {
+        Tt(this.isRunning), this.isRunning = !1, this._reject(t)
     }
 };
-var jr = class {
+var Hr = class {
     terminate() {}
 };
 var Za = new Map;
 
-function wf(t) {
-    be(t.source && !t.url || !t.source && t.url);
-    let e = Za.get(t.source || t.url);
-    return e || (t.url && (e = fm(t.url), Za.set(t.url, e)), t.source && (e = Rf(t.source), Za.set(t.source, e))), be(e), e
+function Rh(e) {
+    Tt(e.source && !e.url || !e.source && e.url);
+    let t = Za.get(e.source || e.url);
+    return t || (e.url && (t = dm(e.url), Za.set(e.url, t)), e.source && (t = vh(e.source), Za.set(e.source, t))), Tt(t), t
 }
 
-function fm(t) {
-    if (!t.startsWith("http")) return t;
-    let e = um(t);
-    return Rf(e)
+function dm(e) {
+    if (!e.startsWith("http")) return e;
+    let t = pm(e);
+    return vh(t)
 }
 
-function Rf(t) {
-    let e = new Blob([t], {
+function vh(e) {
+    let t = new Blob([e], {
         type: "application/javascript"
     });
-    return URL.createObjectURL(e)
+    return URL.createObjectURL(t)
 }
 
-function um(t) {
+function pm(e) {
     return `try {
-  importScripts('${t}');
+  importScripts('${e}');
 } catch (error) {
   console.error(error);
   throw error;
 }`
 }
 
-function Qa(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
+function Qa(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
         r = arguments.length > 2 ? arguments[2] : void 0,
         s = r || new Set;
-    if (t) {
-        if (vf(t)) s.add(t);
-        else if (vf(t.buffer)) s.add(t.buffer);
-        else if (!ArrayBuffer.isView(t)) {
-            if (e && typeof t == "object")
-                for (let i in t) Qa(t[i], e, s)
+    if (e) {
+        if (Mh(e)) s.add(e);
+        else if (Mh(e.buffer)) s.add(e.buffer);
+        else if (!ArrayBuffer.isView(e)) {
+            if (t && typeof e == "object")
+                for (let i in e) Qa(e[i], t, s)
         }
     }
     return r === void 0 ? Array.from(s) : []
 }
 
-function vf(t) {
-    return t ? t instanceof ArrayBuffer || typeof MessagePort < "u" && t instanceof MessagePort || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas : !1
+function Mh(e) {
+    return e ? e instanceof ArrayBuffer || typeof MessagePort < "u" && e instanceof MessagePort || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas : !1
 }
 var Ja = () => {},
-    Bt = class {
+    Be = class {
         static isSupported() {
-            return typeof Worker < "u" && Oe || typeof jr < "u" && !Oe
+            return typeof Worker < "u" && Ot || typeof Hr < "u" && !Ot
         }
-        constructor(e) {
+        constructor(t) {
             this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = "";
             let {
                 name: r,
                 source: s,
                 url: i
-            } = e;
-            be(s || i), this.name = r, this.source = s, this.url = i, this.onMessage = Ja, this.onError = n => console.log(n), this.worker = Oe ? this._createBrowserWorker() : this._createNodeWorker()
+            } = t;
+            Tt(s || i), this.name = r, this.source = s, this.url = i, this.onMessage = Ja, this.onError = n => console.log(n), this.worker = Ot ? this._createBrowserWorker() : this._createNodeWorker()
         }
         destroy() {
             this.onMessage = Ja, this.onError = Ja, this.worker.terminate(), this.terminated = !0
         }
         get isRunning() {
             return !!this.onMessage
         }
-        postMessage(e, r) {
-            r = r || Qa(e), this.worker.postMessage(e, r)
+        postMessage(t, r) {
+            r = r || Qa(t), this.worker.postMessage(t, r)
         }
-        _getErrorFromErrorEvent(e) {
+        _getErrorFromErrorEvent(t) {
             let r = "Failed to load ";
-            return r += `worker ${this.name} from ${this.url}. `, e.message && (r += `${e.message} in `), e.lineno && (r += `:${e.lineno}:${e.colno}`), new Error(r)
+            return r += `worker ${this.name} from ${this.url}. `, t.message && (r += `${t.message} in `), t.lineno && (r += `:${t.lineno}:${t.colno}`), new Error(r)
         }
         _createBrowserWorker() {
-            this._loadableURL = wf({
+            this._loadableURL = Rh({
                 source: this.source,
                 url: this.url
             });
-            let e = new Worker(this._loadableURL, {
+            let t = new Worker(this._loadableURL, {
                 name: this.name
             });
-            return e.onmessage = r => {
+            return t.onmessage = r => {
                 r.data ? this.onMessage(r.data) : this.onError(new Error("No data received"))
-            }, e.onerror = r => {
+            }, t.onerror = r => {
                 this.onError(this._getErrorFromErrorEvent(r)), this.terminated = !0
-            }, e.onmessageerror = r => console.error(r), e
+            }, t.onmessageerror = r => console.error(r), t
         }
         _createNodeWorker() {
-            let e;
+            let t;
             if (this.url) {
                 let s = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
-                e = new jr(s, {
+                t = new Hr(s, {
                     eval: !1
                 })
-            } else if (this.source) e = new jr(this.source, {
+            } else if (this.source) t = new Hr(this.source, {
                 eval: !0
             });
             else throw new Error("no worker");
-            return e.on("message", r => {
+            return t.on("message", r => {
                 this.onMessage(r)
-            }), e.on("error", r => {
+            }), t.on("error", r => {
                 this.onError(r)
-            }), e.on("exit", r => {}), e
+            }), t.on("exit", r => {}), t
         }
     };
 var Vs = class {
     static isSupported() {
-        return Bt.isSupported()
+        return Be.isSupported()
     }
-    constructor(e) {
-        this.name = "unnamed", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {}, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = e.source, this.url = e.url, this.setProps(e)
+    constructor(t) {
+        this.name = "unnamed", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {}, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t)
     }
     destroy() {
-        this.idleQueue.forEach(e => e.destroy()), this.isDestroyed = !0
+        this.idleQueue.forEach(t => t.destroy()), this.isDestroyed = !0
     }
-    setProps(e) {
+    setProps(t) {
         this.props = {
             ...this.props,
-            ...e
-        }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug)
+            ...t
+        }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug)
     }
-    async startJob(e) {
+    async startJob(t) {
         let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n, o, a) => n.done(a),
             s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (n, o) => n.error(o),
             i = new Promise(n => (this.jobQueue.push({
-                name: e,
+                name: t,
                 onMessage: r,
                 onError: s,
                 onStart: n
             }), this));
         return this._startQueuedJob(), await i
     }
     async _startQueuedJob() {
         if (!this.jobQueue.length) return;
-        let e = this._getAvailableWorker();
-        if (!e) return;
+        let t = this._getAvailableWorker();
+        if (!t) return;
         let r = this.jobQueue.shift();
         if (r) {
             this.onDebug({
                 message: "Starting job",
                 name: r.name,
-                workerThread: e,
+                workerThread: t,
                 backlog: this.jobQueue.length
             });
-            let s = new Ls(r.name, e);
-            e.onMessage = i => r.onMessage(s, i.type, i.payload), e.onError = i => r.onError(s, i), r.onStart(s);
+            let s = new Ls(r.name, t);
+            t.onMessage = i => r.onMessage(s, i.type, i.payload), t.onError = i => r.onError(s, i), r.onStart(s);
             try {
                 await s.result
             } catch (i) {
                 console.error(`Worker exception: ${i}`)
             } finally {
-                this.returnWorkerToQueue(e)
+                this.returnWorkerToQueue(t)
             }
         }
     }
-    returnWorkerToQueue(e) {
-        !Oe || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob()
+    returnWorkerToQueue(t) {
+        !Ot || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob()
     }
     _getAvailableWorker() {
         if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
         if (this.count < this._getMaxConcurrency()) {
             this.count++;
-            let e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
-            return new Bt({
-                name: e,
+            let t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
+            return new Be({
+                name: t,
                 source: this.source,
                 url: this.url
             })
         }
         return null
     }
     _getMaxConcurrency() {
-        return Sf ? this.maxMobileConcurrency : this.maxConcurrency
+        return Sh ? this.maxMobileConcurrency : this.maxConcurrency
     }
 };
-var dm = {
+var _m = {
         maxConcurrency: 3,
         maxMobileConcurrency: 1,
         reuseWorkers: !0,
         onDebug: () => {}
     },
-    Ut = class t {
+    Ue = class e {
         static isSupported() {
-            return Bt.isSupported()
+            return Be.isSupported()
         }
         static getWorkerFarm() {
-            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
-            return t._workerFarm = t._workerFarm || new t({}), t._workerFarm.setProps(e), t._workerFarm
+            let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
+            return e._workerFarm = e._workerFarm || new e({}), e._workerFarm.setProps(t), e._workerFarm
         }
-        constructor(e) {
+        constructor(t) {
             this.props = void 0, this.workerPools = new Map, this.props = {
-                ...dm
-            }, this.setProps(e), this.workerPools = new Map
+                ..._m
+            }, this.setProps(t), this.workerPools = new Map
         }
         destroy() {
-            for (let e of this.workerPools.values()) e.destroy();
+            for (let t of this.workerPools.values()) t.destroy();
             this.workerPools = new Map
         }
-        setProps(e) {
+        setProps(t) {
             this.props = {
                 ...this.props,
-                ...e
+                ...t
             };
             for (let r of this.workerPools.values()) r.setProps(this._getWorkerPoolProps())
         }
-        getWorkerPool(e) {
+        getWorkerPool(t) {
             let {
                 name: r,
                 source: s,
                 url: i
-            } = e, n = this.workerPools.get(r);
+            } = t, n = this.workerPools.get(r);
             return n || (n = new Vs({
                 name: r,
                 source: s,
                 url: i
             }), n.setProps(this._getWorkerPoolProps()), this.workerPools.set(r, n)), n
         }
         _getWorkerPoolProps() {
@@ -1354,147 +1354,147 @@
                 maxConcurrency: this.props.maxConcurrency,
                 maxMobileConcurrency: this.props.maxMobileConcurrency,
                 reuseWorkers: this.props.reuseWorkers,
                 onDebug: this.props.onDebug
             }
         }
     };
-Ut._workerFarm = void 0;
+Ue._workerFarm = void 0;
 
-function Ga(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
-        r = e[t.id] || {},
-        s = Oe ? `${t.id}-worker.js` : `${t.id}-worker-node.js`,
+function Ga(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
+        r = t[e.id] || {},
+        s = Ot ? `${e.id}-worker.js` : `${e.id}-worker-node.js`,
         i = r.workerUrl;
-    if (!i && t.id === "compression" && (i = e.workerUrl), e._workerType === "test" && (Oe ? i = `modules/${t.module}/dist/${s}` : i = `modules/${t.module}/src/workers/${t.id}-worker-node.ts`), !i) {
-        let n = t.version;
-        n === "latest" && (n = Af);
+    if (!i && e.id === "compression" && (i = t.workerUrl), t._workerType === "test" && (Ot ? i = `modules/${e.module}/dist/${s}` : i = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !i) {
+        let n = e.version;
+        n === "latest" && (n = Eh);
         let o = n ? `@${n}` : "";
-        i = `https://unpkg.com/@loaders.gl/${t.module}${o}/dist/${s}`
+        i = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${s}`
     }
-    return be(i), i
+    return Tt(i), i
 }
 
-function ec(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ka;
-    be(t, "no worker provided");
-    let r = t.version;
-    return !(!e || !r)
+function tc(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ka;
+    Tt(e, "no worker provided");
+    let r = e.version;
+    return !(!t || !r)
 }
 
-function tc(t, e) {
-    return !Ut.isSupported() || !Oe && !(e != null && e._nodeWorkers) ? !1 : t.worker && e?.worker
+function ec(e, t) {
+    return !Ue.isSupported() || !Ot && !(t != null && t._nodeWorkers) ? !1 : e.worker && t?.worker
 }
-async function rc(t, e, r, s, i) {
-    let n = t.id,
-        o = Ga(t, r),
-        c = Ut.getWorkerFarm(r).getWorkerPool({
+async function rc(e, t, r, s, i) {
+    let n = e.id,
+        o = Ga(e, r),
+        c = Ue.getWorkerFarm(r).getWorkerPool({
             name: n,
             url: o
         });
     r = JSON.parse(JSON.stringify(r)), s = JSON.parse(JSON.stringify(s || {}));
-    let l = await c.startJob("process-on-worker", pm.bind(null, i));
+    let l = await c.startJob("process-on-worker", gm.bind(null, i));
     return l.postMessage("process", {
-        input: e,
+        input: t,
         options: r,
         context: s
     }), await (await l.result).result
 }
-async function pm(t, e, r, s) {
+async function gm(e, t, r, s) {
     switch (r) {
         case "done":
-            e.done(s);
+            t.done(s);
             break;
         case "error":
-            e.error(new Error(s.error));
+            t.error(new Error(s.error));
             break;
         case "process":
             let {
                 id: i, input: n, options: o
             } = s;
             try {
-                let a = await t(n, o);
-                e.postMessage("done", {
+                let a = await e(n, o);
+                t.postMessage("done", {
                     id: i,
                     result: a
                 })
             } catch (a) {
                 let c = a instanceof Error ? a.message : "unknown error";
-                e.postMessage("error", {
+                t.postMessage("error", {
                     id: i,
                     error: c
                 })
             }
             break;
         default:
             console.warn(`parse-with-worker unknown message ${r}`)
     }
 }
 
-function sc(t, e, r) {
-    if (r = r || t.byteLength, t.byteLength < r || e.byteLength < r) return !1;
-    let s = new Uint8Array(t),
-        i = new Uint8Array(e);
+function sc(e, t, r) {
+    if (r = r || e.byteLength, e.byteLength < r || t.byteLength < r) return !1;
+    let s = new Uint8Array(e),
+        i = new Uint8Array(t);
     for (let n = 0; n < s.length; ++n)
         if (s[n] !== i[n]) return !1;
     return !0
 }
 
 function ic() {
-    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
-    return Mf(e)
+    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
+    return Ph(t)
 }
 
-function Mf(t) {
-    let e = t.map(n => n instanceof ArrayBuffer ? new Uint8Array(n) : n),
-        r = e.reduce((n, o) => n + o.byteLength, 0),
+function Ph(e) {
+    let t = e.map(n => n instanceof ArrayBuffer ? new Uint8Array(n) : n),
+        r = t.reduce((n, o) => n + o.byteLength, 0),
         s = new Uint8Array(r),
         i = 0;
-    for (let n of e) s.set(n, i), i += n.byteLength;
+    for (let n of t) s.set(n, i), i += n.byteLength;
     return s.buffer
 }
-async function nc(t) {
-    let e = [];
-    for await (let r of t) e.push(r);
-    return ic(...e)
+async function nc(e) {
+    let t = [];
+    for await (let r of e) t.push(r);
+    return ic(...t)
 }
 
 function Ws() {
-    let t;
-    if (typeof window < "u" && window.performance) t = window.performance.now();
+    let e;
+    if (typeof window < "u" && window.performance) e = window.performance.now();
     else if (typeof process < "u" && process.hrtime) {
-        let e = process.hrtime();
-        t = e[0] * 1e3 + e[1] / 1e6
-    } else t = Date.now();
-    return t
+        let t = process.hrtime();
+        e = t[0] * 1e3 + t[1] / 1e6
+    } else e = Date.now();
+    return e
 }
 var ur = class {
-    constructor(e, r) {
-        this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = r, this.reset()
+    constructor(t, r) {
+        this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = r, this.reset()
     }
     reset() {
         return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this
     }
-    setSampleSize(e) {
-        return this.sampleSize = e, this
+    setSampleSize(t) {
+        return this.sampleSize = t, this
     }
     incrementCount() {
         return this.addCount(1), this
     }
     decrementCount() {
         return this.subtractCount(1), this
     }
-    addCount(e) {
-        return this._count += e, this._samples++, this._checkSampling(), this
+    addCount(t) {
+        return this._count += t, this._samples++, this._checkSampling(), this
     }
-    subtractCount(e) {
-        return this._count -= e, this._samples++, this._checkSampling(), this
+    subtractCount(t) {
+        return this._count -= t, this._samples++, this._checkSampling(), this
     }
-    addTime(e) {
-        return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this
+    addTime(t) {
+        return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this
     }
     timeStart() {
         return this._startTime = Ws(), this._timerPending = !0, this
     }
     timeEnd() {
         return this._timerPending ? (this.addTime(Ws() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
     }
@@ -1516,135 +1516,135 @@
     getHz() {
         return this.time > 0 ? this.samples / (this.time / 1e3) : 0
     }
     _checkSampling() {
         this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0)
     }
 };
-var Ne = class {
-    constructor(e) {
-        this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this)
+var Nt = class {
+    constructor(t) {
+        this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this)
     }
-    get(e, r = "count") {
+    get(t, r = "count") {
         return this._getOrCreate({
-            name: e,
+            name: t,
             type: r
         })
     }
     get size() {
         return Object.keys(this.stats).length
     }
     reset() {
-        for (let e of Object.values(this.stats)) e.reset();
+        for (let t of Object.values(this.stats)) t.reset();
         return this
     }
-    forEach(e) {
-        for (let r of Object.values(this.stats)) e(r)
+    forEach(t) {
+        for (let r of Object.values(this.stats)) t(r)
     }
     getTable() {
-        let e = {};
+        let t = {};
         return this.forEach(r => {
-            e[r.name] = {
+            t[r.name] = {
                 time: r.time || 0,
                 count: r.count || 0,
                 average: r.getAverageTime() || 0,
                 hz: r.getHz() || 0
             }
-        }), e
+        }), t
     }
-    _initializeStats(e = []) {
-        e.forEach(r => this._getOrCreate(r))
+    _initializeStats(t = []) {
+        t.forEach(r => this._getOrCreate(r))
     }
-    _getOrCreate(e) {
+    _getOrCreate(t) {
         let {
             name: r,
             type: s
-        } = e, i = this.stats[r];
-        return i || (e instanceof ur ? i = e : i = new ur(r, s), this.stats[r] = i), i
+        } = t, i = this.stats[r];
+        return i || (t instanceof ur ? i = t : i = new ur(r, s), this.stats[r] = i), i
     }
 };
-var gm = "",
-    Pf = {};
+var mm = "",
+    Ch = {};
 
-function oc(t) {
-    for (let e in Pf)
-        if (t.startsWith(e)) {
-            let r = Pf[e];
-            t = t.replace(e, r)
-        } return !t.startsWith("http://") && !t.startsWith("https://") && (t = `${gm}${t}`), t
+function oc(e) {
+    for (let t in Ch)
+        if (e.startsWith(t)) {
+            let r = Ch[t];
+            e = e.replace(t, r)
+        } return !e.startsWith("http://") && !e.startsWith("https://") && (e = `${mm}${e}`), e
 }
 
-function Cf(t) {
-    return t && typeof t == "object" && t.isBuffer
+function Ih(e) {
+    return e && typeof e == "object" && e.isBuffer
 }
 
-function Mn(t) {
-    if (Cf(t)) return t;
-    if (t instanceof ArrayBuffer) return t;
-    if (ArrayBuffer.isView(t)) return t.byteOffset === 0 && t.byteLength === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
-    if (typeof t == "string") {
-        let e = t;
-        return new TextEncoder().encode(e).buffer
+function Mn(e) {
+    if (Ih(e)) return e;
+    if (e instanceof ArrayBuffer) return e;
+    if (ArrayBuffer.isView(e)) return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
+    if (typeof e == "string") {
+        let t = e;
+        return new TextEncoder().encode(t).buffer
     }
-    if (t && typeof t == "object" && t._toArrayBuffer) return t._toArrayBuffer();
+    if (e && typeof e == "object" && e._toArrayBuffer) return e._toArrayBuffer();
     throw new Error("toArrayBuffer")
 }
 var dr = {};
 Us(dr, {
-    dirname: () => mm,
-    filename: () => _m,
+    dirname: () => ym,
+    filename: () => bm,
     join: () => Tm,
-    resolve: () => ym
+    resolve: () => wm
 });
 
-function If() {
-    var t;
+function Oh() {
+    var e;
     if (typeof process < "u" && typeof process.cwd < "u") return process.cwd();
-    let e = (t = window.location) === null || t === void 0 ? void 0 : t.pathname;
-    return e?.slice(0, e.lastIndexOf("/") + 1) || ""
+    let t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;
+    return t?.slice(0, t.lastIndexOf("/") + 1) || ""
 }
 
-function _m(t) {
-    let e = t ? t.lastIndexOf("/") : -1;
-    return e >= 0 ? t.substr(e + 1) : ""
+function bm(e) {
+    let t = e ? e.lastIndexOf("/") : -1;
+    return t >= 0 ? e.substr(t + 1) : ""
 }
 
-function mm(t) {
-    let e = t ? t.lastIndexOf("/") : -1;
-    return e >= 0 ? t.substr(0, e) : ""
+function ym(e) {
+    let t = e ? e.lastIndexOf("/") : -1;
+    return t >= 0 ? e.substr(0, t) : ""
 }
 
 function Tm() {
-    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
+    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
     let s = "/";
-    return e = e.map((i, n) => (n && (i = i.replace(new RegExp(`^${s}`), "")), n !== e.length - 1 && (i = i.replace(new RegExp(`${s}$`), "")), i)), e.join(s)
+    return t = t.map((i, n) => (n && (i = i.replace(new RegExp(`^${s}`), "")), n !== t.length - 1 && (i = i.replace(new RegExp(`${s}$`), "")), i)), t.join(s)
 }
 
-function ym() {
-    let t = [];
-    for (let i = 0; i < arguments.length; i++) t[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
-    let e = "",
+function wm() {
+    let e = [];
+    for (let i = 0; i < arguments.length; i++) e[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
+    let t = "",
         r = !1,
         s;
-    for (let i = t.length - 1; i >= -1 && !r; i--) {
+    for (let i = e.length - 1; i >= -1 && !r; i--) {
         let n;
-        i >= 0 ? n = t[i] : (s === void 0 && (s = If()), n = s), n.length !== 0 && (e = `${n}/${e}`, r = n.charCodeAt(0) === zs)
+        i >= 0 ? n = e[i] : (s === void 0 && (s = Oh()), n = s), n.length !== 0 && (t = `${n}/${t}`, r = n.charCodeAt(0) === zs)
     }
-    return e = bm(e, !r), r ? `/${e}` : e.length > 0 ? e : "."
+    return t = Am(t, !r), r ? `/${t}` : t.length > 0 ? t : "."
 }
 var zs = 47,
     ac = 46;
 
-function bm(t, e) {
+function Am(e, t) {
     let r = "",
         s = -1,
         i = 0,
         n, o = !1;
-    for (let a = 0; a <= t.length; ++a) {
-        if (a < t.length) n = t.charCodeAt(a);
+    for (let a = 0; a <= e.length; ++a) {
+        if (a < e.length) n = e.charCodeAt(a);
         else {
             if (n === zs) break;
             n = zs
         }
         if (n === zs) {
             if (!(s === a - 1 || i === 1))
                 if (s !== a - 1 && i === 2) {
@@ -1658,491 +1658,491 @@
                                 continue
                             }
                         } else if (r.length === 2 || r.length === 1) {
                             r = "", s = a, i = 0, o = !1;
                             continue
                         }
                     }
-                    e && (r.length > 0 ? r += "/.." : r = "..", o = !0)
+                    t && (r.length > 0 ? r += "/.." : r = "..", o = !0)
                 } else {
-                    let c = t.slice(s + 1, a);
+                    let c = e.slice(s + 1, a);
                     r.length > 0 ? r += `/${c}` : r = c, o = !1
                 } s = a, i = 0
         } else n === ac && i !== -1 ? ++i : i = -1
     }
     return r
 }
-var Em = t => typeof t == "boolean",
-    Hs = t => typeof t == "function",
-    pr = t => t !== null && typeof t == "object",
-    cc = t => pr(t) && t.constructor === {}.constructor;
-var Of = t => !!t && typeof t[Symbol.iterator] == "function",
-    Nf = t => t && typeof t[Symbol.asyncIterator] == "function";
-var Fe = t => typeof Response < "u" && t instanceof Response || t && t.arrayBuffer && t.text && t.json;
-var De = t => typeof Blob < "u" && t instanceof Blob,
-    Ff = t => t && typeof t == "object" && t.isBuffer;
-var Am = t => typeof ReadableStream < "u" && t instanceof ReadableStream || pr(t) && Hs(t.tee) && Hs(t.cancel) && Hs(t.getReader);
-var xm = t => pr(t) && Hs(t.read) && Hs(t.pipe) && Em(t.readable),
-    Pn = t => Am(t) || xm(t);
-var Sm = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
-    wm = /^([-\w.]+\/[-\w.+]+)/;
-
-function Df(t) {
-    let e = wm.exec(t);
-    return e ? e[1] : t
-}
-
-function lc(t) {
-    let e = Sm.exec(t);
-    return e ? e[1] : ""
-}
-var kf = /\?.*/;
-
-function Bf(t) {
-    let e = t.match(kf);
-    return e && e[0]
-}
-
-function Xr(t) {
-    return t.replace(kf, "")
-}
-
-function gr(t) {
-    return Fe(t) ? t.url : De(t) ? t.name || "" : typeof t == "string" ? t : ""
-}
-
-function js(t) {
-    if (Fe(t)) {
-        let e = t,
-            r = e.headers.get("content-type") || "",
-            s = Xr(e.url);
-        return Df(r) || lc(s)
-    }
-    return De(t) ? t.type || "" : typeof t == "string" ? lc(t) : ""
-}
-
-function Uf(t) {
-    return Fe(t) ? t.headers["content-length"] || -1 : De(t) ? t.size : typeof t == "string" ? t.length : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? t.byteLength : -1
-}
-async function Cn(t) {
-    if (Fe(t)) return t;
-    let e = {},
-        r = Uf(t);
-    r >= 0 && (e["content-length"] = String(r));
-    let s = gr(t),
-        i = js(t);
-    i && (e["content-type"] = i);
-    let n = await vm(t);
-    n && (e["x-first-bytes"] = n), typeof t == "string" && (t = new TextEncoder().encode(t));
-    let o = new Response(t, {
-        headers: e
+var Em = e => typeof e == "boolean",
+    js = e => typeof e == "function",
+    pr = e => e !== null && typeof e == "object",
+    cc = e => pr(e) && e.constructor === {}.constructor;
+var Nh = e => !!e && typeof e[Symbol.iterator] == "function",
+    Fh = e => e && typeof e[Symbol.asyncIterator] == "function";
+var Ft = e => typeof Response < "u" && e instanceof Response || e && e.arrayBuffer && e.text && e.json;
+var kt = e => typeof Blob < "u" && e instanceof Blob,
+    kh = e => e && typeof e == "object" && e.isBuffer;
+var xm = e => typeof ReadableStream < "u" && e instanceof ReadableStream || pr(e) && js(e.tee) && js(e.cancel) && js(e.getReader);
+var Sm = e => pr(e) && js(e.read) && js(e.pipe) && Em(e.readable),
+    Pn = e => xm(e) || Sm(e);
+var Rm = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
+    vm = /^([-\w.]+\/[-\w.+]+)/;
+
+function Dh(e) {
+    let t = vm.exec(e);
+    return t ? t[1] : e
+}
+
+function lc(e) {
+    let t = Rm.exec(e);
+    return t ? t[1] : ""
+}
+var Bh = /\?.*/;
+
+function Uh(e) {
+    let t = e.match(Bh);
+    return t && t[0]
+}
+
+function Xr(e) {
+    return e.replace(Bh, "")
+}
+
+function _r(e) {
+    return Ft(e) ? e.url : kt(e) ? e.name || "" : typeof e == "string" ? e : ""
+}
+
+function Hs(e) {
+    if (Ft(e)) {
+        let t = e,
+            r = t.headers.get("content-type") || "",
+            s = Xr(t.url);
+        return Dh(r) || lc(s)
+    }
+    return kt(e) ? e.type || "" : typeof e == "string" ? lc(e) : ""
+}
+
+function Lh(e) {
+    return Ft(e) ? e.headers["content-length"] || -1 : kt(e) ? e.size : typeof e == "string" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1
+}
+async function Cn(e) {
+    if (Ft(e)) return e;
+    let t = {},
+        r = Lh(e);
+    r >= 0 && (t["content-length"] = String(r));
+    let s = _r(e),
+        i = Hs(e);
+    i && (t["content-type"] = i);
+    let n = await Pm(e);
+    n && (t["x-first-bytes"] = n), typeof e == "string" && (e = new TextEncoder().encode(e));
+    let o = new Response(e, {
+        headers: t
     });
     return Object.defineProperty(o, "url", {
         value: s
     }), o
 }
-async function Lf(t) {
-    if (!t.ok) {
-        let e = await Rm(t);
-        throw new Error(e)
+async function Vh(e) {
+    if (!e.ok) {
+        let t = await Mm(e);
+        throw new Error(t)
     }
 }
-async function Rm(t) {
-    let e = `Failed to fetch resource ${t.url} (${t.status}): `;
+async function Mm(e) {
+    let t = `Failed to fetch resource ${e.url} (${e.status}): `;
     try {
-        let r = t.headers.get("Content-Type"),
-            s = t.statusText;
-        r != null && r.includes("application/json") && (s += ` ${await t.text()}`), e += s, e = e.length > 60 ? `${e.slice(0,60)}...` : e
+        let r = e.headers.get("Content-Type"),
+            s = e.statusText;
+        r != null && r.includes("application/json") && (s += ` ${await e.text()}`), t += s, t = t.length > 60 ? `${t.slice(0,60)}...` : t
     } catch {}
-    return e
+    return t
 }
-async function vm(t) {
-    if (typeof t == "string") return `data:,${t.slice(0,5)}`;
-    if (t instanceof Blob) {
-        let r = t.slice(0, 5);
+async function Pm(e) {
+    if (typeof e == "string") return `data:,${e.slice(0,5)}`;
+    if (e instanceof Blob) {
+        let r = e.slice(0, 5);
         return await new Promise(s => {
             let i = new FileReader;
             i.onload = n => {
                 var o;
                 return s(n == null || (o = n.target) === null || o === void 0 ? void 0 : o.result)
             }, i.readAsDataURL(r)
         })
     }
-    if (t instanceof ArrayBuffer) {
-        let r = t.slice(0, 5);
-        return `data:base64,${Mm(r)}`
+    if (e instanceof ArrayBuffer) {
+        let r = e.slice(0, 5);
+        return `data:base64,${Cm(r)}`
     }
     return null
 }
 
-function Mm(t) {
-    let e = "",
-        r = new Uint8Array(t);
-    for (let s = 0; s < r.byteLength; s++) e += String.fromCharCode(r[s]);
-    return btoa(e)
+function Cm(e) {
+    let t = "",
+        r = new Uint8Array(e);
+    for (let s = 0; s < r.byteLength; s++) t += String.fromCharCode(r[s]);
+    return btoa(t)
 }
 
-function Pm(t) {
-    return !Cm(t) && !Im(t)
+function Im(e) {
+    return !Om(e) && !Nm(e)
 }
 
-function Cm(t) {
-    return t.startsWith("http:") || t.startsWith("https:")
+function Om(e) {
+    return e.startsWith("http:") || e.startsWith("https:")
 }
 
-function Im(t) {
-    return t.startsWith("data:")
+function Nm(e) {
+    return e.startsWith("data:")
 }
-async function hc(t, e) {
-    if (typeof t == "string") {
-        let i = oc(t);
-        if (Pm(i)) {
+async function fc(e, t) {
+    if (typeof e == "string") {
+        let i = oc(e);
+        if (Im(i)) {
             var r;
             if ((r = globalThis.loaders) !== null && r !== void 0 && r.fetchNode) {
                 var s;
-                return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(i, e)
+                return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(i, t)
             }
         }
-        return await fetch(i, e)
+        return await fetch(i, t)
     }
-    return await Cn(t)
+    return await Cn(e)
 }
 var In = globalThis,
-    Om = globalThis.document || {},
+    Fm = globalThis.document || {},
     On = globalThis.process || {},
-    Nm = globalThis.console,
-    Vf = globalThis.navigator || {};
+    km = globalThis.console,
+    Wh = globalThis.navigator || {};
 
-function Nn(t) {
+function Nn(e) {
     if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron) return !0;
-    let e = typeof navigator < "u" && navigator.userAgent,
-        r = t || e;
+    let t = typeof navigator < "u" && navigator.userAgent,
+        r = e || t;
     return !!(r && r.indexOf("Electron") >= 0)
 }
 
-function pe() {
+function pt() {
     return !(typeof process == "object" && String(process) === "[object process]" && !process?.browser) || Nn()
 }
 
-function fc(t) {
-    return !t && !pe() ? "Node" : Nn(t) ? "Electron" : (t || Vf.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown"
+function hc(e) {
+    return !e && !pt() ? "Node" : Nn(e) ? "Electron" : (e || Wh.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown"
 }
 var uc = "4.0.7";
 
-function Dm(t) {
+function Bm(e) {
     try {
-        let e = window[t],
+        let t = window[e],
             r = "__storage_test__";
-        return e.setItem(r, r), e.removeItem(r), e
+        return t.setItem(r, r), t.removeItem(r), t
     } catch {
         return null
     }
 }
 var Fn = class {
-    constructor(e, r, s = "sessionStorage") {
-        this.storage = Dm(s), this.id = e, this.config = r, this._loadConfiguration()
+    constructor(t, r, s = "sessionStorage") {
+        this.storage = Bm(s), this.id = t, this.config = r, this._loadConfiguration()
     }
     getConfiguration() {
         return this.config
     }
-    setConfiguration(e) {
-        if (Object.assign(this.config, e), this.storage) {
+    setConfiguration(t) {
+        if (Object.assign(this.config, t), this.storage) {
             let r = JSON.stringify(this.config);
             this.storage.setItem(this.id, r)
         }
     }
     _loadConfiguration() {
-        let e = {};
+        let t = {};
         if (this.storage) {
             let r = this.storage.getItem(this.id);
-            e = r ? JSON.parse(r) : {}
+            t = r ? JSON.parse(r) : {}
         }
-        return Object.assign(this.config, e), this
+        return Object.assign(this.config, t), this
     }
 };
 
-function Wf(t) {
-    let e;
-    return t < 10 ? e = `${t.toFixed(2)}ms` : t < 100 ? e = `${t.toFixed(1)}ms` : t < 1e3 ? e = `${t.toFixed(0)}ms` : e = `${(t/1e3).toFixed(2)}s`, e
+function zh(e) {
+    let t;
+    return e < 10 ? t = `${e.toFixed(2)}ms` : e < 100 ? t = `${e.toFixed(1)}ms` : e < 1e3 ? t = `${e.toFixed(0)}ms` : t = `${(e/1e3).toFixed(2)}s`, t
 }
 
-function zf(t, e = 8) {
-    let r = Math.max(e - t.length, 0);
-    return `${" ".repeat(r)}${t}`
+function jh(e, t = 8) {
+    let r = Math.max(t - e.length, 0);
+    return `${" ".repeat(r)}${e}`
 }
-var Dn;
-(function(t) {
-    t[t.BLACK = 30] = "BLACK", t[t.RED = 31] = "RED", t[t.GREEN = 32] = "GREEN", t[t.YELLOW = 33] = "YELLOW", t[t.BLUE = 34] = "BLUE", t[t.MAGENTA = 35] = "MAGENTA", t[t.CYAN = 36] = "CYAN", t[t.WHITE = 37] = "WHITE", t[t.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", t[t.BRIGHT_RED = 91] = "BRIGHT_RED", t[t.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", t[t.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", t[t.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", t[t.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", t[t.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", t[t.BRIGHT_WHITE = 97] = "BRIGHT_WHITE"
-})(Dn || (Dn = {}));
-var km = 10;
+var kn;
+(function(e) {
+    e[e.BLACK = 30] = "BLACK", e[e.RED = 31] = "RED", e[e.GREEN = 32] = "GREEN", e[e.YELLOW = 33] = "YELLOW", e[e.BLUE = 34] = "BLUE", e[e.MAGENTA = 35] = "MAGENTA", e[e.CYAN = 36] = "CYAN", e[e.WHITE = 37] = "WHITE", e[e.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", e[e.BRIGHT_RED = 91] = "BRIGHT_RED", e[e.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", e[e.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", e[e.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", e[e.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", e[e.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", e[e.BRIGHT_WHITE = 97] = "BRIGHT_WHITE"
+})(kn || (kn = {}));
+var Um = 10;
 
-function Hf(t) {
-    return typeof t != "string" ? t : (t = t.toUpperCase(), Dn[t] || Dn.WHITE)
+function Hh(e) {
+    return typeof e != "string" ? e : (e = e.toUpperCase(), kn[e] || kn.WHITE)
 }
 
-function jf(t, e, r) {
-    return !pe && typeof t == "string" && (e && (t = `\x1B[${Hf(e)}m${t}\x1B[39m`), r && (t = `\x1B[${Hf(r)+km}m${t}\x1B[49m`)), t
+function Xh(e, t, r) {
+    return !pt && typeof e == "string" && (t && (e = `\x1B[${Hh(t)}m${e}\x1B[39m`), r && (e = `\x1B[${Hh(r)+Um}m${e}\x1B[49m`)), e
 }
 
-function Xf(t, e = ["constructor"]) {
-    let r = Object.getPrototypeOf(t),
+function $h(e, t = ["constructor"]) {
+    let r = Object.getPrototypeOf(e),
         s = Object.getOwnPropertyNames(r),
-        i = t;
+        i = e;
     for (let n of s) {
         let o = i[n];
-        typeof o == "function" && (e.find(a => n === a) || (i[n] = o.bind(t)))
+        typeof o == "function" && (t.find(a => n === a) || (i[n] = o.bind(e)))
     }
 }
 
-function Xs(t, e) {
-    if (!t) throw new Error(e || "Assertion failed")
+function Xs(e, t) {
+    if (!e) throw new Error(t || "Assertion failed")
 }
 
-function _r() {
-    let t;
-    if (pe() && In.performance) t = In?.performance?.now?.();
+function gr() {
+    let e;
+    if (pt() && In.performance) e = In?.performance?.now?.();
     else if ("hrtime" in On) {
-        let e = On?.hrtime?.();
-        t = e[0] * 1e3 + e[1] / 1e6
-    } else t = Date.now();
-    return t
+        let t = On?.hrtime?.();
+        e = t[0] * 1e3 + t[1] / 1e6
+    } else e = Date.now();
+    return e
 }
 var $r = {
-        debug: pe() && console.debug || console.log,
+        debug: pt() && console.debug || console.log,
         log: console.log,
         info: console.info,
         warn: console.warn,
         error: console.error
     },
-    Bm = {
+    Lm = {
         enabled: !0,
         level: 0
     };
 
 function Yr() {}
-var $f = {},
-    Yf = {
+var Yh = {},
+    qh = {
         once: !0
     },
-    Se = class {
+    xt = class {
         constructor({
-            id: e
+            id: t
         } = {
             id: ""
         }) {
-            this.VERSION = uc, this._startTs = _r(), this._deltaTs = _r(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new Fn(`__probe-${this.id}__`, Bm), this.timeStamp(`${this.id} started`), Xf(this), Object.seal(this)
+            this.VERSION = uc, this._startTs = gr(), this._deltaTs = gr(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new Fn(`__probe-${this.id}__`, Lm), this.timeStamp(`${this.id} started`), $h(this), Object.seal(this)
         }
-        set level(e) {
-            this.setLevel(e)
+        set level(t) {
+            this.setLevel(t)
         }
         get level() {
             return this.getLevel()
         }
         isEnabled() {
             return this._storage.config.enabled
         }
         getLevel() {
             return this._storage.config.level
         }
         getTotal() {
-            return Number((_r() - this._startTs).toPrecision(10))
+            return Number((gr() - this._startTs).toPrecision(10))
         }
         getDelta() {
-            return Number((_r() - this._deltaTs).toPrecision(10))
+            return Number((gr() - this._deltaTs).toPrecision(10))
         }
-        set priority(e) {
-            this.level = e
+        set priority(t) {
+            this.level = t
         }
         get priority() {
             return this.level
         }
         getPriority() {
             return this.level
         }
-        enable(e = !0) {
+        enable(t = !0) {
             return this._storage.setConfiguration({
-                enabled: e
+                enabled: t
             }), this
         }
-        setLevel(e) {
+        setLevel(t) {
             return this._storage.setConfiguration({
-                level: e
+                level: t
             }), this
         }
-        get(e) {
-            return this._storage.config[e]
+        get(t) {
+            return this._storage.config[t]
         }
-        set(e, r) {
+        set(t, r) {
             this._storage.setConfiguration({
-                [e]: r
+                [t]: r
             })
         }
         settings() {
             console.table ? console.table(this._storage.config) : console.log(this._storage.config)
         }
-        assert(e, r) {
-            if (!e) throw new Error(r || "Assertion failed")
+        assert(t, r) {
+            if (!t) throw new Error(r || "Assertion failed")
         }
-        warn(e) {
-            return this._getLogFunction(0, e, $r.warn, arguments, Yf)
+        warn(t) {
+            return this._getLogFunction(0, t, $r.warn, arguments, qh)
         }
-        error(e) {
-            return this._getLogFunction(0, e, $r.error, arguments)
+        error(t) {
+            return this._getLogFunction(0, t, $r.error, arguments)
         }
-        deprecated(e, r) {
-            return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${r}\` instead`)
+        deprecated(t, r) {
+            return this.warn(`\`${t}\` is deprecated and will be removed in a later version. Use \`${r}\` instead`)
         }
-        removed(e, r) {
-            return this.error(`\`${e}\` has been removed. Use \`${r}\` instead`)
+        removed(t, r) {
+            return this.error(`\`${t}\` has been removed. Use \`${r}\` instead`)
         }
-        probe(e, r) {
-            return this._getLogFunction(e, r, $r.log, arguments, {
+        probe(t, r) {
+            return this._getLogFunction(t, r, $r.log, arguments, {
                 time: !0,
                 once: !0
             })
         }
-        log(e, r) {
-            return this._getLogFunction(e, r, $r.debug, arguments)
+        log(t, r) {
+            return this._getLogFunction(t, r, $r.debug, arguments)
         }
-        info(e, r) {
-            return this._getLogFunction(e, r, console.info, arguments)
+        info(t, r) {
+            return this._getLogFunction(t, r, console.info, arguments)
         }
-        once(e, r) {
-            return this._getLogFunction(e, r, $r.debug || $r.info, arguments, Yf)
+        once(t, r) {
+            return this._getLogFunction(t, r, $r.debug || $r.info, arguments, qh)
         }
-        table(e, r, s) {
-            return r ? this._getLogFunction(e, r, console.table || Yr, s && [s], {
-                tag: Lm(r)
+        table(t, r, s) {
+            return r ? this._getLogFunction(t, r, console.table || Yr, s && [s], {
+                tag: Wm(r)
             }) : Yr
         }
-        time(e, r) {
-            return this._getLogFunction(e, r, console.time ? console.time : console.info)
+        time(t, r) {
+            return this._getLogFunction(t, r, console.time ? console.time : console.info)
         }
-        timeEnd(e, r) {
-            return this._getLogFunction(e, r, console.timeEnd ? console.timeEnd : console.info)
+        timeEnd(t, r) {
+            return this._getLogFunction(t, r, console.timeEnd ? console.timeEnd : console.info)
         }
-        timeStamp(e, r) {
-            return this._getLogFunction(e, r, console.timeStamp || Yr)
+        timeStamp(t, r) {
+            return this._getLogFunction(t, r, console.timeStamp || Yr)
         }
-        group(e, r, s = {
+        group(t, r, s = {
             collapsed: !1
         }) {
-            let i = qf({
-                    logLevel: e,
+            let i = Kh({
+                    logLevel: t,
                     message: r,
                     opts: s
                 }),
                 {
                     collapsed: n
                 } = s;
             return i.method = (n ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(i)
         }
-        groupCollapsed(e, r, s = {}) {
-            return this.group(e, r, Object.assign({}, s, {
+        groupCollapsed(t, r, s = {}) {
+            return this.group(t, r, Object.assign({}, s, {
                 collapsed: !0
             }))
         }
-        groupEnd(e) {
-            return this._getLogFunction(e, "", console.groupEnd || Yr)
+        groupEnd(t) {
+            return this._getLogFunction(t, "", console.groupEnd || Yr)
         }
-        withGroup(e, r, s) {
-            this.group(e, r)();
+        withGroup(t, r, s) {
+            this.group(t, r)();
             try {
                 s()
             } finally {
-                this.groupEnd(e)()
+                this.groupEnd(t)()
             }
         }
         trace() {
             console.trace && console.trace()
         }
-        _shouldLog(e) {
-            return this.isEnabled() && this.getLevel() >= Kf(e)
+        _shouldLog(t) {
+            return this.isEnabled() && this.getLevel() >= Zh(t)
         }
-        _getLogFunction(e, r, s, i, n) {
-            if (this._shouldLog(e)) {
-                n = qf({
-                    logLevel: e,
+        _getLogFunction(t, r, s, i, n) {
+            if (this._shouldLog(t)) {
+                n = Kh({
+                    logLevel: t,
                     message: r,
                     args: i,
                     opts: n
-                }), s = s || n.method, Xs(s), n.total = this.getTotal(), n.delta = this.getDelta(), this._deltaTs = _r();
+                }), s = s || n.method, Xs(s), n.total = this.getTotal(), n.delta = this.getDelta(), this._deltaTs = gr();
                 let o = n.tag || n.message;
                 if (n.once && o)
-                    if (!$f[o]) $f[o] = _r();
+                    if (!Yh[o]) Yh[o] = gr();
                     else return Yr;
-                return r = Um(this.id, n.message, n), s.bind(console, r, ...n.args)
+                return r = Vm(this.id, n.message, n), s.bind(console, r, ...n.args)
             }
             return Yr
         }
     };
-Se.VERSION = uc;
+xt.VERSION = uc;
 
-function Kf(t) {
-    if (!t) return 0;
-    let e;
-    switch (typeof t) {
+function Zh(e) {
+    if (!e) return 0;
+    let t;
+    switch (typeof e) {
         case "number":
-            e = t;
+            t = e;
             break;
         case "object":
-            e = t.logLevel || t.priority || 0;
+            t = e.logLevel || e.priority || 0;
             break;
         default:
             return 0
     }
-    return Xs(Number.isFinite(e) && e >= 0), e
+    return Xs(Number.isFinite(t) && t >= 0), t
 }
 
-function qf(t) {
+function Kh(e) {
     let {
-        logLevel: e,
+        logLevel: t,
         message: r
-    } = t;
-    t.logLevel = Kf(e);
-    let s = t.args ? Array.from(t.args) : [];
+    } = e;
+    e.logLevel = Zh(t);
+    let s = e.args ? Array.from(e.args) : [];
     for (; s.length && s.shift() !== r;);
-    switch (typeof e) {
+    switch (typeof t) {
         case "string":
         case "function":
-            r !== void 0 && s.unshift(r), t.message = e;
+            r !== void 0 && s.unshift(r), e.message = t;
             break;
         case "object":
-            Object.assign(t, e);
+            Object.assign(e, t);
             break;
         default:
     }
-    typeof t.message == "function" && (t.message = t.message());
-    let i = typeof t.message;
-    return Xs(i === "string" || i === "object"), Object.assign(t, {
+    typeof e.message == "function" && (e.message = e.message());
+    let i = typeof e.message;
+    return Xs(i === "string" || i === "object"), Object.assign(e, {
         args: s
-    }, t.opts)
+    }, e.opts)
 }
 
-function Um(t, e, r) {
-    if (typeof e == "string") {
-        let s = r.time ? zf(Wf(r.total)) : "";
-        e = r.time ? `${t}: ${s}  ${e}` : `${t}: ${e}`, e = jf(e, r.color, r.background)
+function Vm(e, t, r) {
+    if (typeof t == "string") {
+        let s = r.time ? jh(zh(r.total)) : "";
+        t = r.time ? `${e}: ${s}  ${t}` : `${e}: ${t}`, t = Xh(t, r.color, r.background)
     }
-    return e
+    return t
 }
 
-function Lm(t) {
-    for (let e in t)
-        for (let r in t[e]) return r || "untitled";
+function Wm(e) {
+    for (let t in e)
+        for (let r in e[t]) return r || "untitled";
     return "empty"
 }
 globalThis.probe = {};
-var xR = new Se({
+var RR = new xt({
     id: "@probe.gl/log"
 });
-var dc = new Se({
+var dc = new xt({
         id: "loaders.gl"
     }),
-    kn = class {
+    Dn = class {
         log() {
             return () => {}
         }
         info() {
             return () => {}
         }
         warn() {
@@ -2153,51 +2153,51 @@
         }
     },
     Bn = class {
         constructor() {
             this.console = void 0, this.console = console
         }
         log() {
-            for (var e = arguments.length, r = new Array(e), s = 0; s < e; s++) r[s] = arguments[s];
+            for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];
             return this.console.log.bind(this.console, ...r)
         }
         info() {
-            for (var e = arguments.length, r = new Array(e), s = 0; s < e; s++) r[s] = arguments[s];
+            for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];
             return this.console.info.bind(this.console, ...r)
         }
         warn() {
-            for (var e = arguments.length, r = new Array(e), s = 0; s < e; s++) r[s] = arguments[s];
+            for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];
             return this.console.warn.bind(this.console, ...r)
         }
         error() {
-            for (var e = arguments.length, r = new Array(e), s = 0; s < e; s++) r[s] = arguments[s];
+            for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];
             return this.console.error.bind(this.console, ...r)
         }
     };
 var pc = {
         fetch: null,
         mimeType: void 0,
         nothrow: !1,
         log: new Bn,
         useLocalLibraries: !1,
         CDN: "https://unpkg.com/@loaders.gl",
         worker: !0,
         maxConcurrency: 3,
         maxMobileConcurrency: 1,
-        reuseWorkers: fr,
+        reuseWorkers: hr,
         _nodeWorkers: !1,
         _workerType: "",
         limit: 0,
         _limitMB: 0,
         batchSize: "auto",
         batchDebounceMs: 0,
         metadata: !1,
         transforms: []
     },
-    Zf = {
+    Qh = {
         throws: "nothrow",
         dataType: "(no longer used)",
         uri: "baseUri",
         method: "fetch.method",
         headers: "fetch.headers",
         body: "fetch.body",
         mode: "fetch.mode",
@@ -2207,830 +2207,830 @@
         referrer: "fetch.referrer",
         referrerPolicy: "fetch.referrerPolicy",
         integrity: "fetch.integrity",
         keepalive: "fetch.keepalive",
         signal: "fetch.signal"
     };
 
-function gc() {
+function _c() {
     globalThis.loaders = globalThis.loaders || {};
     let {
-        loaders: t
+        loaders: e
     } = globalThis;
-    return t._state = t._state || {}, t._state
+    return e._state = e._state || {}, e._state
 }
 
-function _c() {
-    let t = gc();
-    return t.globalOptions = t.globalOptions || {
+function gc() {
+    let e = _c();
+    return e.globalOptions = e.globalOptions || {
         ...pc
-    }, t.globalOptions
+    }, e.globalOptions
 }
 
-function Gf(t, e, r, s) {
-    return r = r || [], r = Array.isArray(r) ? r : [r], Vm(t, r), zm(e, t, s)
+function tu(e, t, r, s) {
+    return r = r || [], r = Array.isArray(r) ? r : [r], zm(e, r), Hm(t, e, s)
 }
 
-function Vm(t, e) {
-    Qf(t, null, pc, Zf, e);
-    for (let r of e) {
-        let s = t && t[r.id] || {},
+function zm(e, t) {
+    Jh(e, null, pc, Qh, t);
+    for (let r of t) {
+        let s = e && e[r.id] || {},
             i = r.options && r.options[r.id] || {},
             n = r.deprecatedOptions && r.deprecatedOptions[r.id] || {};
-        Qf(s, r.id, i, n, e)
+        Jh(s, r.id, i, n, t)
     }
 }
 
-function Qf(t, e, r, s, i) {
-    let n = e || "Top level",
-        o = e ? `${e}.` : "";
-    for (let a in t) {
-        let c = !e && pr(t[a]),
-            l = a === "baseUri" && !e,
-            h = a === "workerUrl" && e;
-        if (!(a in r) && !l && !h) {
+function Jh(e, t, r, s, i) {
+    let n = t || "Top level",
+        o = t ? `${t}.` : "";
+    for (let a in e) {
+        let c = !t && pr(e[a]),
+            l = a === "baseUri" && !t,
+            f = a === "workerUrl" && t;
+        if (!(a in r) && !l && !f) {
             if (a in s) dc.warn(`${n} loader option '${o}${a}' no longer supported, use '${s[a]}'`)();
             else if (!c) {
-                let d = Wm(a, i);
+                let d = jm(a, i);
                 dc.warn(`${n} loader option '${o}${a}' not recognized. ${d}`)()
             }
         }
     }
 }
 
-function Wm(t, e) {
-    let r = t.toLowerCase(),
+function jm(e, t) {
+    let r = e.toLowerCase(),
         s = "";
-    for (let i of e)
+    for (let i of t)
         for (let n in i.options) {
-            if (t === n) return `Did you mean '${i.id}.${n}'?`;
+            if (e === n) return `Did you mean '${i.id}.${n}'?`;
             let o = n.toLowerCase();
             (r.startsWith(o) || o.startsWith(r)) && (s = s || `Did you mean '${i.id}.${n}'?`)
         }
     return s
 }
 
-function zm(t, e, r) {
+function Hm(e, t, r) {
     let i = {
-        ...t.options || {}
+        ...e.options || {}
     };
-    return Hm(i, r), i.log === null && (i.log = new kn), Jf(i, _c()), Jf(i, e), i
+    return Xm(i, r), i.log === null && (i.log = new Dn), Gh(i, gc()), Gh(i, t), i
 }
 
-function Jf(t, e) {
-    for (let r in e)
-        if (r in e) {
-            let s = e[r];
-            cc(s) && cc(t[r]) ? t[r] = {
-                ...t[r],
-                ...e[r]
-            } : t[r] = e[r]
+function Gh(e, t) {
+    for (let r in t)
+        if (r in t) {
+            let s = t[r];
+            cc(s) && cc(e[r]) ? e[r] = {
+                ...e[r],
+                ...t[r]
+            } : e[r] = t[r]
         }
 }
 
-function Hm(t, e) {
-    e && !("baseUri" in t) && (t.baseUri = e)
+function Xm(e, t) {
+    t && !("baseUri" in e) && (e.baseUri = t)
 }
 
-function $s(t) {
-    var e;
-    return t ? (Array.isArray(t) && (t = t[0]), Array.isArray((e = t) === null || e === void 0 ? void 0 : e.extensions)) : !1
+function $s(e) {
+    var t;
+    return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1
 }
 
-function Ys(t) {
-    var e, r;
-    kt(t, "null loader"), kt($s(t), "invalid loader");
+function Ys(e) {
+    var t, r;
+    De(e, "null loader"), De($s(e), "invalid loader");
     let s;
-    return Array.isArray(t) && (s = t[1], t = t[0], t = {
-        ...t,
+    return Array.isArray(e) && (s = e[1], e = e[0], e = {
+        ...e,
         options: {
-            ...t.options,
+            ...e.options,
             ...s
         }
-    }), ((e = t) !== null && e !== void 0 && e.parseTextSync || (r = t) !== null && r !== void 0 && r.parseText) && (t.text = !0), t.text || (t.binary = !0), t
+    }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (r = e) !== null && r !== void 0 && r.parseText) && (e.text = !0), e.text || (e.binary = !0), e
 }
 var eu = () => {
-    let t = gc();
-    return t.loaderRegistry = t.loaderRegistry || [], t.loaderRegistry
+    let e = _c();
+    return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry
 };
 
-function mc(t) {
-    let e = eu();
-    t = Array.isArray(t) ? t : [t];
-    for (let r of t) {
+function mc(e) {
+    let t = eu();
+    e = Array.isArray(e) ? e : [e];
+    for (let r of e) {
         let s = Ys(r);
-        e.find(i => s === i) || e.unshift(s)
+        t.find(i => s === i) || t.unshift(s)
     }
 }
 
-function tu() {
+function ru() {
     return eu()
 }
-var ru = new Se({
+var su = new xt({
     id: "loaders.gl"
 });
-var jm = /\.([^.]+)$/;
-async function nu(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
+var $m = /\.([^.]+)$/;
+async function ou(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
         r = arguments.length > 2 ? arguments[2] : void 0,
         s = arguments.length > 3 ? arguments[3] : void 0;
-    if (!ou(t)) return null;
-    let i = su(t, e, {
+    if (!au(e)) return null;
+    let i = iu(e, t, {
         ...r,
         nothrow: !0
     }, s);
     if (i) return i;
-    if (De(t) && (t = await t.slice(0, 10).arrayBuffer(), i = su(t, e, r, s)), !i && !(r != null && r.nothrow)) throw new Error(au(t));
+    if (kt(e) && (e = await e.slice(0, 10).arrayBuffer(), i = iu(e, t, r, s)), !i && !(r != null && r.nothrow)) throw new Error(cu(e));
     return i
 }
 
-function su(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
+function iu(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
         r = arguments.length > 2 ? arguments[2] : void 0,
         s = arguments.length > 3 ? arguments[3] : void 0;
-    if (!ou(t)) return null;
-    if (e && !Array.isArray(e)) return Ys(e);
+    if (!au(e)) return null;
+    if (t && !Array.isArray(t)) return Ys(t);
     let i = [];
-    e && (i = i.concat(e)), r != null && r.ignoreRegisteredLoaders || i.push(...tu()), $m(i);
-    let n = Xm(t, i, r, s);
-    if (!n && !(r != null && r.nothrow)) throw new Error(au(t));
+    t && (i = i.concat(t)), r != null && r.ignoreRegisteredLoaders || i.push(...ru()), qm(i);
+    let n = Ym(e, i, r, s);
+    if (!n && !(r != null && r.nothrow)) throw new Error(cu(e));
     return n
 }
 
-function Xm(t, e, r, s) {
-    let i = gr(t),
-        n = js(t),
+function Ym(e, t, r, s) {
+    let i = _r(e),
+        n = Hs(e),
         o = Xr(i) || s?.url,
         a = null,
         c = "";
-    if (r != null && r.mimeType && (a = Tc(e, r?.mimeType), c = `match forced by supplied MIME type ${r?.mimeType}`), a = a || Ym(e, o), c = c || (a ? `matched url ${o}` : ""), a = a || Tc(e, n), c = c || (a ? `matched MIME type ${n}` : ""), a = a || Km(e, t), c = c || (a ? `matched initial data ${cu(t)}` : ""), r != null && r.fallbackMimeType && (a = a || Tc(e, r?.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${n}` : "")), c) {
+    if (r != null && r.mimeType && (a = bc(t, r?.mimeType), c = `match forced by supplied MIME type ${r?.mimeType}`), a = a || Km(t, o), c = c || (a ? `matched url ${o}` : ""), a = a || bc(t, n), c = c || (a ? `matched MIME type ${n}` : ""), a = a || Qm(t, e), c = c || (a ? `matched initial data ${lu(e)}` : ""), r != null && r.fallbackMimeType && (a = a || bc(t, r?.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${n}` : "")), c) {
         var l;
-        ru.log(1, `selectLoader selected ${(l=a)===null||l===void 0?void 0:l.name}: ${c}.`)
+        su.log(1, `selectLoader selected ${(l=a)===null||l===void 0?void 0:l.name}: ${c}.`)
     }
     return a
 }
 
-function ou(t) {
-    return !(t instanceof Response && t.status === 204)
+function au(e) {
+    return !(e instanceof Response && e.status === 204)
 }
 
-function au(t) {
-    let e = gr(t),
-        r = js(t),
+function cu(e) {
+    let t = _r(e),
+        r = Hs(e),
         s = "No valid loader found (";
-    s += e ? `${dr.filename(e)}, ` : "no url provided, ", s += `MIME type: ${r?`"${r}"`:"not provided"}, `;
-    let i = t ? cu(t) : "";
+    s += t ? `${dr.filename(t)}, ` : "no url provided, ", s += `MIME type: ${r?`"${r}"`:"not provided"}, `;
+    let i = e ? lu(e) : "";
     return s += i ? ` first bytes: "${i}"` : "first bytes: not available", s += ")", s
 }
 
-function $m(t) {
-    for (let e of t) Ys(e)
+function qm(e) {
+    for (let t of e) Ys(t)
 }
 
-function Ym(t, e) {
-    let r = e && jm.exec(e),
+function Km(e, t) {
+    let r = t && $m.exec(t),
         s = r && r[1];
-    return s ? qm(t, s) : null
+    return s ? Zm(e, s) : null
 }
 
-function qm(t, e) {
-    e = e.toLowerCase();
-    for (let r of t)
+function Zm(e, t) {
+    t = t.toLowerCase();
+    for (let r of e)
         for (let s of r.extensions)
-            if (s.toLowerCase() === e) return r;
+            if (s.toLowerCase() === t) return r;
     return null
 }
 
-function Tc(t, e) {
-    for (let r of t)
-        if (r.mimeTypes && r.mimeTypes.includes(e) || e === `application/x.${r.id}`) return r;
+function bc(e, t) {
+    for (let r of e)
+        if (r.mimeTypes && r.mimeTypes.includes(t) || t === `application/x.${r.id}`) return r;
     return null
 }
 
-function Km(t, e) {
-    if (!e) return null;
-    for (let r of t)
-        if (typeof e == "string") {
-            if (Zm(e, r)) return r
-        } else if (ArrayBuffer.isView(e)) {
-        if (iu(e.buffer, e.byteOffset, r)) return r
-    } else if (e instanceof ArrayBuffer && iu(e, 0, r)) return r;
+function Qm(e, t) {
+    if (!t) return null;
+    for (let r of e)
+        if (typeof t == "string") {
+            if (Jm(t, r)) return r
+        } else if (ArrayBuffer.isView(t)) {
+        if (nu(t.buffer, t.byteOffset, r)) return r
+    } else if (t instanceof ArrayBuffer && nu(t, 0, r)) return r;
     return null
 }
 
-function Zm(t, e) {
-    return e.testText ? e.testText(t) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some(s => t.startsWith(s))
+function Jm(e, t) {
+    return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some(s => e.startsWith(s))
 }
 
-function iu(t, e, r) {
-    return (Array.isArray(r.tests) ? r.tests : [r.tests]).some(i => Qm(t, e, r, i))
+function nu(e, t, r) {
+    return (Array.isArray(r.tests) ? r.tests : [r.tests]).some(i => Gm(e, t, r, i))
 }
 
-function Qm(t, e, r, s) {
-    if (s instanceof ArrayBuffer) return sc(s, t, s.byteLength);
+function Gm(e, t, r, s) {
+    if (s instanceof ArrayBuffer) return sc(s, e, s.byteLength);
     switch (typeof s) {
         case "function":
-            return s(t);
+            return s(e);
         case "string":
-            let i = yc(t, e, s.length);
+            let i = yc(e, t, s.length);
             return s === i;
         default:
             return !1
     }
 }
 
-function cu(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
-    return typeof t == "string" ? t.slice(0, e) : ArrayBuffer.isView(t) ? yc(t.buffer, t.byteOffset, e) : t instanceof ArrayBuffer ? yc(t, 0, e) : ""
+function lu(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
+    return typeof e == "string" ? e.slice(0, t) : ArrayBuffer.isView(e) ? yc(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? yc(e, 0, t) : ""
 }
 
-function yc(t, e, r) {
-    if (t.byteLength < e + r) return "";
-    let s = new DataView(t),
+function yc(e, t, r) {
+    if (e.byteLength < t + r) return "";
+    let s = new DataView(e),
         i = "";
-    for (let n = 0; n < r; n++) i += String.fromCharCode(s.getUint8(e + n));
+    for (let n = 0; n < r; n++) i += String.fromCharCode(s.getUint8(t + n));
     return i
 }
 
-function* lu(t, e) {
-    let r = e?.chunkSize || 262144,
+function* fu(e, t) {
+    let r = t?.chunkSize || 262144,
         s = 0,
         i = new TextEncoder;
-    for (; s < t.length;) {
-        let n = Math.min(t.length - s, r),
-            o = t.slice(s, s + n);
+    for (; s < e.length;) {
+        let n = Math.min(e.length - s, r),
+            o = e.slice(s, s + n);
         s += n, yield i.encode(o)
     }
 }
 
-function hu(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
+function hu(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
     return function*() {
         let {
             chunkSize: r = 262144
-        } = e, s = 0;
-        for (; s < t.byteLength;) {
-            let i = Math.min(t.byteLength - s, r),
+        } = t, s = 0;
+        for (; s < e.byteLength;) {
+            let i = Math.min(e.byteLength - s, r),
                 n = new ArrayBuffer(i),
-                o = new Uint8Array(t, s, i);
+                o = new Uint8Array(e, s, i);
             new Uint8Array(n).set(o), s += i, yield n
         }
     }()
 }
-async function* fu(t, e) {
-    let r = e?.chunkSize || 1048576,
+async function* uu(e, t) {
+    let r = t?.chunkSize || 1048576,
         s = 0;
-    for (; s < t.size;) {
+    for (; s < e.size;) {
         let i = s + r,
-            n = await t.slice(s, i).arrayBuffer();
+            n = await e.slice(s, i).arrayBuffer();
         s = i, yield n
     }
 }
 
-function bc(t, e) {
-    return fr ? Jm(t, e) : Gm(t, e)
+function Tc(e, t) {
+    return hr ? tb(e, t) : eb(e, t)
 }
-async function* Jm(t, e) {
-    let r = t.getReader(),
+async function* tb(e, t) {
+    let r = e.getReader(),
         s;
     try {
         for (;;) {
             let i = s || r.read();
-            e != null && e._streamReadAhead && (s = r.read());
+            t != null && t._streamReadAhead && (s = r.read());
             let {
                 done: n,
                 value: o
             } = await i;
             if (n) return;
             yield Mn(o)
         }
     } catch {
         r.releaseLock()
     }
 }
-async function* Gm(t, e) {
-    for await (let r of t) yield Mn(r)
+async function* eb(e, t) {
+    for await (let r of e) yield Mn(r)
 }
 
-function uu(t, e) {
-    if (typeof t == "string") return lu(t, e);
-    if (t instanceof ArrayBuffer) return hu(t, e);
-    if (De(t)) return fu(t, e);
-    if (Pn(t)) return bc(t, e);
-    if (Fe(t)) return bc(t.body, e);
+function du(e, t) {
+    if (typeof e == "string") return fu(e, t);
+    if (e instanceof ArrayBuffer) return hu(e, t);
+    if (kt(e)) return uu(e, t);
+    if (Pn(e)) return Tc(e, t);
+    if (Ft(e)) return Tc(e.body, t);
     throw new Error("makeIterator")
 }
-var du = "Cannot convert supplied data type";
+var pu = "Cannot convert supplied data type";
 
-function eT(t, e, r) {
-    if (e.text && typeof t == "string") return t;
-    if (Ff(t) && (t = t.buffer), t instanceof ArrayBuffer) {
-        let s = t;
-        return e.text && !e.binary ? new TextDecoder("utf8").decode(s) : s
+function rb(e, t, r) {
+    if (t.text && typeof e == "string") return e;
+    if (kh(e) && (e = e.buffer), e instanceof ArrayBuffer) {
+        let s = e;
+        return t.text && !t.binary ? new TextDecoder("utf8").decode(s) : s
     }
-    if (ArrayBuffer.isView(t)) {
-        if (e.text && !e.binary) return new TextDecoder("utf8").decode(t);
-        let s = t.buffer,
-            i = t.byteLength || t.length;
-        return (t.byteOffset !== 0 || i !== s.byteLength) && (s = s.slice(t.byteOffset, t.byteOffset + i)), s
+    if (ArrayBuffer.isView(e)) {
+        if (t.text && !t.binary) return new TextDecoder("utf8").decode(e);
+        let s = e.buffer,
+            i = e.byteLength || e.length;
+        return (e.byteOffset !== 0 || i !== s.byteLength) && (s = s.slice(e.byteOffset, e.byteOffset + i)), s
     }
-    throw new Error(du)
+    throw new Error(pu)
 }
-async function pu(t, e, r) {
-    let s = t instanceof ArrayBuffer || ArrayBuffer.isView(t);
-    if (typeof t == "string" || s) return eT(t, e, r);
-    if (De(t) && (t = await Cn(t)), Fe(t)) {
-        let i = t;
-        return await Lf(i), e.binary ? await i.arrayBuffer() : await i.text()
+async function _u(e, t, r) {
+    let s = e instanceof ArrayBuffer || ArrayBuffer.isView(e);
+    if (typeof e == "string" || s) return rb(e, t, r);
+    if (kt(e) && (e = await Cn(e)), Ft(e)) {
+        let i = e;
+        return await Vh(i), t.binary ? await i.arrayBuffer() : await i.text()
     }
-    if (Pn(t) && (t = uu(t, r)), Of(t) || Nf(t)) return nc(t);
-    throw new Error(du)
+    if (Pn(e) && (e = du(e, r)), Nh(e) || Fh(e)) return nc(e);
+    throw new Error(pu)
 }
 
-function Un(t, e) {
-    let r = _c(),
-        s = t || r;
-    return typeof s.fetch == "function" ? s.fetch : pr(s.fetch) ? i => hc(i, s.fetch) : e != null && e.fetch ? e?.fetch : hc
+function Un(e, t) {
+    let r = gc(),
+        s = e || r;
+    return typeof s.fetch == "function" ? s.fetch : pr(s.fetch) ? i => fc(i, s.fetch) : t != null && t.fetch ? t?.fetch : fc
 }
 
-function gu(t, e, r) {
+function gu(e, t, r) {
     if (r) return r;
     let s = {
-        fetch: Un(e, t),
-        ...t
+        fetch: Un(t, e),
+        ...e
     };
     if (s.url) {
         let i = Xr(s.url);
-        s.baseUrl = i, s.queryString = Bf(s.url), s.filename = dr.filename(i), s.baseUrl = dr.dirname(i)
+        s.baseUrl = i, s.queryString = Uh(s.url), s.filename = dr.filename(i), s.baseUrl = dr.dirname(i)
     }
     return Array.isArray(s.loaders) || (s.loaders = null), s
 }
 
-function _u(t, e) {
-    if (t && !Array.isArray(t)) return t;
+function mu(e, t) {
+    if (e && !Array.isArray(e)) return e;
     let r;
-    if (t && (r = Array.isArray(t) ? t : [t]), e && e.loaders) {
-        let s = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
+    if (e && (r = Array.isArray(e) ? e : [e]), t && t.loaders) {
+        let s = Array.isArray(t.loaders) ? t.loaders : [t.loaders];
         r = r ? [...r, ...s] : s
     }
     return r && r.length ? r : void 0
 }
-async function qs(t, e, r, s) {
-    e && !Array.isArray(e) && !$s(e) && (s = void 0, r = e, e = void 0), t = await t, r = r || {};
-    let i = gr(t),
-        o = _u(e, s),
-        a = await nu(t, o, r);
-    return a ? (r = Gf(r, a, o, i), s = gu({
+async function qs(e, t, r, s) {
+    t && !Array.isArray(t) && !$s(t) && (s = void 0, r = t, t = void 0), e = await e, r = r || {};
+    let i = _r(e),
+        o = mu(t, s),
+        a = await ou(e, o, r);
+    return a ? (r = tu(r, a, o, i), s = gu({
         url: i,
         _parse: qs,
         loaders: o
-    }, r, s || null), await tT(a, t, r, s)) : null
+    }, r, s || null), await sb(a, e, r, s)) : null
 }
-async function tT(t, e, r, s) {
-    if (ec(t), r = qa(t.options, r), Fe(e)) {
-        let n = e,
+async function sb(e, t, r, s) {
+    if (tc(e), r = qa(e.options, r), Ft(t)) {
+        let n = t,
             {
                 ok: o,
                 redirected: a,
                 status: c,
                 statusText: l,
-                type: h,
+                type: f,
                 url: d
             } = n,
             p = Object.fromEntries(n.headers.entries());
         s.response = {
             headers: p,
             ok: o,
             redirected: a,
             status: c,
             statusText: l,
-            type: h,
+            type: f,
             url: d
         }
     }
-    e = await pu(e, t, r);
-    let i = t;
-    if (i.parseTextSync && typeof e == "string") return i.parseTextSync(e, r, s);
-    if (tc(t, r)) return await rc(t, e, r, s, qs);
-    if (i.parseText && typeof e == "string") return await i.parseText(e, r, s);
-    if (i.parse) return await i.parse(e, r, s);
-    throw be(!i.parseSync), new Error(`${t.id} loader - no parser found and worker is disabled`)
+    t = await _u(t, e, r);
+    let i = e;
+    if (i.parseTextSync && typeof t == "string") return i.parseTextSync(t, r, s);
+    if (ec(e, r)) return await rc(e, t, r, s, qs);
+    if (i.parseText && typeof t == "string") return await i.parseText(t, r, s);
+    if (i.parse) return await i.parse(t, r, s);
+    throw Tt(!i.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`)
 }
-async function qr(t, e, r, s) {
+async function qr(e, t, r, s) {
     let i, n;
-    !Array.isArray(e) && !$s(e) ? (i = [], n = e, s = void 0) : (i = e, n = r);
+    !Array.isArray(t) && !$s(t) ? (i = [], n = t, s = void 0) : (i = t, n = r);
     let o = Un(n),
-        a = t;
-    return typeof t == "string" && (a = await o(t)), De(t) && (a = await o(t)), Array.isArray(i) ? await qs(a, i, n) : await qs(a, i, n)
+        a = e;
+    return typeof e == "string" && (a = await o(e)), kt(e) && (a = await o(e)), Array.isArray(i) ? await qs(a, i, n) : await qs(a, i, n)
 }
-var mu = "4.1.4";
-var Ec, rT = (Ec = globalThis.loaders) === null || Ec === void 0 ? void 0 : Ec.parseImageNode,
+var bu = "4.1.4";
+var wc, ib = (wc = globalThis.loaders) === null || wc === void 0 ? void 0 : wc.parseImageNode,
     Ac = typeof Image < "u",
-    xc = typeof ImageBitmap < "u",
-    sT = !!rT,
-    Sc = fr ? !0 : sT;
+    Ec = typeof ImageBitmap < "u",
+    nb = !!ib,
+    xc = hr ? !0 : nb;
 
-function Tu(t) {
-    switch (t) {
+function yu(e) {
+    switch (e) {
         case "auto":
-            return xc || Ac || Sc;
+            return Ec || Ac || xc;
         case "imagebitmap":
-            return xc;
+            return Ec;
         case "image":
             return Ac;
         case "data":
-            return Sc;
+            return xc;
         default:
-            throw new Error(`@loaders.gl/images: image ${t} not supported in this environment`)
+            throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`)
     }
 }
 
-function yu() {
-    if (xc) return "imagebitmap";
+function Tu() {
+    if (Ec) return "imagebitmap";
     if (Ac) return "image";
-    if (Sc) return "data";
+    if (xc) return "data";
     throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js")
 }
 
-function iT(t) {
-    let e = nT(t);
-    if (!e) throw new Error("Not an image");
-    return e
+function ob(e) {
+    let t = ab(e);
+    if (!t) throw new Error("Not an image");
+    return t
 }
 
-function bu(t) {
-    switch (iT(t)) {
+function wu(e) {
+    switch (ob(e)) {
         case "data":
-            return t;
+            return e;
         case "image":
         case "imagebitmap":
-            let e = document.createElement("canvas"),
-                r = e.getContext("2d");
+            let t = document.createElement("canvas"),
+                r = t.getContext("2d");
             if (!r) throw new Error("getImageData");
-            return e.width = t.width, e.height = t.height, r.drawImage(t, 0, 0), r.getImageData(0, 0, t.width, t.height);
+            return t.width = e.width, t.height = e.height, r.drawImage(e, 0, 0), r.getImageData(0, 0, e.width, e.height);
         default:
             throw new Error("getImageData")
     }
 }
 
-function nT(t) {
-    return typeof ImageBitmap < "u" && t instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && t instanceof Image ? "image" : t && typeof t == "object" && t.data && t.width && t.height ? "data" : null
+function ab(e) {
+    return typeof ImageBitmap < "u" && e instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && e instanceof Image ? "image" : e && typeof e == "object" && e.data && e.width && e.height ? "data" : null
 }
-var oT = /^data:image\/svg\+xml/,
-    aT = /\.svg((\?|#).*)?$/;
+var cb = /^data:image\/svg\+xml/,
+    lb = /\.svg((\?|#).*)?$/;
 
-function Ln(t) {
-    return t && (oT.test(t) || aT.test(t))
+function Ln(e) {
+    return e && (cb.test(e) || lb.test(e))
 }
 
-function Eu(t, e) {
-    if (Ln(e)) {
-        let s = new TextDecoder().decode(t);
+function Au(e, t) {
+    if (Ln(t)) {
+        let s = new TextDecoder().decode(e);
         try {
             typeof unescape == "function" && typeof encodeURIComponent == "function" && (s = unescape(encodeURIComponent(s)))
         } catch (n) {
             throw new Error(n.message)
         }
         return `data:image/svg+xml;base64,${btoa(s)}`
     }
-    return wc(t, e)
+    return Sc(e, t)
 }
 
-function wc(t, e) {
-    if (Ln(e)) throw new Error("SVG cannot be parsed directly to imagebitmap");
-    return new Blob([new Uint8Array(t)])
+function Sc(e, t) {
+    if (Ln(t)) throw new Error("SVG cannot be parsed directly to imagebitmap");
+    return new Blob([new Uint8Array(e)])
 }
-async function Vn(t, e, r) {
-    let s = Eu(t, r),
+async function Vn(e, t, r) {
+    let s = Au(e, r),
         i = self.URL || self.webkitURL,
         n = typeof s != "string" && i.createObjectURL(s);
     try {
-        return await cT(n || s, e)
+        return await fb(n || s, t)
     } finally {
         n && i.revokeObjectURL(n)
     }
 }
-async function cT(t, e) {
+async function fb(e, t) {
     let r = new Image;
-    return r.src = t, e.image && e.image.decode && r.decode ? (await r.decode(), r) : await new Promise((s, i) => {
+    return r.src = e, t.image && t.image.decode && r.decode ? (await r.decode(), r) : await new Promise((s, i) => {
         try {
             r.onload = () => s(r), r.onerror = n => {
                 let o = n instanceof Error ? n.message : "error";
                 i(new Error(o))
             }
         } catch (n) {
             i(n)
         }
     })
 }
-var lT = {},
-    Au = !0;
-async function xu(t, e, r) {
+var hb = {},
+    Eu = !0;
+async function xu(e, t, r) {
     let s;
-    Ln(r) ? s = await Vn(t, e, r) : s = wc(t, r);
-    let i = e && e.imagebitmap;
-    return await hT(s, i)
-}
-async function hT(t) {
-    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
-    if ((fT(e) || !Au) && (e = null), e) try {
-        return await createImageBitmap(t, e)
+    Ln(r) ? s = await Vn(e, t, r) : s = Sc(e, r);
+    let i = t && t.imagebitmap;
+    return await ub(s, i)
+}
+async function ub(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
+    if ((db(t) || !Eu) && (t = null), t) try {
+        return await createImageBitmap(e, t)
     } catch (r) {
-        console.warn(r), Au = !1
+        console.warn(r), Eu = !1
     }
-    return await createImageBitmap(t)
+    return await createImageBitmap(e)
 }
 
-function fT(t) {
-    for (let e in t || lT) return !1;
+function db(e) {
+    for (let t in e || hb) return !1;
     return !0
 }
 
-function Su(t) {
-    return !gT(t, "ftyp", 4) || !(t[8] & 96) ? null : uT(t)
+function Su(e) {
+    return !mb(e, "ftyp", 4) || !(e[8] & 96) ? null : pb(e)
 }
 
-function uT(t) {
-    switch (dT(t, 8, 12).replace("\0", " ").trim()) {
+function pb(e) {
+    switch (_b(e, 8, 12).replace("\0", " ").trim()) {
         case "avif":
         case "avis":
             return {
                 extension: "avif", mimeType: "image/avif"
             };
         default:
             return null
     }
 }
 
-function dT(t, e, r) {
-    return String.fromCharCode(...t.slice(e, r))
+function _b(e, t, r) {
+    return String.fromCharCode(...e.slice(t, r))
 }
 
-function pT(t) {
-    return [...t].map(e => e.charCodeAt(0))
+function gb(e) {
+    return [...e].map(t => t.charCodeAt(0))
 }
 
-function gT(t, e) {
+function mb(e, t) {
     let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
-        s = pT(e);
+        s = gb(t);
     for (let i = 0; i < s.length; ++i)
-        if (s[i] !== t[i + r]) return !1;
+        if (s[i] !== e[i + r]) return !1;
     return !0
 }
-var it = !1,
+var ie = !1,
     Ks = !0;
 
-function Wn(t) {
-    let e = Zs(t);
-    return mT(e) || bT(e) || TT(e) || yT(e) || _T(e)
+function Wn(e) {
+    let t = Zs(e);
+    return yb(t) || Ab(t) || Tb(t) || wb(t) || bb(t)
 }
 
-function _T(t) {
-    let e = new Uint8Array(t instanceof DataView ? t.buffer : t),
-        r = Su(e);
+function bb(e) {
+    let t = new Uint8Array(e instanceof DataView ? e.buffer : e),
+        r = Su(t);
     return r ? {
         mimeType: r.mimeType,
         width: 0,
         height: 0
     } : null
 }
 
-function mT(t) {
-    let e = Zs(t);
-    return e.byteLength >= 24 && e.getUint32(0, it) === 2303741511 ? {
+function yb(e) {
+    let t = Zs(e);
+    return t.byteLength >= 24 && t.getUint32(0, ie) === 2303741511 ? {
         mimeType: "image/png",
-        width: e.getUint32(16, it),
-        height: e.getUint32(20, it)
+        width: t.getUint32(16, ie),
+        height: t.getUint32(20, ie)
     } : null
 }
 
-function TT(t) {
-    let e = Zs(t);
-    return e.byteLength >= 10 && e.getUint32(0, it) === 1195984440 ? {
+function Tb(e) {
+    let t = Zs(e);
+    return t.byteLength >= 10 && t.getUint32(0, ie) === 1195984440 ? {
         mimeType: "image/gif",
-        width: e.getUint16(6, Ks),
-        height: e.getUint16(8, Ks)
+        width: t.getUint16(6, Ks),
+        height: t.getUint16(8, Ks)
     } : null
 }
 
-function yT(t) {
-    let e = Zs(t);
-    return e.byteLength >= 14 && e.getUint16(0, it) === 16973 && e.getUint32(2, Ks) === e.byteLength ? {
+function wb(e) {
+    let t = Zs(e);
+    return t.byteLength >= 14 && t.getUint16(0, ie) === 16973 && t.getUint32(2, Ks) === t.byteLength ? {
         mimeType: "image/bmp",
-        width: e.getUint32(18, Ks),
-        height: e.getUint32(22, Ks)
+        width: t.getUint32(18, Ks),
+        height: t.getUint32(22, Ks)
     } : null
 }
 
-function bT(t) {
-    let e = Zs(t);
-    if (!(e.byteLength >= 3 && e.getUint16(0, it) === 65496 && e.getUint8(2) === 255)) return null;
+function Ab(e) {
+    let t = Zs(e);
+    if (!(t.byteLength >= 3 && t.getUint16(0, ie) === 65496 && t.getUint8(2) === 255)) return null;
     let {
         tableMarkers: s,
         sofMarkers: i
-    } = ET(), n = 2;
-    for (; n + 9 < e.byteLength;) {
-        let o = e.getUint16(n, it);
+    } = Eb(), n = 2;
+    for (; n + 9 < t.byteLength;) {
+        let o = t.getUint16(n, ie);
         if (i.has(o)) return {
             mimeType: "image/jpeg",
-            height: e.getUint16(n + 5, it),
-            width: e.getUint16(n + 7, it)
+            height: t.getUint16(n + 5, ie),
+            width: t.getUint16(n + 7, ie)
         };
         if (!s.has(o)) return null;
-        n += 2, n += e.getUint16(n, it)
+        n += 2, n += t.getUint16(n, ie)
     }
     return null
 }
 
-function ET() {
-    let t = new Set([65499, 65476, 65484, 65501, 65534]);
-    for (let r = 65504; r < 65520; ++r) t.add(r);
+function Eb() {
+    let e = new Set([65499, 65476, 65484, 65501, 65534]);
+    for (let r = 65504; r < 65520; ++r) e.add(r);
     return {
-        tableMarkers: t,
+        tableMarkers: e,
         sofMarkers: new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
     }
 }
 
-function Zs(t) {
-    if (t instanceof DataView) return t;
-    if (ArrayBuffer.isView(t)) return new DataView(t.buffer);
-    if (t instanceof ArrayBuffer) return new DataView(t);
+function Zs(e) {
+    if (e instanceof DataView) return e;
+    if (ArrayBuffer.isView(e)) return new DataView(e.buffer);
+    if (e instanceof ArrayBuffer) return new DataView(e);
     throw new Error("toDataView")
 }
-async function wu(t, e) {
+async function Ru(e, t) {
     var r;
     let {
         mimeType: s
-    } = Wn(t) || {}, i = (r = globalThis.loaders) === null || r === void 0 ? void 0 : r.parseImageNode;
-    return kt(i), await i(t, s)
+    } = Wn(e) || {}, i = (r = globalThis.loaders) === null || r === void 0 ? void 0 : r.parseImageNode;
+    return De(i), await i(e, s)
 }
-async function Ru(t, e, r) {
-    e = e || {};
-    let i = (e.image || {}).type || "auto",
+async function vu(e, t, r) {
+    t = t || {};
+    let i = (t.image || {}).type || "auto",
         {
             url: n
         } = r || {},
-        o = AT(i),
+        o = xb(i),
         a;
     switch (o) {
         case "imagebitmap":
-            a = await xu(t, e, n);
+            a = await xu(e, t, n);
             break;
         case "image":
-            a = await Vn(t, e, n);
+            a = await Vn(e, t, n);
             break;
         case "data":
-            a = await wu(t, e);
+            a = await Ru(e, t);
             break;
         default:
-            kt(!1)
+            De(!1)
     }
-    return i === "data" && (a = bu(a)), a
+    return i === "data" && (a = wu(a)), a
 }
 
-function AT(t) {
-    switch (t) {
+function xb(e) {
+    switch (e) {
         case "auto":
         case "data":
-            return yu();
+            return Tu();
         default:
-            return Tu(t), t
+            return yu(e), e
     }
 }
-var xT = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"],
-    ST = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"],
-    wT = {
+var Sb = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"],
+    Rb = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"],
+    vb = {
         image: {
             type: "auto",
             decode: !0
         }
     },
     Rc = {
         id: "image",
         module: "images",
         name: "Images",
-        version: mu,
-        mimeTypes: ST,
-        extensions: xT,
-        parse: Ru,
-        tests: [t => !!Wn(new DataView(t))],
-        options: wT
+        version: bu,
+        mimeTypes: Rb,
+        extensions: Sb,
+        parse: vu,
+        tests: [e => !!Wn(new DataView(e))],
+        options: vb
     };
-var RT = new Se({
+var Mb = new xt({
         id: "deck"
     }),
-    W = RT;
+    W = Mb;
 var vc = {};
 
-function vu(t) {
-    vc = t
+function Mu(e) {
+    vc = e
 }
 
-function re(t, e, r, s) {
-    W.level > 0 && vc[t] && vc[t].call(null, e, r, s)
+function rt(e, t, r, s) {
+    W.level > 0 && vc[e] && vc[e].call(null, t, r, s)
 }
 
-function vT(t) {
-    let e = t[0],
-        r = t[t.length - 1];
-    return e === "{" && r === "}" || e === "[" && r === "]"
+function Pb(e) {
+    let t = e[0],
+        r = e[e.length - 1];
+    return t === "{" && r === "}" || t === "[" && r === "]"
 }
-var Mu = {
+var Pu = {
     id: "JSON",
     name: "JSON",
     module: "",
     version: "",
     options: {},
     extensions: ["json", "geojson"],
     mimeTypes: ["application/json", "application/geo+json"],
-    testText: vT,
+    testText: Pb,
     parseTextSync: JSON.parse
 };
 
-function MT() {
-    let t = "9.0.5",
-        e = globalThis.deck && globalThis.deck.VERSION;
-    if (e && e !== t) throw new Error(`deck.gl - multiple versions detected: ${e} vs ${t}`);
-    return e || (W.log(1, `deck.gl ${t}`)(), globalThis.deck = {
+function Cb() {
+    let e = "9.0.5",
+        t = globalThis.deck && globalThis.deck.VERSION;
+    if (t && t !== e) throw new Error(`deck.gl - multiple versions detected: ${t} vs ${e}`);
+    return t || (W.log(1, `deck.gl ${e}`)(), globalThis.deck = {
         ...globalThis.deck,
-        VERSION: t,
-        version: t,
+        VERSION: e,
+        version: e,
         log: W,
-        _registerLoggers: vu
-    }, mc([Mu, [Rc, {
+        _registerLoggers: Mu
+    }, mc([Pu, [Rc, {
         imagebitmap: {
             premultiplyAlpha: "none"
         }
-    }]])), t
+    }]])), e
 }
-var Mc = MT();
+var Mc = Cb();
 
-function nt(t, e) {
-    if (!t) throw new Error(e || "shadertools: assertion failed.")
+function ne(e, t) {
+    if (!e) throw new Error(t || "shadertools: assertion failed.")
 }
 var Pc = {
     number: {
         type: "number",
-        validate(t, e) {
-            return Number.isFinite(t) && typeof e == "object" && (e.max === void 0 || t <= e.max) && (e.min === void 0 || t >= e.min)
+        validate(e, t) {
+            return Number.isFinite(e) && typeof t == "object" && (t.max === void 0 || e <= t.max) && (t.min === void 0 || e >= t.min)
         }
     },
     array: {
         type: "array",
-        validate(t, e) {
-            return Array.isArray(t) || ArrayBuffer.isView(t)
+        validate(e, t) {
+            return Array.isArray(e) || ArrayBuffer.isView(e)
         }
     }
 };
 
-function Cu(t) {
-    let e = {};
-    for (let [r, s] of Object.entries(t)) e[r] = PT(s);
-    return e
+function Iu(e) {
+    let t = {};
+    for (let [r, s] of Object.entries(e)) t[r] = Ib(s);
+    return t
 }
 
-function Iu(t, e, r) {
+function Ou(e, t, r) {
     let s = {};
-    for (let [i, n] of Object.entries(e)) t && i in t && !n.private ? (n.validate && nt(n.validate(t[i], n), `${r}: invalid ${i}`), s[i] = t[i]) : s[i] = n.value;
+    for (let [i, n] of Object.entries(t)) e && i in e && !n.private ? (n.validate && ne(n.validate(e[i], n), `${r}: invalid ${i}`), s[i] = e[i]) : s[i] = n.value;
     return s
 }
 
-function PT(t) {
-    let e = Pu(t);
-    if (e !== "object") return {
-        value: t,
-        ...Pc[e],
-        type: e
+function Ib(e) {
+    let t = Cu(e);
+    if (t !== "object") return {
+        value: e,
+        ...Pc[t],
+        type: t
     };
-    if (typeof t == "object") return t ? t.type !== void 0 ? {
-        ...t,
-        ...Pc[t.type],
-        type: t.type
-    } : t.value === void 0 ? {
+    if (typeof e == "object") return e ? e.type !== void 0 ? {
+        ...e,
+        ...Pc[e.type],
+        type: e.type
+    } : e.value === void 0 ? {
         type: "object",
-        value: t
-    } : (e = Pu(t.value), {
-        ...t,
-        ...Pc[e],
-        type: e
+        value: e
+    } : (t = Cu(e.value), {
+        ...e,
+        ...Pc[t],
+        type: t
     }) : {
         type: "object",
         value: null
     };
     throw new Error("props")
 }
 
-function Pu(t) {
-    return Array.isArray(t) || ArrayBuffer.isView(t) ? "array" : typeof t
+function Cu(e) {
+    return Array.isArray(e) || ArrayBuffer.isView(e) ? "array" : typeof e
 }
-var Ou = `#ifdef MODULE_LOGDEPTH
+var Nu = `#ifdef MODULE_LOGDEPTH
 logdepth_adjustPosition(gl_Position);
 #endif
 `,
-    Nu = `#ifdef MODULE_MATERIAL
+    Fu = `#ifdef MODULE_MATERIAL
 gl_FragColor = material_filterColor(gl_FragColor);
 #endif
 #ifdef MODULE_LIGHTING
 gl_FragColor = lighting_filterColor(gl_FragColor);
 #endif
 #ifdef MODULE_FOG
 gl_FragColor = fog_filterColor(gl_FragColor);
@@ -3039,235 +3039,235 @@
 gl_FragColor = picking_filterHighlightColor(gl_FragColor);
 gl_FragColor = picking_filterPickingColor(gl_FragColor);
 #endif
 #ifdef MODULE_LOGDEPTH
 logdepth_setFragDepth();
 #endif
 `;
-var CT = {
-        vertex: Ou,
-        fragment: Nu
+var Ob = {
+        vertex: Nu,
+        fragment: Fu
     },
-    Fu = /void\s+main\s*\([^)]*\)\s*\{\n?/,
+    ku = /void\s+main\s*\([^)]*\)\s*\{\n?/,
     Du = /}\n?[^{}]*$/,
     Cc = [],
     Qs = "__LUMA_INJECT_DECLARATIONS__";
 
-function ku(t) {
-    let e = {
+function Bu(e) {
+    let t = {
         vertex: {},
         fragment: {}
     };
-    for (let r in t) {
-        let s = t[r],
-            i = IT(r);
+    for (let r in e) {
+        let s = e[r],
+            i = Nb(r);
         typeof s == "string" && (s = {
             order: 0,
             injection: s
-        }), e[i][r] = s
+        }), t[i][r] = s
     }
-    return e
+    return t
 }
 
-function IT(t) {
-    let e = t.slice(0, 2);
-    switch (e) {
+function Nb(e) {
+    let t = e.slice(0, 2);
+    switch (t) {
         case "vs":
             return "vertex";
         case "fs":
             return "fragment";
         default:
-            throw new Error(e)
+            throw new Error(t)
     }
 }
 
-function Js(t, e, r, s = !1) {
-    let i = e === "vertex";
+function Js(e, t, r, s = !1) {
+    let i = t === "vertex";
     for (let n in r) {
         let o = r[n];
         o.sort((c, l) => c.order - l.order), Cc.length = o.length;
         for (let c = 0, l = o.length; c < l; ++c) Cc[c] = o[c].injection;
         let a = `${Cc.join(`
 `)}
 `;
         switch (n) {
             case "vs:#decl":
-                i && (t = t.replace(Qs, a));
+                i && (e = e.replace(Qs, a));
                 break;
             case "vs:#main-start":
-                i && (t = t.replace(Fu, c => c + a));
+                i && (e = e.replace(ku, c => c + a));
                 break;
             case "vs:#main-end":
-                i && (t = t.replace(Du, c => a + c));
+                i && (e = e.replace(Du, c => a + c));
                 break;
             case "fs:#decl":
-                i || (t = t.replace(Qs, a));
+                i || (e = e.replace(Qs, a));
                 break;
             case "fs:#main-start":
-                i || (t = t.replace(Fu, c => c + a));
+                i || (e = e.replace(ku, c => c + a));
                 break;
             case "fs:#main-end":
-                i || (t = t.replace(Du, c => a + c));
+                i || (e = e.replace(Du, c => a + c));
                 break;
             default:
-                t = t.replace(n, c => c + a)
+                e = e.replace(n, c => c + a)
         }
     }
-    return t = t.replace(Qs, ""), s && (t = t.replace(/\}\s*$/, n => n + CT[e])), t
+    return e = e.replace(Qs, ""), s && (e = e.replace(/\}\s*$/, n => n + Ob[t])), e
 }
-var OT = 1,
-    Kr = class t {
-        constructor(e) {
-            f(this, "name");
-            f(this, "vs");
-            f(this, "fs");
-            f(this, "getModuleUniforms");
-            f(this, "dependencies");
-            f(this, "deprecations");
-            f(this, "defines");
-            f(this, "injections");
-            f(this, "uniforms", {});
-            f(this, "uniformTypes", {});
+var Fb = 1,
+    Kr = class e {
+        constructor(t) {
+            h(this, "name");
+            h(this, "vs");
+            h(this, "fs");
+            h(this, "getModuleUniforms");
+            h(this, "dependencies");
+            h(this, "deprecations");
+            h(this, "defines");
+            h(this, "injections");
+            h(this, "uniforms", {});
+            h(this, "uniformTypes", {});
             let {
                 name: r,
                 vs: s,
                 fs: i,
                 dependencies: n = [],
                 uniformPropTypes: o = {},
                 getUniforms: a,
                 deprecations: c = [],
                 defines: l = {},
-                inject: h = {}
-            } = e;
-            nt(typeof r == "string"), this.name = r, this.vs = s, this.fs = i, this.getModuleUniforms = a, this.dependencies = t.instantiateModules(n), this.deprecations = this._parseDeprecationDefinitions(c), this.defines = l, this.injections = ku(h), o && (this.uniforms = Cu(o))
-        }
-        static instantiateModules(e) {
-            return e.map(r => {
-                if (r instanceof t) return r;
-                nt(typeof r != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(r)}' and use it directly.`), r.name || (console.warn("shader module has no name"), r.name = `shader-module-${OT++}`);
-                let s = new t(r);
-                return s.dependencies = t.instantiateModules(r.dependencies || []), s
+                inject: f = {}
+            } = t;
+            ne(typeof r == "string"), this.name = r, this.vs = s, this.fs = i, this.getModuleUniforms = a, this.dependencies = e.instantiateModules(n), this.deprecations = this._parseDeprecationDefinitions(c), this.defines = l, this.injections = Bu(f), o && (this.uniforms = Iu(o))
+        }
+        static instantiateModules(t) {
+            return t.map(r => {
+                if (r instanceof e) return r;
+                ne(typeof r != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(r)}' and use it directly.`), r.name || (console.warn("shader module has no name"), r.name = `shader-module-${Fb++}`);
+                let s = new e(r);
+                return s.dependencies = e.instantiateModules(r.dependencies || []), s
             })
         }
-        getModuleSource(e) {
+        getModuleSource(t) {
             let r;
-            switch (e) {
+            switch (t) {
                 case "vertex":
                     r = this.vs || "";
                     break;
                 case "fragment":
                     r = this.fs || "";
                     break;
                 default:
-                    nt(!1)
+                    ne(!1)
             }
             let s = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
             return `// ----- MODULE ${this.name} ---------------
 
 #define MODULE_${s}
 ${r}
 
 `
         }
-        getUniforms(e, r) {
-            return this.getModuleUniforms ? this.getModuleUniforms(e, r) : Iu(e, this.uniforms, this.name)
+        getUniforms(t, r) {
+            return this.getModuleUniforms ? this.getModuleUniforms(t, r) : Ou(t, this.uniforms, this.name)
         }
         getDefines() {
             return this.defines
         }
-        checkDeprecations(e, r) {
+        checkDeprecations(t, r) {
             this.deprecations.forEach(s => {
-                s.regex?.test(e) && (s.deprecated ? r.deprecated(s.old, s.new)() : r.removed(s.old, s.new)())
+                s.regex?.test(t) && (s.deprecated ? r.deprecated(s.old, s.new)() : r.removed(s.old, s.new)())
             })
         }
-        _parseDeprecationDefinitions(e) {
-            return e.forEach(r => {
+        _parseDeprecationDefinitions(t) {
+            return t.forEach(r => {
                 switch (r.type) {
                     case "function":
                         r.regex = new RegExp(`\\b${r.old}\\(`);
                         break;
                     default:
                         r.regex = new RegExp(`${r.type} ${r.old};`)
                 }
-            }), e
+            }), t
         }
-        _defaultGetUniforms(e = {}) {
+        _defaultGetUniforms(t = {}) {
             let r = {},
                 s = this.uniforms;
             for (let i in s) {
                 let n = s[i];
-                i in e && !n.private ? (n.validate && nt(n.validate(e[i], n), `${this.name}: invalid ${i}`), r[i] = e[i]) : r[i] = n.value
+                i in t && !n.private ? (n.validate && ne(n.validate(t[i], n), `${this.name}: invalid ${i}`), r[i] = t[i]) : r[i] = n.value
             }
             return r
         }
     };
 
-function Ic(t) {
-    if (t.source && t.platformInfo.type === "webgpu") return {
-        ...t,
+function Ic(e) {
+    if (e.source && e.platformInfo.type === "webgpu") return {
+        ...e,
         vs: void 0,
         fs: void 0
     };
-    if (!t.vs) throw new Error("no vertex shader");
-    let e = Bu(t.platformInfo, t.vs),
+    if (!e.vs) throw new Error("no vertex shader");
+    let t = Uu(e.platformInfo, e.vs),
         r;
-    return t.fs && (r = Bu(t.platformInfo, t.fs)), {
-        ...t,
-        vs: e,
+    return e.fs && (r = Uu(e.platformInfo, e.fs)), {
+        ...e,
+        vs: t,
         fs: r
     }
 }
 
-function Bu(t, e) {
-    if (typeof e == "string") return e;
-    switch (t.type) {
+function Uu(e, t) {
+    if (typeof t == "string") return t;
+    switch (e.type) {
         case "webgpu":
-            if (e?.wgsl) return e.wgsl;
+            if (t?.wgsl) return t.wgsl;
             throw new Error("WebGPU does not support GLSL shaders");
         default:
-            if (e?.glsl) return e.glsl;
+            if (t?.glsl) return t.glsl;
             throw new Error("WebGL does not support WGSL shaders")
     }
 }
 
-function mr(t) {
-    let e = Kr.instantiateModules(t);
-    return NT(e)
+function mr(e) {
+    let t = Kr.instantiateModules(e);
+    return kb(t)
 }
 
-function NT(t) {
-    let e = {},
+function kb(e) {
+    let t = {},
         r = {};
-    return Uu({
-        modules: t,
+    return Lu({
+        modules: e,
         level: 0,
-        moduleMap: e,
+        moduleMap: t,
         moduleDepth: r
-    }), Object.keys(r).sort((s, i) => r[i] - r[s]).map(s => e[s])
+    }), Object.keys(r).sort((s, i) => r[i] - r[s]).map(s => t[s])
 }
 
-function Uu(t) {
+function Lu(e) {
     let {
-        modules: e,
+        modules: t,
         level: r,
         moduleMap: s,
         moduleDepth: i
-    } = t;
+    } = e;
     if (r >= 5) throw new Error("Possible loop in shader dependency graph");
-    for (let n of e) s[n.name] = n, (i[n.name] === void 0 || i[n.name] < r) && (i[n.name] = r);
-    for (let n of e) n.dependencies && Uu({
+    for (let n of t) s[n.name] = n, (i[n.name] === void 0 || i[n.name] < r) && (i[n.name] = r);
+    for (let n of t) n.dependencies && Lu({
         modules: n.dependencies,
         level: r + 1,
         moduleMap: s,
         moduleDepth: i
     })
 }
 
-function Lu(t) {
-    switch (t?.gpu.toLowerCase()) {
+function Vu(e) {
+    switch (e?.gpu.toLowerCase()) {
         case "apple":
             return `#define APPLE_GPU
 #define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
 #define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
 #define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
 `;
         case "nvidia":
@@ -3288,687 +3288,687 @@
 #define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
 #define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
 #define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
 `
     }
 }
 
-function Wu(t, e) {
-    if (Number(t.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
-    switch (e) {
+function zu(e, t) {
+    if (Number(e.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
+    switch (t) {
         case "vertex":
-            return t = Vu(t, FT), t;
+            return e = Wu(e, Db), e;
         case "fragment":
-            return t = Vu(t, DT), t;
+            return e = Wu(e, Bb), e;
         default:
-            throw new Error(e)
+            throw new Error(t)
     }
 }
-var zu = [
+var ju = [
         [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
 `],
         [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
         [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
     ],
-    FT = [...zu, [Oc("attribute"), "in $1"],
+    Db = [...ju, [Oc("attribute"), "in $1"],
         [Oc("varying"), "out $1"]
     ],
-    DT = [...zu, [Oc("varying"), "in $1"]];
+    Bb = [...ju, [Oc("varying"), "in $1"]];
 
-function Vu(t, e) {
-    for (let [r, s] of e) t = t.replace(r, s);
-    return t
+function Wu(e, t) {
+    for (let [r, s] of t) e = e.replace(r, s);
+    return e
 }
 
-function Oc(t) {
-    return new RegExp(`\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g")
+function Oc(e) {
+    return new RegExp(`\\b${e}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g")
 }
 
-function Nc(t, e) {
+function Nc(e, t) {
     let r = "";
-    for (let s in t) {
-        let i = t[s];
+    for (let s in e) {
+        let i = e[s];
         if (r += `void ${i.signature} {
-`, i.header && (r += `  ${i.header}`), e[s]) {
-            let n = e[s];
+`, i.header && (r += `  ${i.header}`), t[s]) {
+            let n = t[s];
             n.sort((o, a) => o.order - a.order);
             for (let o of n) r += `  ${o.injection}
 `
         }
         i.footer && (r += `  ${i.footer}`), r += `}
 `
     }
     return r
 }
 
-function Fc(t) {
-    let e = {
+function Fc(e) {
+    let t = {
         vertex: {},
         fragment: {}
     };
-    for (let r of t) {
+    for (let r of e) {
         let s, i;
         typeof r != "string" ? (s = r, i = s.hook) : (s = {}, i = r), i = i.trim();
         let [n, o] = i.split(":"), a = i.replace(/\(.+/, ""), c = Object.assign(s, {
             signature: o
         });
         switch (n) {
             case "vs":
-                e.vertex[a] = c;
+                t.vertex[a] = c;
                 break;
             case "fs":
-                e.fragment[a] = c;
+                t.fragment[a] = c;
                 break;
             default:
                 throw new Error(n)
         }
     }
-    return e
+    return t
 }
 
-function Hu(t, e) {
+function Hu(e, t) {
     return {
-        name: kT(t, e),
+        name: Ub(e, t),
         language: "glsl",
-        version: BT(t)
+        version: Lb(e)
     }
 }
 
-function kT(t, e = "unnamed") {
-    let s = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(t);
-    return s ? s[1] : e
+function Ub(e, t = "unnamed") {
+    let s = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(e);
+    return s ? s[1] : t
 }
 
-function BT(t) {
-    let e = 100,
-        r = t.match(/[^\s]+/g);
+function Lb(e) {
+    let t = 100,
+        r = e.match(/[^\s]+/g);
     if (r && r.length >= 2 && r[0] === "#version") {
         let s = parseInt(r[1], 10);
-        Number.isFinite(s) && (e = s)
+        Number.isFinite(s) && (t = s)
     }
-    if (e !== 100 && e !== 300) throw new Error(`Invalid GLSL version ${e}`);
-    return e
+    if (t !== 100 && t !== 300) throw new Error(`Invalid GLSL version ${t}`);
+    return t
 }
-var Xu = `
+var $u = `
 
 ${Qs}
 `,
-    UT = `precision highp float;
+    Vb = `precision highp float;
 `;
 
-function $u(t) {
-    let e = mr(t.modules || []);
+function Yu(e) {
+    let t = mr(e.modules || []);
     return {
-        source: Dc(t.platformInfo, {
-            ...t,
-            source: t.source,
+        source: kc(e.platformInfo, {
+            ...e,
+            source: e.source,
             stage: "vertex",
-            modules: e
+            modules: t
         }),
-        getUniforms: kc(e)
+        getUniforms: Dc(t)
     }
 }
 
-function Yu(t) {
-    let e = mr(t.modules || []);
+function qu(e) {
+    let t = mr(e.modules || []);
     return {
-        vs: Dc(t.platformInfo, {
-            ...t,
-            source: t.vs,
+        vs: kc(e.platformInfo, {
+            ...e,
+            source: e.vs,
             stage: "vertex",
-            modules: e
+            modules: t
         }),
-        fs: Dc(t.platformInfo, {
-            ...t,
-            source: t.fs,
+        fs: kc(e.platformInfo, {
+            ...e,
+            source: e.fs,
             stage: "fragment",
-            modules: e
+            modules: t
         }),
-        getUniforms: kc(e)
+        getUniforms: Dc(t)
     }
 }
 
-function qu(t) {
+function Ku(e) {
     let {
-        vs: e,
+        vs: t,
         fs: r
-    } = t, s = mr(t.modules || []);
+    } = e, s = mr(e.modules || []);
     return {
-        vs: ju(t.platformInfo, {
-            ...t,
-            source: e,
+        vs: Xu(e.platformInfo, {
+            ...e,
+            source: t,
             stage: "vertex",
             modules: s
         }),
-        fs: ju(t.platformInfo, {
-            ...t,
+        fs: Xu(e.platformInfo, {
+            ...e,
             source: r,
             stage: "fragment",
             modules: s
         }),
-        getUniforms: kc(s)
+        getUniforms: Dc(s)
     }
 }
 
-function Dc(t, e) {
+function kc(e, t) {
     let {
         source: r,
         stage: s,
         modules: i,
         hookFunctions: n = [],
         inject: o = {},
         log: a
-    } = e;
-    nt(typeof r == "string", "shader source must be a string");
+    } = t;
+    ne(typeof r == "string", "shader source must be a string");
     let c = r,
         l = "",
-        h = Fc(n),
+        f = Fc(n),
         d = {},
         p = {},
         m = {};
-    for (let x in o) {
-        let b = typeof o[x] == "string" ? {
-                injection: o[x],
+    for (let E in o) {
+        let T = typeof o[E] == "string" ? {
+                injection: o[E],
                 order: 0
-            } : o[x],
-            w = /^(v|f)s:(#)?([\w-]+)$/.exec(x);
-        if (w) {
-            let R = w[2],
-                v = w[3];
-            R ? v === "decl" ? p[x] = [b] : m[x] = [b] : d[x] = [b]
-        } else m[x] = [b]
-    }
-    let y = t.type !== "webgpu" ? i : [];
-    for (let x of y) {
-        a && x.checkDeprecations(c, a);
-        let b = x.getModuleSource(s, "wgsl");
-        l += b;
-        let w = x.injections[s];
-        for (let R in w) {
+            } : o[E],
+            S = /^(v|f)s:(#)?([\w-]+)$/.exec(E);
+        if (S) {
+            let R = S[2],
+                v = S[3];
+            R ? v === "decl" ? p[E] = [T] : m[E] = [T] : d[E] = [T]
+        } else m[E] = [T]
+    }
+    let y = e.type !== "webgpu" ? i : [];
+    for (let E of y) {
+        a && E.checkDeprecations(c, a);
+        let T = E.getModuleSource(s, "wgsl");
+        l += T;
+        let S = E.injections[s];
+        for (let R in S) {
             let v = /^(v|f)s:#([\w-]+)$/.exec(R);
             if (v) {
                 let O = v[2] === "decl" ? p : m;
-                O[R] = O[R] || [], O[R].push(w[R])
-            } else d[R] = d[R] || [], d[R].push(w[R])
+                O[R] = O[R] || [], O[R].push(S[R])
+            } else d[R] = d[R] || [], d[R].push(S[R])
         }
     }
-    return l += Xu, l = Js(l, s, p), l += Nc(h[s], d), l += c, l = Js(l, s, m), l
+    return l += $u, l = Js(l, s, p), l += Nc(f[s], d), l += c, l = Js(l, s, m), l
 }
 
-function ju(t, e) {
+function Xu(e, t) {
     let {
         id: r,
         source: s,
         stage: i,
         language: n = "glsl",
         modules: o,
         defines: a = {},
         hookFunctions: c = [],
         inject: l = {},
-        prologue: h = !0,
+        prologue: f = !0,
         log: d
-    } = e;
-    nt(typeof s == "string", "shader source must be a string");
+    } = t;
+    ne(typeof s == "string", "shader source must be a string");
     let p = n === "glsl" ? Hu(s).version : -1,
-        m = t.shaderLanguageVersion,
+        m = e.shaderLanguageVersion,
         y = p === 100 ? "#version 100" : "#version 300 es",
-        b = s.split(`
+        T = s.split(`
 `).slice(1).join(`
 `),
-        w = {};
+        S = {};
     o.forEach(U => {
-        Object.assign(w, U.getDefines())
-    }), Object.assign(w, a);
+        Object.assign(S, U.getDefines())
+    }), Object.assign(S, a);
     let R = "";
     switch (n) {
         case "wgsl":
             break;
         case "glsl":
-            R = h ? `${y}
+            R = f ? `${y}
 
 // ----- PROLOGUE -------------------------
-${LT({id:r,source:s,stage:i})}
+${Wb({id:r,source:s,stage:i})}
 ${`#define SHADER_TYPE_${i.toUpperCase()}`}
-${Lu(t)}
-${i==="fragment"?UT:""}
+${Vu(e)}
+${i==="fragment"?Vb:""}
 
 // ----- APPLICATION DEFINES -------------------------
 
-${VT(w)}
+${zb(S)}
 
 ` : `${y}
 `;
             break
     }
     let v = Fc(c),
         C = {},
         O = {},
         N = {};
     for (let U in l) {
-        let k = typeof l[U] == "string" ? {
+        let D = typeof l[U] == "string" ? {
                 injection: l[U],
                 order: 0
             } : l[U],
             B = /^(v|f)s:(#)?([\w-]+)$/.exec(U);
         if (B) {
             let F = B[2],
                 L = B[3];
-            F ? L === "decl" ? O[U] = [k] : N[U] = [k] : C[U] = [k]
-        } else N[U] = [k]
+            F ? L === "decl" ? O[U] = [D] : N[U] = [D] : C[U] = [D]
+        } else N[U] = [D]
     }
     for (let U of o) {
-        d && U.checkDeprecations(b, d);
-        let k = U.getModuleSource(i);
-        R += k;
+        d && U.checkDeprecations(T, d);
+        let D = U.getModuleSource(i);
+        R += D;
         let B = U.injections[i];
         for (let F in B) {
             let L = /^(v|f)s:#([\w-]+)$/.exec(F);
             if (L) {
                 let $ = L[2] === "decl" ? O : N;
                 $[F] = $[F] || [], $[F].push(B[F])
             } else C[F] = C[F] || [], C[F].push(B[F])
         }
     }
-    return R += "// ----- MAIN SHADER SOURCE -------------------------", R += Xu, R = Js(R, i, O), R += Nc(v[i], C), R += b, R = Js(R, i, N), n === "glsl" && p !== m && (R = Wu(R, i)), R.trim()
+    return R += "// ----- MAIN SHADER SOURCE -------------------------", R += $u, R = Js(R, i, O), R += Nc(v[i], C), R += T, R = Js(R, i, N), n === "glsl" && p !== m && (R = zu(R, i)), R.trim()
 }
 
-function kc(t) {
+function Dc(e) {
     return function(r) {
         let s = {};
-        for (let i of t) {
+        for (let i of e) {
             let n = i.getUniforms(r, s);
             Object.assign(s, n)
         }
         return s
     }
 }
 
-function LT(t) {
+function Wb(e) {
     let {
-        id: e,
+        id: t,
         source: r,
         stage: s
-    } = t;
-    return e && r.indexOf("SHADER_NAME") === -1 ? `
-#define SHADER_NAME ${e}_${s}
+    } = e;
+    return t && r.indexOf("SHADER_NAME") === -1 ? `
+#define SHADER_NAME ${t}_${s}
 
 ` : ""
 }
 
-function VT(t = {}) {
-    let e = "";
-    for (let r in t) {
-        let s = t[r];
-        (s || Number.isFinite(s)) && (e += `#define ${r.toUpperCase()} ${t[r]}
+function zb(e = {}) {
+    let t = "";
+    for (let r in e) {
+        let s = e[r];
+        (s || Number.isFinite(s)) && (t += `#define ${r.toUpperCase()} ${e[r]}
 `)
     }
-    return e
+    return t
 }
-var Tr = class Tr {
+var br = class br {
     constructor() {
-        f(this, "_hookFunctions", []);
-        f(this, "_defaultModules", [])
+        h(this, "_hookFunctions", []);
+        h(this, "_defaultModules", [])
     }
     static getDefaultShaderAssembler() {
-        return Tr.defaultShaderAssembler = Tr.defaultShaderAssembler || new Tr, Tr.defaultShaderAssembler
+        return br.defaultShaderAssembler = br.defaultShaderAssembler || new br, br.defaultShaderAssembler
     }
-    addDefaultModule(e) {
-        this._defaultModules.find(r => r.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e)
+    addDefaultModule(t) {
+        this._defaultModules.find(r => r.name === (typeof t == "string" ? t : t.name)) || this._defaultModules.push(t)
     }
-    removeDefaultModule(e) {
-        let r = typeof e == "string" ? e : e.name;
+    removeDefaultModule(t) {
+        let r = typeof t == "string" ? t : t.name;
         this._defaultModules = this._defaultModules.filter(s => s.name !== r)
     }
-    addShaderHook(e, r) {
-        r && (e = Object.assign(r, {
-            hook: e
-        })), this._hookFunctions.push(e)
+    addShaderHook(t, r) {
+        r && (t = Object.assign(r, {
+            hook: t
+        })), this._hookFunctions.push(t)
     }
-    assembleShader(e) {
-        let r = this._getModuleList(e.modules),
+    assembleShader(t) {
+        let r = this._getModuleList(t.modules),
             s = this._hookFunctions,
-            i = Ic(e);
+            i = Ic(t);
         return {
-            ...$u({
-                platformInfo: e.platformInfo,
+            ...Yu({
+                platformInfo: t.platformInfo,
                 ...i,
                 modules: r,
                 hookFunctions: s
             }),
             modules: r
         }
     }
-    assembleShaderPair(e) {
-        let r = Ic(e),
-            s = this._getModuleList(e.modules),
+    assembleShaderPair(t) {
+        let r = Ic(t),
+            s = this._getModuleList(t.modules),
             i = this._hookFunctions,
             {
                 platformInfo: n
-            } = e;
+            } = t;
         return {
-            ...e.platformInfo.shaderLanguage === "wgsl" ? Yu({
+            ...t.platformInfo.shaderLanguage === "wgsl" ? qu({
                 platformInfo: n,
                 ...r,
                 modules: s,
                 hookFunctions: i
-            }) : qu({
+            }) : Ku({
                 platformInfo: n,
                 ...r,
                 modules: s,
                 hookFunctions: i
             }),
             modules: s
         }
     }
-    _getModuleList(e = []) {
-        let r = new Array(this._defaultModules.length + e.length),
+    _getModuleList(t = []) {
+        let r = new Array(this._defaultModules.length + t.length),
             s = {},
             i = 0;
         for (let n = 0, o = this._defaultModules.length; n < o; ++n) {
             let a = this._defaultModules[n],
                 c = a.name;
             r[i++] = a, s[c] = !0
         }
-        for (let n = 0, o = e.length; n < o; ++n) {
-            let a = e[n],
+        for (let n = 0, o = t.length; n < o; ++n) {
+            let a = t[n],
                 c = a.name;
             s[c] || (r[i++] = a, s[c] = !0)
         }
         return r.length = i, Kr.instantiateModules(r)
     }
 };
-f(Tr, "defaultShaderAssembler");
-var yr = Tr;
-var WT = `out vec4 transform_output;
+h(br, "defaultShaderAssembler");
+var yr = br;
+var jb = `out vec4 transform_output;
 void main() {
 transform_output = vec4(0);
 }`,
-    zT = `#version 300 es
-${WT}`;
+    Hb = `#version 300 es
+${jb}`;
 
-function Bc(t) {
+function Bc(e) {
     let {
-        input: e,
+        input: t,
         inputChannels: r,
         output: s
-    } = t || {};
-    if (!e) return zT;
+    } = e || {};
+    if (!t) return Hb;
     if (!r) throw new Error("inputChannels");
-    let i = HT(r),
-        n = Ku(e, r);
+    let i = Xb(r),
+        n = Zu(t, r);
     return `#version 300 es
-in ${i} ${e};
+in ${i} ${t};
 out vec4 ${s};
 void main() {
   ${s} = ${n};
 }`
 }
 
-function HT(t) {
-    switch (t) {
+function Xb(e) {
+    switch (e) {
         case 1:
             return "float";
         case 2:
             return "vec2";
         case 3:
             return "vec3";
         case 4:
             return "vec4";
         default:
-            throw new Error(`invalid channels: ${t}`)
+            throw new Error(`invalid channels: ${e}`)
     }
 }
 
-function Ku(t, e) {
-    switch (e) {
+function Zu(e, t) {
+    switch (t) {
         case 1:
-            return `vec4(${t}, 0.0, 0.0, 1.0)`;
+            return `vec4(${e}, 0.0, 0.0, 1.0)`;
         case 2:
-            return `vec4(${t}, 0.0, 1.0)`;
+            return `vec4(${e}, 0.0, 1.0)`;
         case 3:
-            return `vec4(${t}, 1.0)`;
+            return `vec4(${e}, 1.0)`;
         case 4:
-            return t;
+            return e;
         default:
-            throw new Error(`invalid channels: ${e}`)
+            throw new Error(`invalid channels: ${t}`)
     }
 }
-var P = new Se({
+var P = new xt({
     id: "luma.gl"
 });
 var Uc = class {
         constructor() {
-            f(this, "stats", new Map)
+            h(this, "stats", new Map)
         }
-        getStats(e) {
-            return this.get(e)
+        getStats(t) {
+            return this.get(t)
         }
-        get(e) {
-            return this.stats.has(e) || this.stats.set(e, new Ne({
-                id: e
-            })), this.stats.get(e)
+        get(t) {
+            return this.stats.has(t) || this.stats.set(t, new Nt({
+                id: t
+            })), this.stats.get(t)
         }
     },
     Zr = new Uc;
 
-function jT() {
-    let t = "9.0.9",
-        e = "set luma.log.level=1 (or higher) to trace rendering";
-    if (globalThis.luma && globalThis.luma.VERSION !== t) throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${t}`);
-    return globalThis.luma || (pe() && P.log(1, `${t} - ${e}`)(), globalThis.luma = globalThis.luma || {
-        VERSION: t,
-        version: t,
+function $b() {
+    let e = "9.0.9",
+        t = "set luma.log.level=1 (or higher) to trace rendering";
+    if (globalThis.luma && globalThis.luma.VERSION !== e) throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${e}`);
+    return globalThis.luma || (pt() && P.log(1, `${e} - ${t}`)(), globalThis.luma = globalThis.luma || {
+        VERSION: e,
+        version: e,
         log: P,
         stats: Zr
-    }), t
+    }), e
 }
-var Zu = jT();
+var Qu = $b();
 
-function XT(t) {
-    return ArrayBuffer.isView(t) && !(t instanceof DataView) ? t : null
+function Yb(e) {
+    return ArrayBuffer.isView(e) && !(e instanceof DataView) ? e : null
 }
 
-function Lt(t) {
-    return Array.isArray(t) ? t.length === 0 || typeof t[0] == "number" ? t : null : XT(t)
+function Le(e) {
+    return Array.isArray(e) ? e.length === 0 || typeof e[0] == "number" ? e : null : Yb(e)
 }
 var Lc = {};
 
-function Ee(t = "id") {
-    Lc[t] = Lc[t] || 1;
-    let e = Lc[t]++;
-    return `${t}-${e}`
+function wt(e = "id") {
+    Lc[e] = Lc[e] || 1;
+    let t = Lc[e]++;
+    return `${e}-${t}`
 }
 
-function Vt(t) {
-    let e = !0;
-    for (let r in t) {
-        e = !1;
+function Ve(e) {
+    let t = !0;
+    for (let r in e) {
+        t = !1;
         break
     }
-    return e
+    return t
 }
 var V = class {
-    constructor(e, r, s) {
-        f(this, "id");
-        f(this, "props");
-        f(this, "userData", {});
-        f(this, "_device");
-        f(this, "destroyed", !1);
-        f(this, "allocatedBytes", 0);
-        f(this, "_attachedResources", new Set);
-        if (!e) throw new Error("no device");
-        this._device = e, this.props = $T(r, s);
-        let i = this.props.id !== "undefined" ? this.props.id : Ee(this[Symbol.toStringTag]);
+    constructor(t, r, s) {
+        h(this, "id");
+        h(this, "props");
+        h(this, "userData", {});
+        h(this, "_device");
+        h(this, "destroyed", !1);
+        h(this, "allocatedBytes", 0);
+        h(this, "_attachedResources", new Set);
+        if (!t) throw new Error("no device");
+        this._device = t, this.props = qb(r, s);
+        let i = this.props.id !== "undefined" ? this.props.id : wt(this[Symbol.toStringTag]);
         this.props.id = i, this.id = i, this.userData = this.props.userData || {}, this.addStats()
     }
     destroy() {
         this.destroyResource()
     }
     delete() {
         return this.destroy(), this
     }
     toString() {
         return `${this[Symbol.toStringTag]||this.constructor.name}(${this.id})`
     }
     getProps() {
         return this.props
     }
-    attachResource(e) {
-        this._attachedResources.add(e)
+    attachResource(t) {
+        this._attachedResources.add(t)
     }
-    detachResource(e) {
-        this._attachedResources.delete(e)
+    detachResource(t) {
+        this._attachedResources.delete(t)
     }
-    destroyAttachedResource(e) {
-        this._attachedResources.delete(e) && e.destroy()
+    destroyAttachedResource(t) {
+        this._attachedResources.delete(t) && t.destroy()
     }
     destroyAttachedResources() {
-        for (let e of Object.values(this._attachedResources)) e.destroy();
+        for (let t of Object.values(this._attachedResources)) t.destroy();
         this._attachedResources = new Set
     }
     destroyResource() {
         this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0
     }
     removeStats() {
-        let e = this._device.statsManager.getStats("Resource Counts"),
+        let t = this._device.statsManager.getStats("Resource Counts"),
             r = this[Symbol.toStringTag];
-        e.get(`${r}s Active`).decrementCount()
+        t.get(`${r}s Active`).decrementCount()
     }
-    trackAllocatedMemory(e, r = this[Symbol.toStringTag]) {
+    trackAllocatedMemory(t, r = this[Symbol.toStringTag]) {
         let s = this._device.statsManager.getStats("Resource Counts");
-        s.get("GPU Memory").addCount(e), s.get(`${r} Memory`).addCount(e), this.allocatedBytes = e
+        s.get("GPU Memory").addCount(t), s.get(`${r} Memory`).addCount(t), this.allocatedBytes = t
     }
-    trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
+    trackDeallocatedMemory(t = this[Symbol.toStringTag]) {
         let r = this._device.statsManager.getStats("Resource Counts");
-        r.get("GPU Memory").subtractCount(this.allocatedBytes), r.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0
+        r.get("GPU Memory").subtractCount(this.allocatedBytes), r.get(`${t} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0
     }
     addStats() {
-        let e = this._device.statsManager.getStats("Resource Counts"),
+        let t = this._device.statsManager.getStats("Resource Counts"),
             r = this[Symbol.toStringTag];
-        e.get("Resources Created").incrementCount(), e.get(`${r}s Created`).incrementCount(), e.get(`${r}s Active`).incrementCount()
+        t.get("Resources Created").incrementCount(), t.get(`${r}s Created`).incrementCount(), t.get(`${r}s Active`).incrementCount()
     }
 };
-f(V, "defaultProps", {
+h(V, "defaultProps", {
     id: "undefined",
     handle: void 0,
     userData: void 0
 });
 
-function $T(t, e) {
+function qb(e, t) {
     let r = {
-        ...e
+        ...t
     };
-    for (let s in t) t[s] !== void 0 && (r[s] = t[s]);
+    for (let s in e) e[s] !== void 0 && (r[s] = e[s]);
     return r
 }
-var he = class he extends V {
+var ft = class ft extends V {
     constructor(r, s) {
         let i = {
             ...s
         };
-        (s.usage || 0) & he.INDEX && !s.indexType && (s.data instanceof Uint32Array ? i.indexType = "uint32" : s.data instanceof Uint16Array && (i.indexType = "uint16"));
-        super(r, i, he.defaultProps);
-        f(this, "usage");
-        f(this, "indexType");
-        f(this, "updateTimestamp");
-        f(this, "debugData", new ArrayBuffer(0));
+        (s.usage || 0) & ft.INDEX && !s.indexType && (s.data instanceof Uint32Array ? i.indexType = "uint32" : s.data instanceof Uint16Array && (i.indexType = "uint16"));
+        super(r, i, ft.defaultProps);
+        h(this, "usage");
+        h(this, "indexType");
+        h(this, "updateTimestamp");
+        h(this, "debugData", new ArrayBuffer(0));
         this.usage = s.usage || 0, this.indexType = i.indexType, this.updateTimestamp = r.incrementTimestamp()
     }
     get[Symbol.toStringTag]() {
         return "Buffer"
     }
     readSyncWebGL(r, s) {
         throw new Error("not implemented")
     }
     _setDebugData(r, s, i) {
         let n = ArrayBuffer.isView(r) ? r.buffer : r,
-            o = Math.min(r ? r.byteLength : i, he.DEBUG_DATA_MAX_LENGTH);
+            o = Math.min(r ? r.byteLength : i, ft.DEBUG_DATA_MAX_LENGTH);
         r === null ? this.debugData = new ArrayBuffer(o) : s === 0 && i === r.byteLength ? this.debugData = n.slice(0, o) : this.debugData = n.slice(s, s + o)
     }
 };
-f(he, "defaultProps", {
+h(ft, "defaultProps", {
     ...V.defaultProps,
     usage: 0,
     byteLength: 0,
     byteOffset: 0,
     data: null,
     indexType: "uint16",
     mappedAtCreation: !1
-}), f(he, "MAP_READ", 1), f(he, "MAP_WRITE", 2), f(he, "COPY_SRC", 4), f(he, "COPY_DST", 8), f(he, "INDEX", 16), f(he, "VERTEX", 32), f(he, "UNIFORM", 64), f(he, "STORAGE", 128), f(he, "INDIRECT", 256), f(he, "QUERY_RESOLVE", 512), f(he, "DEBUG_DATA_MAX_LENGTH", 32);
-var K = he;
+}), h(ft, "MAP_READ", 1), h(ft, "MAP_WRITE", 2), h(ft, "COPY_SRC", 4), h(ft, "COPY_DST", 8), h(ft, "INDEX", 16), h(ft, "VERTEX", 32), h(ft, "UNIFORM", 64), h(ft, "STORAGE", 128), h(ft, "INDIRECT", 256), h(ft, "QUERY_RESOLVE", 512), h(ft, "DEBUG_DATA_MAX_LENGTH", 32);
+var K = ft;
 
-function zn(t) {
-    let e = Qu[t],
-        r = YT(e),
-        s = t.includes("norm"),
-        i = !s && !t.startsWith("float"),
-        n = t.startsWith("s");
+function zn(e) {
+    let t = Ju[e],
+        r = Kb(t),
+        s = e.includes("norm"),
+        i = !s && !e.startsWith("float"),
+        n = e.startsWith("s");
     return {
-        dataType: Qu[t],
+        dataType: Ju[e],
         byteLength: r,
         integer: i,
         signed: n,
         normalized: s
     }
 }
 
-function YT(t) {
-    return qT[t]
+function Kb(e) {
+    return Zb[e]
 }
-var Qu = {
+var Ju = {
         uint8: "uint8",
         sint8: "sint8",
         unorm8: "uint8",
         snorm8: "sint8",
         uint16: "uint16",
         sint16: "sint16",
         unorm16: "uint16",
         snorm16: "sint16",
         float16: "float16",
         float32: "float32",
         uint32: "uint32",
         sint32: "sint32"
     },
-    qT = {
+    Zb = {
         uint8: 1,
         sint8: 1,
         uint16: 2,
         sint16: 2,
         float16: 2,
         float32: 4,
         uint32: 4,
         sint32: 4
     };
-var KT = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"],
-    ZT = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
+var Qb = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"],
+    Jb = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
 
-function Ju(t) {
-    return KT.some(e => t.startsWith(e))
+function Gu(e) {
+    return Qb.some(t => e.startsWith(t))
 }
 
-function Hn(t) {
-    let e = ZT.exec(t);
-    if (e) {
-        let [, r, s, i, n, o] = e;
+function jn(e) {
+    let t = Jb.exec(e);
+    if (t) {
+        let [, r, s, i, n, o] = t;
         if (r) {
             let a = `${i}${s}`,
                 c = zn(a);
             return {
                 format: r,
                 components: r.length,
                 srgb: n === "-srgb",
                 unsized: o === "-unsized",
                 webgl: o === "-webgl",
                 ...c
             }
         }
     }
-    return JT(t)
+    return ty(e)
 }
-var QT = {
+var Gb = {
     "rgba4unorm-webgl": {
         format: "rgba",
         bpp: 2
     },
     "rgb565unorm-webgl": {
         format: "rgb",
         bpp: 2
@@ -4026,110 +4026,110 @@
     "depth32float-stencil8": {
         components: 2,
         bpp: 4,
         a: "depth-stencil"
     }
 };
 
-function JT(t) {
-    let e = QT[t];
-    if (!e) throw new Error(`Unknown format ${t}`);
+function ty(e) {
+    let t = Gb[e];
+    if (!t) throw new Error(`Unknown format ${e}`);
     return {
-        format: e.format || "",
-        components: e.components || e.format?.length || 1,
-        byteLength: e.bpp || 1,
+        format: t.format || "",
+        components: t.components || t.format?.length || 1,
+        byteLength: t.bpp || 1,
         srgb: !1,
         unsized: !1
     }
 }
-var ei = class {},
-    ti = class {
-        constructor(e = [], r) {
-            f(this, "features");
-            f(this, "disabledFeatures");
-            this.features = new Set(e), this.disabledFeatures = r || {}
+var ti = class {},
+    ei = class {
+        constructor(t = [], r) {
+            h(this, "features");
+            h(this, "disabledFeatures");
+            this.features = new Set(t), this.disabledFeatures = r || {}
         }*[Symbol.iterator]() {
             yield* this.features
         }
-        has(e) {
-            return !this.disabledFeatures[e] && this.features.has(e)
+        has(t) {
+            return !this.disabledFeatures[t] && this.features.has(t)
         }
     },
     Gs = class Gs {
-        constructor(e) {
-            f(this, "id");
-            f(this, "props");
-            f(this, "userData", {});
-            f(this, "statsManager", Zr);
-            f(this, "_lumaData", {});
-            f(this, "timestamp", 0);
+        constructor(t) {
+            h(this, "id");
+            h(this, "props");
+            h(this, "userData", {});
+            h(this, "statsManager", Zr);
+            h(this, "_lumaData", {});
+            h(this, "timestamp", 0);
             this.props = {
                 ...Gs.defaultProps,
-                ...e
-            }, this.id = this.props.id || Ee(this[Symbol.toStringTag].toLowerCase())
+                ...t
+            }, this.id = this.props.id || wt(this[Symbol.toStringTag].toLowerCase())
         }
         get[Symbol.toStringTag]() {
             return "Device"
         }
-        isTextureFormatCompressed(e) {
-            return Ju(e)
+        isTextureFormatCompressed(t) {
+            return Gu(t)
         }
         loseDevice() {
             return !1
         }
         getCanvasContext() {
             if (!this.canvasContext) throw new Error("Device has no CanvasContext");
             return this.canvasContext
         }
-        createTexture(e) {
-            return (e instanceof Promise || typeof e == "string") && (e = {
-                data: e
-            }), this._createTexture(e)
+        createTexture(t) {
+            return (t instanceof Promise || typeof t == "string") && (t = {
+                data: t
+            }), this._createTexture(t)
         }
-        createCommandEncoder(e = {}) {
+        createCommandEncoder(t = {}) {
             throw new Error("not implemented")
         }
-        readPixelsToArrayWebGL(e, r) {
+        readPixelsToArrayWebGL(t, r) {
             throw new Error("not implemented")
         }
-        readPixelsToBufferWebGL(e, r) {
+        readPixelsToBufferWebGL(t, r) {
             throw new Error("not implemented")
         }
-        setParametersWebGL(e) {
+        setParametersWebGL(t) {
             throw new Error("not implemented")
         }
-        getParametersWebGL(e) {
+        getParametersWebGL(t) {
             throw new Error("not implemented")
         }
-        withParametersWebGL(e, r) {
+        withParametersWebGL(t, r) {
             throw new Error("not implemented")
         }
-        clearWebGL(e) {
+        clearWebGL(t) {
             throw new Error("not implemented")
         }
         resetWebGL() {
             throw new Error("not implemented")
         }
         incrementTimestamp() {
             return this.timestamp++
         }
-        onError(e) {
-            this.props.onError(e)
+        onError(t) {
+            this.props.onError(t)
         }
-        _getBufferProps(e) {
-            (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = {
-                data: e
+        _getBufferProps(t) {
+            (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) && (t = {
+                data: t
             });
             let r = {
-                ...e
+                ...t
             };
-            return (e.usage || 0) & K.INDEX && !e.indexType && (e.data instanceof Uint32Array ? r.indexType = "uint32" : e.data instanceof Uint16Array ? r.indexType = "uint16" : P.warn("indices buffer content must be of integer type")()), r
+            return (t.usage || 0) & K.INDEX && !t.indexType && (t.data instanceof Uint32Array ? r.indexType = "uint32" : t.data instanceof Uint16Array ? r.indexType = "uint16" : P.warn("indices buffer content must be of integer type")()), r
         }
     };
-f(Gs, "defaultProps", {
+h(Gs, "defaultProps", {
     id: null,
     canvas: null,
     container: null,
     manageState: !0,
     width: 800,
     height: 600,
     requestMaxLimits: !0,
@@ -4137,267 +4137,267 @@
     spector: !!P.get("spector"),
     break: [],
     initalizeFeatures: !0,
     disabledFeatures: {
         "compilation-status-async-webgl": !0
     },
     gl: null,
-    onError: e => P.error(e.message)
-}), f(Gs, "VERSION", Zu);
-var ot = Gs;
+    onError: t => P.error(t.message)
+}), h(Gs, "VERSION", Qu);
+var oe = Gs;
 
-function z(t, e) {
-    if (!t) throw new Error(e || "luma.gl: assertion failed.")
+function z(e, t) {
+    if (!e) throw new Error(t || "luma.gl: assertion failed.")
 }
 var ri = new Map,
-    ke = class {
-        static registerDevices(e) {
-            for (let r of e) z(r.type && r.isSupported && r.create), ri.set(r.type, r)
+    Dt = class {
+        static registerDevices(t) {
+            for (let r of t) z(r.type && r.isSupported && r.create), ri.set(r.type, r)
         }
         static getAvailableDevices() {
-            return Array.from(ri).map(e => e.type)
+            return Array.from(ri).map(t => t.type)
         }
         static getSupportedDevices() {
-            return Array.from(ri).filter(e => e.isSupported()).map(e => e.type)
+            return Array.from(ri).filter(t => t.isSupported()).map(t => t.type)
         }
-        static setDefaultDeviceProps(e) {
-            Object.assign(ot.defaultProps, e)
+        static setDefaultDeviceProps(t) {
+            Object.assign(oe.defaultProps, t)
         }
-        static async attachDevice(e) {
-            let r = Gu(e.devices) || ri;
-            if (e.handle instanceof WebGL2RenderingContext) {
+        static async attachDevice(t) {
+            let r = td(t.devices) || ri;
+            if (t.handle instanceof WebGL2RenderingContext) {
                 let s = r.get("webgl");
-                if (s) return await s.attach(e.handle)
+                if (s) return await s.attach(t.handle)
             }
-            if (e.handle === null) {
+            if (t.handle === null) {
                 let s = r.get("unknown");
                 if (s) return await s.attach(null)
             }
             throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.")
         }
-        static async createDevice(e = {}) {
-            e = {
-                ...ot.defaultProps,
-                ...e
-            }, e.gl && (e.type = "webgl");
-            let r = Gu(e.devices) || ri;
-            switch (e.type) {
+        static async createDevice(t = {}) {
+            t = {
+                ...oe.defaultProps,
+                ...t
+            }, t.gl && (t.type = "webgl");
+            let r = td(t.devices) || ri;
+            switch (t.type) {
                 case "webgpu":
                     let s = r.get("webgpu");
-                    if (s) return await s.create(e);
+                    if (s) return await s.create(t);
                     break;
                 case "webgl":
                     let i = r.get("webgl");
-                    if (i) return await i.create(e);
+                    if (i) return await i.create(t);
                     break;
                 case "unknown":
                     let n = r.get("unknown");
-                    if (n) return await n.create(e);
+                    if (n) return await n.create(t);
                     break;
                 case "best-available":
-                    if (s = r.get("webgpu"), s?.isSupported?.()) return await s.create(e);
-                    if (i = r.get("webgl"), i?.isSupported?.()) return await i.create(e);
+                    if (s = r.get("webgpu"), s?.isSupported?.()) return await s.create(t);
+                    if (i = r.get("webgl"), i?.isSupported?.()) return await i.create(t);
                     break
             }
             throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.")
         }
     };
-f(ke, "defaultProps", {
-    ...ot.defaultProps,
+h(Dt, "defaultProps", {
+    ...oe.defaultProps,
     type: "best-available",
     devices: void 0
-}), f(ke, "stats", Zr), f(ke, "log", P);
+}), h(Dt, "stats", Zr), h(Dt, "log", P);
 
-function Gu(t) {
-    if (!t || t?.length === 0) return null;
-    let e = new Map;
-    for (let r of t) e.set(r.type, r);
-    return e
+function td(e) {
+    if (!e || e?.length === 0) return null;
+    let t = new Map;
+    for (let r of e) t.set(r.type, r);
+    return t
 }
-var GT = pe() && typeof document < "u",
-    jn = () => GT && document.readyState === "complete",
-    ey = {
+var ey = pt() && typeof document < "u",
+    Hn = () => ey && document.readyState === "complete",
+    ry = {
         canvas: null,
         width: 800,
         height: 600,
         useDevicePixels: !0,
         autoResize: !0,
         container: null,
         visible: !0,
         colorSpace: "srgb",
         alphaMode: "opaque"
     },
-    Wt = class {
-        constructor(e) {
-            f(this, "id");
-            f(this, "props");
-            f(this, "canvas");
-            f(this, "htmlCanvas");
-            f(this, "offscreenCanvas");
-            f(this, "type");
-            f(this, "width", 1);
-            f(this, "height", 1);
-            f(this, "resizeObserver");
-            f(this, "_canvasSizeInfo", {
+    We = class {
+        constructor(t) {
+            h(this, "id");
+            h(this, "props");
+            h(this, "canvas");
+            h(this, "htmlCanvas");
+            h(this, "offscreenCanvas");
+            h(this, "type");
+            h(this, "width", 1);
+            h(this, "height", 1);
+            h(this, "resizeObserver");
+            h(this, "_canvasSizeInfo", {
                 clientWidth: 0,
                 clientHeight: 0,
                 devicePixelRatio: 1
             });
             if (this.props = {
-                    ...ey,
-                    ...e
-                }, e = this.props, !pe()) {
+                    ...ry,
+                    ...t
+                }, t = this.props, !pt()) {
                 this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
                 return
             }
-            if (e.canvas) typeof e.canvas == "string" ? this.canvas = sy(e.canvas) : this.canvas = e.canvas;
+            if (t.canvas) typeof t.canvas == "string" ? this.canvas = ny(t.canvas) : this.canvas = t.canvas;
             else {
-                let r = iy(e),
-                    s = ry(e?.container || null);
-                s.insertBefore(r, s.firstChild), this.canvas = r, e?.visible || (this.canvas.style.visibility = "hidden")
+                let r = oy(t),
+                    s = iy(t?.container || null);
+                s.insertBefore(r, s.firstChild), this.canvas = r, t?.visible || (this.canvas.style.visibility = "hidden")
             }
-            this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver(r => {
+            this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && t.autoResize && (this.resizeObserver = new ResizeObserver(r => {
                 for (let s of r) s.target === this.canvas && this.update()
             }), this.resizeObserver.observe(this.canvas))
         }
         static get isPageLoaded() {
-            return jn()
+            return Hn()
         }
-        getDevicePixelRatio(e) {
-            return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e
+        getDevicePixelRatio(t) {
+            return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (t = t === void 0 ? this.props.useDevicePixels : t, !t || t <= 0) ? 1 : t === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : t
         }
         getPixelSize() {
             switch (this.type) {
                 case "node":
                     return [this.width, this.height];
                 case "offscreen-canvas":
                     return [this.canvas.width, this.canvas.height];
                 case "html-canvas":
-                    let e = this.getDevicePixelRatio(),
+                    let t = this.getDevicePixelRatio(),
                         r = this.canvas;
-                    return r.parentElement ? [r.clientWidth * e, r.clientHeight * e] : [this.canvas.width, this.canvas.height];
+                    return r.parentElement ? [r.clientWidth * t, r.clientHeight * t] : [this.canvas.width, this.canvas.height];
                 default:
                     throw new Error(this.type)
             }
         }
         getAspect() {
-            let [e, r] = this.getPixelSize();
-            return e / r
+            let [t, r] = this.getPixelSize();
+            return t / r
         }
         cssToDeviceRatio() {
             try {
-                let [e] = this.getDrawingBufferSize(), {
+                let [t] = this.getDrawingBufferSize(), {
                     clientWidth: r
                 } = this._canvasSizeInfo;
-                return r ? e / r : 1
+                return r ? t / r : 1
             } catch {
                 return 1
             }
         }
-        cssToDevicePixels(e, r = !0) {
+        cssToDevicePixels(t, r = !0) {
             let s = this.cssToDeviceRatio(),
                 [i, n] = this.getDrawingBufferSize();
-            return ny(e, s, i, n, r)
+            return ay(t, s, i, n, r)
         }
-        setDevicePixelRatio(e, r = {}) {
+        setDevicePixelRatio(t, r = {}) {
             if (!this.htmlCanvas) return;
             let s = "width" in r ? r.width : this.htmlCanvas.clientWidth,
                 i = "height" in r ? r.height : this.htmlCanvas.clientHeight;
-            (!s || !i) && (P.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, s = this.htmlCanvas.width || 1, i = this.htmlCanvas.height || 1);
+            (!s || !i) && (P.log(1, "Canvas clientWidth/clientHeight is 0")(), t = 1, s = this.htmlCanvas.width || 1, i = this.htmlCanvas.height || 1);
             let n = this._canvasSizeInfo;
-            if (n.clientWidth !== s || n.clientHeight !== i || n.devicePixelRatio !== e) {
-                let o = e,
+            if (n.clientWidth !== s || n.clientHeight !== i || n.devicePixelRatio !== t) {
+                let o = t,
                     a = Math.floor(s * o),
                     c = Math.floor(i * o);
                 this.htmlCanvas.width = a, this.htmlCanvas.height = c;
-                let [l, h] = this.getDrawingBufferSize();
-                (l !== a || h !== c) && (o = Math.min(l / s, h / i), this.htmlCanvas.width = Math.floor(s * o), this.htmlCanvas.height = Math.floor(i * o), P.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = s, this._canvasSizeInfo.clientHeight = i, this._canvasSizeInfo.devicePixelRatio = e
+                let [l, f] = this.getDrawingBufferSize();
+                (l !== a || f !== c) && (o = Math.min(l / s, f / i), this.htmlCanvas.width = Math.floor(s * o), this.htmlCanvas.height = Math.floor(i * o), P.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = s, this._canvasSizeInfo.clientHeight = i, this._canvasSizeInfo.devicePixelRatio = t
             }
         }
         getDrawingBufferSize() {
-            let e = this.device.gl;
-            if (!e) throw new Error("canvas size");
-            return [e.drawingBufferWidth, e.drawingBufferHeight]
+            let t = this.device.gl;
+            if (!t) throw new Error("canvas size");
+            return [t.drawingBufferWidth, t.drawingBufferHeight]
         }
-        _setAutoCreatedCanvasId(e) {
-            this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e)
+        _setAutoCreatedCanvasId(t) {
+            this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = t)
         }
     };
-f(Wt, "pageLoaded", ty());
+h(We, "pageLoaded", sy());
 
-function ty() {
-    return jn() || typeof window > "u" ? Promise.resolve() : new Promise(t => {
-        window.addEventListener("load", () => t())
+function sy() {
+    return Hn() || typeof window > "u" ? Promise.resolve() : new Promise(e => {
+        window.addEventListener("load", () => e())
     })
 }
 
-function ry(t) {
-    if (typeof t == "string") {
-        let e = document.getElementById(t);
-        if (!e && !jn()) throw new Error(`Accessing '${t}' before page was loaded`);
-        if (!e) throw new Error(`${t} is not an HTML element`);
-        return e
-    } else if (t) return t;
+function iy(e) {
+    if (typeof e == "string") {
+        let t = document.getElementById(e);
+        if (!t && !Hn()) throw new Error(`Accessing '${e}' before page was loaded`);
+        if (!t) throw new Error(`${e} is not an HTML element`);
+        return t
+    } else if (e) return e;
     return document.body
 }
 
-function sy(t) {
-    let e = document.getElementById(t);
-    if (!e && !jn()) throw new Error(`Accessing '${t}' before page was loaded`);
-    if (!(e instanceof HTMLCanvasElement)) throw new Error("Object is not a canvas element");
-    return e
+function ny(e) {
+    let t = document.getElementById(e);
+    if (!t && !Hn()) throw new Error(`Accessing '${e}' before page was loaded`);
+    if (!(t instanceof HTMLCanvasElement)) throw new Error("Object is not a canvas element");
+    return t
 }
 
-function iy(t) {
+function oy(e) {
     let {
-        width: e,
+        width: t,
         height: r
-    } = t, s = document.createElement("canvas");
-    return s.id = "lumagl-auto-created-canvas", s.width = e || 1, s.height = r || 1, s.style.width = Number.isFinite(e) ? `${e}px` : "100%", s.style.height = Number.isFinite(r) ? `${r}px` : "100%", s
+    } = e, s = document.createElement("canvas");
+    return s.id = "lumagl-auto-created-canvas", s.width = t || 1, s.height = r || 1, s.style.width = Number.isFinite(t) ? `${t}px` : "100%", s.style.height = Number.isFinite(r) ? `${r}px` : "100%", s
 }
 
-function ny(t, e, r, s, i) {
-    let n = t,
-        o = ed(n[0], e, r),
-        a = td(n[1], e, s, i),
-        c = ed(n[0] + 1, e, r),
+function ay(e, t, r, s, i) {
+    let n = e,
+        o = ed(n[0], t, r),
+        a = rd(n[1], t, s, i),
+        c = ed(n[0] + 1, t, r),
         l = c === r - 1 ? c : c - 1;
-    c = td(n[1] + 1, e, s, i);
-    let h;
-    return i ? (c = c === 0 ? c : c + 1, h = a, a = c) : h = c === s - 1 ? c : c - 1, {
+    c = rd(n[1] + 1, t, s, i);
+    let f;
+    return i ? (c = c === 0 ? c : c + 1, f = a, a = c) : f = c === s - 1 ? c : c - 1, {
         x: o,
         y: a,
         width: Math.max(l - o + 1, 1),
-        height: Math.max(h - a + 1, 1)
+        height: Math.max(f - a + 1, 1)
     }
 }
 
-function ed(t, e, r) {
-    return Math.min(Math.round(t * e), r - 1)
+function ed(e, t, r) {
+    return Math.min(Math.round(e * t), r - 1)
 }
 
-function td(t, e, r, s) {
-    return s ? Math.max(0, r - 1 - Math.round(t * e)) : Math.min(Math.round(t * e), r - 1)
+function rd(e, t, r, s) {
+    return s ? Math.max(0, r - 1 - Math.round(e * t)) : Math.min(Math.round(e * t), r - 1)
 }
-var bt = class bt extends V {
-    constructor(r, s, i = bt.defaultProps) {
+var Te = class Te extends V {
+    constructor(r, s, i = Te.defaultProps) {
         super(r, s, i);
-        f(this, "dimension");
-        f(this, "format");
-        f(this, "width");
-        f(this, "height");
-        f(this, "depth");
-        f(this, "updateTimestamp");
+        h(this, "dimension");
+        h(this, "format");
+        h(this, "width");
+        h(this, "height");
+        h(this, "depth");
+        h(this, "updateTimestamp");
         this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.updateTimestamp = r.incrementTimestamp()
     }
     get[Symbol.toStringTag]() {
         return "Texture"
     }
 };
-f(bt, "defaultProps", {
+h(Te, "defaultProps", {
     ...V.defaultProps,
     data: null,
     dimension: "2d",
     format: "rgba8unorm",
     width: void 0,
     height: void 0,
     depth: 1,
@@ -4405,130 +4405,130 @@
     compressed: !1,
     usage: 0,
     mipLevels: void 0,
     samples: void 0,
     type: void 0,
     sampler: {},
     view: void 0
-}), f(bt, "COPY_SRC", 1), f(bt, "COPY_DST", 2), f(bt, "TEXTURE_BINDING", 4), f(bt, "STORAGE_BINDING", 8), f(bt, "RENDER_ATTACHMENT", 16);
-var se = bt;
+}), h(Te, "COPY_SRC", 1), h(Te, "COPY_DST", 2), h(Te, "TEXTURE_BINDING", 4), h(Te, "STORAGE_BINDING", 8), h(Te, "RENDER_ATTACHMENT", 16);
+var st = Te;
 var Xn = class Xn extends V {
     get[Symbol.toStringTag]() {
         return "TextureView"
     }
-    constructor(e, r) {
-        super(e, r, Xn.defaultProps)
+    constructor(t, r) {
+        super(t, r, Xn.defaultProps)
     }
 };
-f(Xn, "defaultProps", {
+h(Xn, "defaultProps", {
     ...V.defaultProps,
     format: void 0,
     dimension: void 0,
     aspect: "all",
     baseMipLevel: 0,
     mipLevelCount: void 0,
     baseArrayLayer: 0,
     arrayLayerCount: void 0
 });
-var br = Xn;
+var Tr = Xn;
 
-function sd(t, e, r) {
+function id(e, t, r) {
     let s = "",
-        i = e.split(/\r?\n/),
-        n = t.slice().sort((o, a) => o.lineNum - a.lineNum);
+        i = t.split(/\r?\n/),
+        n = e.slice().sort((o, a) => o.lineNum - a.lineNum);
     switch (r?.showSourceCode || "no") {
         case "all":
             let o = 0;
             for (let a = 1; a <= i.length; a++)
-                for (s += id(i[a - 1], a, r); n.length > o && n[o].lineNum === a;) {
+                for (s += nd(i[a - 1], a, r); n.length > o && n[o].lineNum === a;) {
                     let c = n[o++];
-                    s += rd(c, i, c.lineNum, {
+                    s += sd(c, i, c.lineNum, {
                         ...r,
                         inlineSource: !1
                     })
                 }
             return s;
         case "issues":
         case "no":
-            for (let a of t) s += rd(a, i, a.lineNum, {
+            for (let a of e) s += sd(a, i, a.lineNum, {
                 inlineSource: r?.showSourceCode !== "no"
             });
             return s
     }
 }
 
-function rd(t, e, r, s) {
+function sd(e, t, r, s) {
     if (s?.inlineSource) {
-        let i = oy(e, r),
-            n = t.linePos > 0 ? `${" ".repeat(t.linePos+5)}^^^
+        let i = cy(t, r),
+            n = e.linePos > 0 ? `${" ".repeat(e.linePos+5)}^^^
 ` : "";
         return `
-${i}${n}${t.type.toUpperCase()}: ${t.message}
+${i}${n}${e.type.toUpperCase()}: ${e.message}
 
 `
     }
-    return s?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${t.type.toUpperCase()}: ${t.message}</b></div>` : `${t.type.toUpperCase()}: ${t.message}`
+    return s?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${e.type.toUpperCase()}: ${e.message}</b></div>` : `${e.type.toUpperCase()}: ${e.message}`
 }
 
-function oy(t, e, r) {
+function cy(e, t, r) {
     let s = "";
-    for (let i = e - 2; i <= e; i++) {
-        let n = t[i - 1];
-        n !== void 0 && (s += id(n, e, r))
+    for (let i = t - 2; i <= t; i++) {
+        let n = e[i - 1];
+        n !== void 0 && (s += nd(n, t, r))
     }
     return s
 }
 
-function id(t, e, r) {
-    let s = r?.html ? cy(t) : t;
-    return `${ay(String(e),4)}: ${s}${r?.html?"<br/>":`
+function nd(e, t, r) {
+    let s = r?.html ? fy(e) : e;
+    return `${ly(String(t),4)}: ${s}${r?.html?"<br/>":`
 `}`
 }
 
-function ay(t, e) {
+function ly(e, t) {
     let r = "";
-    for (let s = t.length; s < e; ++s) r += " ";
-    return r + t
+    for (let s = e.length; s < t; ++s) r += " ";
+    return r + e
 }
 
-function cy(t) {
-    return t.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;")
+function fy(e) {
+    return e.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;")
 }
 
-function Vc(t, e) {
+function Vc(e, t) {
     return {
-        name: ly(t, e),
+        name: hy(e, t),
         language: "glsl",
-        version: hy(t)
+        version: uy(e)
     }
 }
 
-function ly(t, e = "unnamed") {
-    let s = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(t);
-    return s ? s[1] : e
+function hy(e, t = "unnamed") {
+    let s = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(e);
+    return s ? s[1] : t
 }
 
-function hy(t) {
-    let e = 100,
-        r = t.match(/[^\s]+/g);
+function uy(e) {
+    let t = 100,
+        r = e.match(/[^\s]+/g);
     if (r && r.length >= 2 && r[0] === "#version") {
         let s = parseInt(r[1], 10);
-        Number.isFinite(s) && (e = s)
+        Number.isFinite(s) && (t = s)
     }
-    return e
+    return t
 }
 var $n = class $n extends V {
     constructor(r, s) {
         super(r, {
-            id: fy(s),
+            id: dy(s),
             ...s
         }, $n.defaultProps);
-        f(this, "stage");
-        f(this, "source");
-        f(this, "compilationStatus", "pending");
+        h(this, "stage");
+        h(this, "source");
+        h(this, "compilationStatus", "pending");
         this.stage = this.props.stage, this.source = this.props.source
     }
     get[Symbol.toStringTag]() {
         return "Shader"
     }
     getCompilationInfoSync() {
         return null
@@ -4550,15 +4550,15 @@
         let s = await this.getCompilationInfo();
         this.props.debug === "warnings" && s?.length === 0 || this._displayShaderLog(s)
     }
     _displayShaderLog(r) {
         if (typeof document > "u" || !document?.createElement) return;
         let s = Vc(this.source).name,
             i = `${this.stage} ${s}`,
-            n = sd(r, this.source, {
+            n = id(r, this.source, {
                 showSourceCode: "all",
                 html: !0
             }),
             o = this.getTranslatedSource();
         o && (n += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${o}</pre></code>`);
         let a = document.createElement("Button");
         a.innerHTML = `
@@ -4569,37 +4569,37 @@
         let c = document.getElementsByClassName("luma-compiler-log-error");
         c[0]?.scrollIntoView && c[0].scrollIntoView(), a.onclick = () => {
             let l = `data:text/plain,${encodeURIComponent(this.source)}`;
             navigator.clipboard.writeText(l)
         }
     }
 };
-f($n, "defaultProps", {
+h($n, "defaultProps", {
     ...V.defaultProps,
     language: "auto",
     stage: void 0,
     source: "",
     sourceMap: null,
     entryPoint: "main",
     debug: "errors"
 });
-var Er = $n;
+var wr = $n;
 
-function fy(t) {
-    return Vc(t.source).name || t.id || Ee(`unnamed ${t.stage}-shader`)
+function dy(e) {
+    return Vc(e.source).name || e.id || wt(`unnamed ${e.stage}-shader`)
 }
 var Yn = class Yn extends V {
     get[Symbol.toStringTag]() {
         return "Sampler"
     }
-    constructor(e, r) {
-        super(e, r, Yn.defaultProps)
+    constructor(t, r) {
+        super(t, r, Yn.defaultProps)
     }
 };
-f(Yn, "defaultProps", {
+h(Yn, "defaultProps", {
     ...V.defaultProps,
     type: "color-sampler",
     addressModeU: "clamp-to-edge",
     addressModeV: "clamp-to-edge",
     addressModeW: "clamp-to-edge",
     magFilter: "nearest",
     minFilter: "nearest",
@@ -4609,18 +4609,18 @@
     compare: "less-equal",
     maxAnisotropy: 1
 });
 var Ar = Yn;
 var qn = class qn extends V {
     constructor(r, s = {}) {
         super(r, s, qn.defaultProps);
-        f(this, "width");
-        f(this, "height");
-        f(this, "colorAttachments", []);
-        f(this, "depthStencilAttachment", null);
+        h(this, "width");
+        h(this, "height");
+        h(this, "colorAttachments", []);
+        h(this, "depthStencilAttachment", null);
         this.width = this.props.width, this.height = this.props.height
     }
     get[Symbol.toStringTag]() {
         return "Framebuffer"
     }
     resize(r) {
         let s = !r;
@@ -4633,36 +4633,36 @@
     autoCreateAttachmentTextures() {
         if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) throw new Error("Framebuffer has noattachments");
         this.colorAttachments = this.props.colorAttachments.map(s => {
             if (typeof s == "string") {
                 let i = this.createColorTexture(s);
                 return this.attachResource(i), i.view
             }
-            return s instanceof se ? s.view : s
+            return s instanceof st ? s.view : s
         });
         let r = this.props.depthStencilAttachment;
         if (r)
             if (typeof r == "string") {
                 let s = this.createDepthStencilTexture(r);
                 this.attachResource(s), this.depthStencilAttachment = s.view
-            } else r instanceof se ? this.depthStencilAttachment = r.view : this.depthStencilAttachment = r
+            } else r instanceof st ? this.depthStencilAttachment = r.view : this.depthStencilAttachment = r
     }
     createColorTexture(r) {
         return this.device.createTexture({
             id: "color-attachment",
-            usage: se.RENDER_ATTACHMENT,
+            usage: st.RENDER_ATTACHMENT,
             format: r,
             width: this.width,
             height: this.height
         })
     }
     createDepthStencilTexture(r) {
         return this.device.createTexture({
             id: "depth-stencil-attachment",
-            usage: se.RENDER_ATTACHMENT,
+            usage: st.RENDER_ATTACHMENT,
             format: r,
             width: this.width,
             height: this.height
         })
     }
     resizeAttachments(r, s) {
         for (let i = 0; i < this.colorAttachments.length; ++i)
@@ -4679,39 +4679,39 @@
                 width: r,
                 height: s
             });
             this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = i.view, this.attachResource(i)
         }
     }
 };
-f(qn, "defaultProps", {
+h(qn, "defaultProps", {
     ...V.defaultProps,
     width: 1,
     height: 1,
     colorAttachments: [],
     depthStencilAttachment: null
 });
-var xr = qn;
+var Er = qn;
 var Kn = class Kn extends V {
     constructor(r, s) {
         super(r, s, Kn.defaultProps);
-        f(this, "shaderLayout");
-        f(this, "bufferLayout");
-        f(this, "linkStatus", "pending");
-        f(this, "hash", "");
+        h(this, "shaderLayout");
+        h(this, "bufferLayout");
+        h(this, "linkStatus", "pending");
+        h(this, "hash", "");
         this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || []
     }
     get[Symbol.toStringTag]() {
         return "RenderPipeline"
     }
     setUniformsWebGL(r) {
         throw new Error("Use uniform blocks")
     }
 };
-f(Kn, "defaultProps", {
+h(Kn, "defaultProps", {
     ...V.defaultProps,
     vs: null,
     vertexEntryPoint: "vertexMain",
     vsConstants: {},
     fs: null,
     fragmentEntryPoint: "fragmentMain",
     fsConstants: {},
@@ -4720,24 +4720,24 @@
     topology: "triangle-list",
     parameters: {},
     vertexCount: 0,
     instanceCount: 0,
     bindings: {},
     uniforms: {}
 });
-var at = Kn;
+var ae = Kn;
 var Zn = class Zn extends V {
     get[Symbol.toStringTag]() {
         return "RenderPass"
     }
-    constructor(e, r) {
-        super(e, r, Zn.defaultProps)
+    constructor(t, r) {
+        super(t, r, Zn.defaultProps)
     }
 };
-f(Zn, "defaultProps", {
+h(Zn, "defaultProps", {
     ...V.defaultProps,
     framebuffer: null,
     parameters: void 0,
     clearColor: [0, 0, 0, 0],
     clearDepth: 1,
     clearStencil: 0,
     depthReadOnly: !1,
@@ -4748,84 +4748,84 @@
     beginTimestampIndex: void 0,
     endTimestampIndex: void 0
 });
 var si = Zn;
 var Qn = class Qn extends V {
     constructor(r, s) {
         super(r, s, Qn.defaultProps);
-        f(this, "hash", "")
+        h(this, "hash", "")
     }
     get[Symbol.toStringTag]() {
         return "ComputePipeline"
     }
 };
-f(Qn, "defaultProps", {
+h(Qn, "defaultProps", {
     ...V.defaultProps,
     shader: void 0,
     entryPoint: void 0,
     constants: {},
     shaderLayout: void 0
 });
 var Qr = Qn;
 var Jn = class Jn extends V {
     get[Symbol.toStringTag]() {
         return "CommandEncoder"
     }
-    constructor(e, r) {
-        super(e, r, Jn.defaultProps)
+    constructor(t, r) {
+        super(t, r, Jn.defaultProps)
     }
 };
-f(Jn, "defaultProps", {
+h(Jn, "defaultProps", {
     ...V.defaultProps,
     measureExecutionTime: void 0
 });
 var ii = Jn;
 var Gn = class Gn extends V {
     get[Symbol.toStringTag]() {
         return "CommandBuffer"
     }
-    constructor(e, r) {
-        super(e, r, Gn.defaultProps)
+    constructor(t, r) {
+        super(t, r, Gn.defaultProps)
     }
 };
-f(Gn, "defaultProps", {
+h(Gn, "defaultProps", {
     ...V.defaultProps
 });
 var ni = Gn;
 
-function nd(t) {
-    let [e, r] = dy[t], s = e === "i32" || e === "u32", i = e !== "u32", n = py[e] * r, o = uy(e, r);
+function od(e) {
+    let [t, r] = _y[e], s = t === "i32" || t === "u32", i = t !== "u32", n = gy[t] * r, o = py(t, r);
     return {
-        dataType: e,
+        dataType: t,
         components: r,
         defaultVertexFormat: o,
         byteLength: n,
         integer: s,
         signed: i
     }
 }
 
-function uy(t, e) {
+function py(e, t) {
     let r;
-    switch (t) {
+    switch (e) {
         case "f32":
             r = "float32";
             break;
         case "i32":
             r = "sint32";
             break;
         case "u32":
             r = "uint32";
             break;
         case "f16":
-            return e <= 2 ? "float16x2" : "float16x4"
+            return t <= 2 ? "float16x2" : "float16x4"
     }
-    return e === 1 ? r : `${r}x${e}`
+    return t === 1 ? r : `${r}x${t}`
 }
-var dy = {
+var _y = {
         f32: ["f32", 1],
         "vec2<f32>": ["f32", 2],
         "vec3<f32>": ["f32", 3],
         "vec4<f32>": ["f32", 4],
         f16: ["f16", 1],
         "vec2<f16>": ["f16", 2],
         "vec3<f16>": ["f16", 3],
@@ -4835,53 +4835,53 @@
         "vec3<i32>": ["i32", 3],
         "vec4<i32>": ["i32", 4],
         u32: ["u32", 1],
         "vec2<u32>": ["u32", 2],
         "vec3<u32>": ["u32", 3],
         "vec4<u32>": ["u32", 4]
     },
-    py = {
+    gy = {
         f32: 4,
         f16: 2,
         i32: 4,
         u32: 4
     };
 
-function Wc(t) {
-    let e;
-    t.endsWith("-webgl") && (t.replace("-webgl", ""), e = !0);
-    let [r, s] = t.split("x"), i = r, n = s ? parseInt(s) : 1, o = zn(i), a = {
+function Wc(e) {
+    let t;
+    e.endsWith("-webgl") && (e.replace("-webgl", ""), t = !0);
+    let [r, s] = e.split("x"), i = r, n = s ? parseInt(s) : 1, o = zn(i), a = {
         type: i,
         components: n,
         byteLength: o.byteLength * n,
         integer: o.integer,
         signed: o.signed,
         normalized: o.normalized
     };
-    return e && (a.webglOnly = !0), a
+    return t && (a.webglOnly = !0), a
 }
 
-function eo(t, e) {
+function to(e, t) {
     let r = {};
-    for (let s of t.attributes) r[s.name] = gy(t, e, s.name);
+    for (let s of e.attributes) r[s.name] = my(e, t, s.name);
     return r
 }
 
-function od(t, e, r = 16) {
-    let s = eo(t, e),
+function ad(e, t, r = 16) {
+    let s = to(e, t),
         i = new Array(r).fill(null);
     for (let n of Object.values(s)) i[n.location] = n;
     return i
 }
 
-function gy(t, e, r) {
-    let s = _y(t, r),
-        i = my(e, r);
+function my(e, t, r) {
+    let s = by(e, r),
+        i = yy(t, r);
     if (!s) return null;
-    let n = nd(s.type),
+    let n = od(s.type),
         o = i?.vertexFormat || n.defaultVertexFormat,
         a = Wc(o);
     return {
         attributeName: i?.attributeName || s.name,
         bufferName: i?.bufferName || s.name,
         location: s.location,
         shaderType: s.type,
@@ -4894,120 +4894,120 @@
         integer: n.integer,
         stepMode: i?.stepMode || s.stepMode,
         byteOffset: i?.byteOffset || 0,
         byteStride: i?.byteStride || 0
     }
 }
 
-function _y(t, e) {
-    let r = t.attributes.find(s => s.name === e);
-    return r || P.warn(`shader layout attribute "${e}" not present in shader`), r || null
+function by(e, t) {
+    let r = e.attributes.find(s => s.name === t);
+    return r || P.warn(`shader layout attribute "${t}" not present in shader`), r || null
 }
 
-function my(t, e) {
-    Ty(t);
-    let r = yy(t, e);
-    return r || (r = by(t, e), r) ? r : (P.warn(`layout for attribute "${e}" not present in buffer layout`), null)
+function yy(e, t) {
+    Ty(e);
+    let r = wy(e, t);
+    return r || (r = Ay(e, t), r) ? r : (P.warn(`layout for attribute "${t}" not present in buffer layout`), null)
 }
 
-function Ty(t) {
-    for (let e of t)(e.attributes && e.format || !e.attributes && !e.format) && P.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`)
+function Ty(e) {
+    for (let t of e)(t.attributes && t.format || !t.attributes && !t.format) && P.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`)
 }
 
-function yy(t, e) {
-    for (let r of t)
-        if (r.format && r.name === e) return {
+function wy(e, t) {
+    for (let r of e)
+        if (r.format && r.name === t) return {
             attributeName: r.name,
-            bufferName: e,
+            bufferName: t,
             stepMode: r.stepMode,
             vertexFormat: r.format,
             byteOffset: 0,
             byteStride: r.byteStride || 0
         };
     return null
 }
 
-function by(t, e) {
-    for (let r of t) {
+function Ay(e, t) {
+    for (let r of e) {
         let s = r.byteStride;
         if (typeof r.byteStride != "number")
             for (let n of r.attributes || []) {
                 let o = Wc(n.format);
                 s += o.byteLength
             }
-        let i = r.attributes?.find(n => n.attribute === e);
+        let i = r.attributes?.find(n => n.attribute === t);
         if (i) return {
             attributeName: i.attribute,
             bufferName: r.name,
             stepMode: r.stepMode,
             vertexFormat: i.format,
             byteOffset: i.byteOffset,
             byteStride: s
         }
     }
     return null
 }
 
-function zc(t, e) {
+function zc(e, t) {
     let r = {
-        ...t,
-        attributes: t.attributes.map(s => ({
+        ...e,
+        attributes: e.attributes.map(s => ({
             ...s
         }))
     };
-    for (let s of e?.attributes || []) {
+    for (let s of t?.attributes || []) {
         let i = r.attributes.find(n => n.name === s.name);
         i ? (i.type = s.type || i.type, i.stepMode = s.stepMode || i.stepMode) : P.warn(`shader layout attribute ${s.name} not present in shader`)
     }
     return r
 }
-var to = class to extends V {
+var eo = class eo extends V {
     constructor(r, s) {
-        super(r, s, to.defaultProps);
-        f(this, "maxVertexAttributes");
-        f(this, "attributeInfos");
-        f(this, "indexBuffer", null);
-        f(this, "attributes");
-        this.maxVertexAttributes = r.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = od(s.renderPipeline.shaderLayout, s.renderPipeline.bufferLayout, this.maxVertexAttributes)
+        super(r, s, eo.defaultProps);
+        h(this, "maxVertexAttributes");
+        h(this, "attributeInfos");
+        h(this, "indexBuffer", null);
+        h(this, "attributes");
+        this.maxVertexAttributes = r.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = ad(s.renderPipeline.shaderLayout, s.renderPipeline.bufferLayout, this.maxVertexAttributes)
     }
     get[Symbol.toStringTag]() {
         return "VertexArray"
     }
     setConstantWebGL(r, s) {
         throw new Error("constant attributes not supported")
     }
 };
-f(to, "defaultProps", {
+h(eo, "defaultProps", {
     ...V.defaultProps,
     renderPipeline: null
 });
-var oi = to;
+var oi = eo;
 var ro = class ro extends V {
     get[Symbol.toStringTag]() {
         return "TransformFeedback"
     }
-    constructor(e, r) {
-        super(e, r, ro.defaultProps)
+    constructor(t, r) {
+        super(t, r, ro.defaultProps)
     }
 };
-f(ro, "defaultProps", {
+h(ro, "defaultProps", {
     ...V.defaultProps,
     layout: void 0,
     buffers: {}
 });
 var ai = ro;
 var so = class so extends V {
     get[Symbol.toStringTag]() {
         return "QuerySet"
     }
-    constructor(e, r) {
-        super(e, r, so.defaultProps)
+    constructor(t, r) {
+        super(t, r, so.defaultProps)
     }
 };
-f(so, "defaultProps", {
+h(so, "defaultProps", {
     ...V.defaultProps,
     type: void 0,
     count: void 0
 });
 var ci = so;
 var Ey = {
     f32: {
@@ -5092,240 +5092,240 @@
     },
     "mat4x4<f32>": {
         type: "f32",
         components: 16
     }
 };
 
-function ad(t) {
-    let e = Ey[t];
-    return z(t), e
+function cd(e) {
+    let t = Ey[e];
+    return z(e), t
 }
 
-function cd(t, e) {
-    switch (e) {
+function ld(e, t) {
+    switch (t) {
         case 1:
-            return t;
+            return e;
         case 2:
-            return t + t % 2;
+            return e + e % 2;
         default:
-            return t + (4 - t % 4) % 4
+            return e + (4 - e % 4) % 4
     }
 }
 var io;
 
-function no(t) {
-    return (!io || io.byteLength < t) && (io = new ArrayBuffer(t)), io
+function no(e) {
+    return (!io || io.byteLength < e) && (io = new ArrayBuffer(e)), io
 }
 
-function Hc(t, e) {
-    let r = no(t.BYTES_PER_ELEMENT * e);
-    return new t(r, 0, e)
+function jc(e, t) {
+    let r = no(e.BYTES_PER_ELEMENT * t);
+    return new e(r, 0, t)
 }
 
-function jc(t) {
+function Hc(e) {
     let {
-        target: e,
+        target: t,
         source: r,
         start: s = 0,
         count: i = 1
-    } = t, n = r.length, o = i * n, a = 0;
-    for (let c = s; a < n; a++) e[c++] = r[a];
-    for (; a < o;) a < o - a ? (e.copyWithin(s + a, s, s + a), a *= 2) : (e.copyWithin(s + a, s, s + o - a), a = o);
-    return t.target
+    } = e, n = r.length, o = i * n, a = 0;
+    for (let c = s; a < n; a++) t[c++] = r[a];
+    for (; a < o;) a < o - a ? (t.copyWithin(s + a, s, s + a), a *= 2) : (t.copyWithin(s + a, s, s + o - a), a = o);
+    return e.target
 }
-var ld = 1024,
+var fd = 1024,
     oo = class {
-        constructor(e) {
-            f(this, "layout", {});
-            f(this, "byteLength");
+        constructor(t) {
+            h(this, "layout", {});
+            h(this, "byteLength");
             let r = 0;
-            for (let [i, n] of Object.entries(e)) {
-                let o = ad(n),
+            for (let [i, n] of Object.entries(t)) {
+                let o = cd(n),
                     {
                         type: a,
                         components: c
                     } = o;
-                r = cd(r, c);
+                r = ld(r, c);
                 let l = r;
                 r += c, this.layout[i] = {
                     type: a,
                     size: c,
                     offset: l
                 }
             }
             r += (4 - r % 4) % 4;
             let s = r * 4;
-            this.byteLength = Math.max(s, ld)
+            this.byteLength = Math.max(s, fd)
         }
-        getData(e) {
-            let r = Math.max(this.byteLength, ld),
+        getData(t) {
+            let r = Math.max(this.byteLength, fd),
                 s = no(r),
                 i = {
                     i32: new Int32Array(s),
                     u32: new Uint32Array(s),
                     f32: new Float32Array(s),
                     f16: new Uint16Array(s)
                 };
-            for (let [n, o] of Object.entries(e)) {
+            for (let [n, o] of Object.entries(t)) {
                 let a = this.layout[n];
                 if (!a) {
                     P.warn(`Supplied uniform value ${n} not present in uniform block layout`)();
                     continue
                 }
                 let {
                     type: c,
                     size: l,
-                    offset: h
+                    offset: f
                 } = a, d = i[c];
                 if (l === 1) {
                     if (typeof o != "number" && typeof o != "boolean") {
                         P.warn(`Supplied value for single component uniform ${n} is not a number: ${o}`)();
                         continue
                     }
-                    d[h] = Number(o)
+                    d[f] = Number(o)
                 } else {
-                    let p = Lt(o);
+                    let p = Le(o);
                     if (!p) {
                         P.warn(`Supplied value for multi component / array uniform ${n} is not a numeric array: ${o}`)();
                         continue
                     }
-                    d.set(p, h)
+                    d.set(p, f)
                 }
             }
             return new Uint8Array(s)
         }
-        has(e) {
-            return !!this.layout[e]
+        has(t) {
+            return !!this.layout[t]
         }
-        get(e) {
-            return this.layout[e]
+        get(t) {
+            return this.layout[t]
         }
     };
 
-function hd(t, e, r = 16) {
-    if (t !== e) return !1;
-    let s = Lt(t);
+function hd(e, t, r = 16) {
+    if (e !== t) return !1;
+    let s = Le(e);
     if (!s) return !1;
-    let i = Lt(e);
+    let i = Le(t);
     if (i && s.length === i.length) {
         for (let n = 0; n < s.length; ++n)
             if (i[n] !== s[n]) return !1
     }
     return !0
 }
 
-function fd(t) {
-    let e = Lt(t);
-    return e ? e.slice() : t
+function ud(e) {
+    let t = Le(e);
+    return t ? t.slice() : e
 }
 var ao = class {
-    constructor(e) {
-        f(this, "name");
-        f(this, "uniforms", {});
-        f(this, "modifiedUniforms", {});
-        f(this, "modified", !0);
-        f(this, "bindingLayout", {});
-        f(this, "needsRedraw", "initialized");
-        if (this.name = e?.name, e?.name && e?.shaderLayout) {
-            let r = e?.shaderLayout.bindings?.find(i => i.type === "uniform" && i.name === e?.name);
-            if (!r) throw new Error(e?.name);
+    constructor(t) {
+        h(this, "name");
+        h(this, "uniforms", {});
+        h(this, "modifiedUniforms", {});
+        h(this, "modified", !0);
+        h(this, "bindingLayout", {});
+        h(this, "needsRedraw", "initialized");
+        if (this.name = t?.name, t?.name && t?.shaderLayout) {
+            let r = t?.shaderLayout.bindings?.find(i => i.type === "uniform" && i.name === t?.name);
+            if (!r) throw new Error(t?.name);
             let s = r;
             for (let i of s.uniforms || []) this.bindingLayout[i.name] = i
         }
     }
-    setUniforms(e) {
-        for (let [r, s] of Object.entries(e)) this._setUniform(r, s), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${r}=${s}`)
+    setUniforms(t) {
+        for (let [r, s] of Object.entries(t)) this._setUniform(r, s), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${r}=${s}`)
     }
-    setNeedsRedraw(e) {
-        this.needsRedraw = this.needsRedraw || e
+    setNeedsRedraw(t) {
+        this.needsRedraw = this.needsRedraw || t
     }
     getAllUniforms() {
         return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {}
     }
-    _setUniform(e, r) {
-        hd(this.uniforms[e], r) || (this.uniforms[e] = fd(r), this.modifiedUniforms[e] = !0, this.modified = !0)
+    _setUniform(t, r) {
+        hd(this.uniforms[t], r) || (this.uniforms[t] = ud(r), this.modifiedUniforms[t] = !0, this.modified = !0)
     }
 };
 var li = class {
-    constructor(e) {
-        f(this, "uniformBlocks", new Map);
-        f(this, "uniformBufferLayouts", new Map);
-        f(this, "uniformBuffers", new Map);
-        for (let [r, s] of Object.entries(e)) {
+    constructor(t) {
+        h(this, "uniformBlocks", new Map);
+        h(this, "uniformBufferLayouts", new Map);
+        h(this, "uniformBuffers", new Map);
+        for (let [r, s] of Object.entries(t)) {
             let i = r,
                 n = new oo(s.uniformTypes || {});
             this.uniformBufferLayouts.set(i, n);
             let o = new ao({
                 name: r
             });
             o.setUniforms(s.defaultUniforms || {}), this.uniformBlocks.set(i, o)
         }
     }
     destroy() {
-        for (let e of this.uniformBuffers.values()) e.destroy()
+        for (let t of this.uniformBuffers.values()) t.destroy()
     }
-    setUniforms(e) {
-        for (let [r, s] of Object.entries(e)) this.uniformBlocks.get(r).setUniforms(s);
+    setUniforms(t) {
+        for (let [r, s] of Object.entries(t)) this.uniformBlocks.get(r).setUniforms(s);
         this.updateUniformBuffers()
     }
-    getUniformBufferByteLength(e) {
-        return this.uniformBufferLayouts.get(e).byteLength
+    getUniformBufferByteLength(t) {
+        return this.uniformBufferLayouts.get(t).byteLength
     }
-    getUniformBufferData(e) {
-        let r = this.uniformBlocks.get(e).getAllUniforms();
-        return this.uniformBufferLayouts.get(e).getData(r)
+    getUniformBufferData(t) {
+        let r = this.uniformBlocks.get(t).getAllUniforms();
+        return this.uniformBufferLayouts.get(t).getData(r)
     }
-    createUniformBuffer(e, r, s) {
+    createUniformBuffer(t, r, s) {
         s && this.setUniforms(s);
         let i = this.getUniformBufferByteLength(r),
-            n = e.createBuffer({
+            n = t.createBuffer({
                 usage: K.UNIFORM | K.COPY_DST,
                 byteLength: i
             }),
             o = this.getUniformBufferData(r);
         return n.write(o), n
     }
-    getManagedUniformBuffer(e, r) {
+    getManagedUniformBuffer(t, r) {
         if (!this.uniformBuffers.get(r)) {
             let s = this.getUniformBufferByteLength(r),
-                i = e.createBuffer({
+                i = t.createBuffer({
                     usage: K.UNIFORM | K.COPY_DST,
                     byteLength: s
                 });
             this.uniformBuffers.set(r, i)
         }
         return this.uniformBuffers.get(r)
     }
     updateUniformBuffers() {
-        let e = !1;
+        let t = !1;
         for (let r of this.uniformBlocks.keys()) {
             let s = this.updateUniformBuffer(r);
-            e || (e = s)
+            t || (t = s)
         }
-        return e && P.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e
+        return t && P.log(3, `UniformStore.updateUniformBuffers(): ${t}`)(), t
     }
-    updateUniformBuffer(e) {
-        let r = this.uniformBlocks.get(e),
-            s = this.uniformBuffers.get(e),
+    updateUniformBuffer(t) {
+        let r = this.uniformBlocks.get(t),
+            s = this.uniformBuffers.get(t),
             i = !1;
         if (s && r.needsRedraw) {
             i || (i = r.needsRedraw);
-            let n = this.getUniformBufferData(e);
-            this.uniformBuffers.get(e).write(n);
-            let a = this.uniformBlocks.get(e).getAllUniforms();
-            P.log(4, `Writing to uniform buffer ${String(e)}`, n, a)()
+            let n = this.getUniformBufferData(t);
+            this.uniformBuffers.get(t).write(n);
+            let a = this.uniformBlocks.get(t).getAllUniforms();
+            P.log(4, `Writing to uniform buffer ${String(t)}`, n, a)()
         }
         return i
     }
 };
 
-function co(t) {
-    let e = ArrayBuffer.isView(t) ? t.constructor : t;
-    switch (e) {
+function co(e) {
+    let t = ArrayBuffer.isView(e) ? e.constructor : e;
+    switch (t) {
         case Float32Array:
             return "float32";
         case Uint16Array:
             return "uint16";
         case Uint32Array:
             return "uint32";
         case Uint8Array:
@@ -5334,20 +5334,20 @@
         case Int8Array:
             return "sint8";
         case Int16Array:
             return "sint16";
         case Int32Array:
             return "sint32";
         default:
-            throw new Error(e.constructor.name)
+            throw new Error(t.constructor.name)
     }
 }
 
-function hi(t) {
-    switch (t) {
+function fi(e) {
+    switch (e) {
         case "float32":
             return Float32Array;
         case "uint32":
             return Uint32Array;
         case "sint32":
             return Int32Array;
         case "uint16":
@@ -5359,1698 +5359,1698 @@
         case "uint8":
         case "unorm8":
             return Uint8Array;
         case "sint8":
         case "snorm8":
             return Int8Array;
         default:
-            throw new Error(t)
+            throw new Error(e)
     }
 }
 
-function Xc(t, e, r) {
-    if (!e || e > 4) throw new Error(`size ${e}`);
-    let s = e,
-        i = co(t);
+function Xc(e, t, r) {
+    if (!t || t > 4) throw new Error(`size ${t}`);
+    let s = t,
+        i = co(e);
     if (i === "uint8" || i === "sint8") {
-        if (s === 1 || s === 3) throw new Error(`size: ${e}`);
+        if (s === 1 || s === 3) throw new Error(`size: ${t}`);
         return r && (i = i.replace("int", "norm")), `${i}x${s}`
     }
     if (i === "uint16" || i === "sint16") {
-        if (s === 1 || s === 3) throw new Error(`size: ${e}`);
+        if (s === 1 || s === 3) throw new Error(`size: ${t}`);
         return r && (i = i.replace("int", "norm")), `${i}x${s}`
     }
     return s === 1 ? i : `${i}x${s}`
 }
 
-function ud(t) {
-    return Lt(t) !== null || typeof t == "number" || typeof t == "boolean"
+function dd(e) {
+    return Le(e) !== null || typeof e == "number" || typeof e == "boolean"
 }
 
-function fi(t) {
-    let e = {
+function hi(e) {
+    let t = {
         bindings: {},
         uniforms: {}
     };
-    return Object.keys(t).forEach(r => {
-        let s = t[r];
-        ud(s) ? e.uniforms[r] = s : e.bindings[r] = s
-    }), e
+    return Object.keys(e).forEach(r => {
+        let s = e[r];
+        dd(s) ? t.uniforms[r] = s : t.bindings[r] = s
+    }), t
 }
 
-function $c(t, e, r) {
+function $c(e, t, r) {
     let {
         removedProps: s = {},
         deprecatedProps: i = {},
         replacedProps: n = {}
     } = r;
     for (let a in s)
-        if (a in e) {
-            let l = s[a] ? `${t}.${s[a]}` : "N/A";
-            P.removed(`${t}.${a}`, l)()
+        if (a in t) {
+            let l = s[a] ? `${e}.${s[a]}` : "N/A";
+            P.removed(`${e}.${a}`, l)()
         } for (let a in i)
-        if (a in e) {
+        if (a in t) {
             let c = i[a];
-            P.deprecated(`${t}.${a}`, `${t}.${c}`)()
+            P.deprecated(`${e}.${a}`, `${e}.${c}`)()
         } let o = null;
-    for (let [a, c] of Object.entries(n)) a in e && (P.deprecated(`${t}.${a}`, `${t}.${c}`)(), o = o || Object.assign({}, e), o[c] = e[a], delete o[a]);
-    return o || e
+    for (let [a, c] of Object.entries(n)) a in t && (P.deprecated(`${e}.${a}`, `${e}.${c}`)(), o = o || Object.assign({}, t), o[c] = t[a], delete o[a]);
+    return o || t
 }
-var Ay = "";
-async function Yc(t, e) {
+var xy = "";
+async function Yc(e, t) {
     return await new Promise((r, s) => {
         try {
             let i = new Image;
-            i.onload = () => r(i), i.onerror = () => s(new Error(`Could not load image ${t}.`)), i.crossOrigin = e?.crossOrigin || "anonymous", i.src = t.startsWith("http") ? t : Ay + t
+            i.onload = () => r(i), i.onerror = () => s(new Error(`Could not load image ${e}.`)), i.crossOrigin = t?.crossOrigin || "anonymous", i.src = e.startsWith("http") ? e : xy + e
         } catch (i) {
             s(i)
         }
     })
 }
-async function ui(t, e) {
+async function ui(e, t) {
     let r = document.getElementsByTagName("head")[0];
     if (!r) throw new Error("loadScript");
     let s = document.createElement("script");
-    return s.setAttribute("type", "text/javascript"), s.setAttribute("src", t), e && (s.id = e), new Promise((i, n) => {
-        s.onload = i, s.onerror = o => n(new Error(`Unable to load script '${t}': ${o}`)), r.appendChild(s)
+    return s.setAttribute("type", "text/javascript"), s.setAttribute("src", e), t && (s.id = t), new Promise((i, n) => {
+        s.onload = i, s.onerror = o => n(new Error(`Unable to load script '${e}': ${o}`)), r.appendChild(s)
     })
 }
 
-function di(t, e, r) {
-    if (t === e) return !0;
-    if (!r || !t || !e) return !1;
-    if (Array.isArray(t)) {
-        if (!Array.isArray(e) || t.length !== e.length) return !1;
-        for (let s = 0; s < t.length; s++)
-            if (!di(t[s], e[s], r - 1)) return !1;
+function di(e, t, r) {
+    if (e === t) return !0;
+    if (!r || !e || !t) return !1;
+    if (Array.isArray(e)) {
+        if (!Array.isArray(t) || e.length !== t.length) return !1;
+        for (let s = 0; s < e.length; s++)
+            if (!di(e[s], t[s], r - 1)) return !1;
         return !0
     }
-    if (Array.isArray(e)) return !1;
-    if (typeof t == "object" && typeof e == "object") {
-        let s = Object.keys(t),
-            i = Object.keys(e);
+    if (Array.isArray(t)) return !1;
+    if (typeof e == "object" && typeof t == "object") {
+        let s = Object.keys(e),
+            i = Object.keys(t);
         if (s.length !== i.length) return !1;
         for (let n of s)
-            if (!e.hasOwnProperty(n) || !di(t[n], e[n], r - 1)) return !1;
+            if (!t.hasOwnProperty(n) || !di(e[n], t[n], r - 1)) return !1;
         return !0
     }
     return !1
 }
 
-function qc(t) {
-    return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(t) : setTimeout(t, 1e3 / 60)
+function qc(e) {
+    return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(e) : setTimeout(e, 1e3 / 60)
 }
 
-function Kc(t) {
-    return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(t) : clearTimeout(t)
+function Kc(e) {
+    return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(e) : clearTimeout(e)
 }
 var Zc = class {
         constructor() {
             this.constants = new Map, this.aliases = new Map, this.structs = new Map
         }
     },
-    At = class {
+    Ae = class {
         constructor() {}
         get isAstNode() {
             return !0
         }
         get astNodeType() {
             return ""
         }
-        evaluate(e) {
+        evaluate(t) {
             throw new Error("Cannot evaluate node")
         }
-        evaluateString(e) {
-            return this.evaluate(e).toString()
+        evaluateString(t) {
+            return this.evaluate(t).toString()
         }
     },
-    Q = class extends At {
+    Q = class extends Ae {
         constructor() {
             super()
         }
     },
     lo = class extends Q {
-        constructor(e, r, s, i) {
-            super(), this.name = e, this.args = r, this.returnType = s, this.body = i
+        constructor(t, r, s, i) {
+            super(), this.name = t, this.args = r, this.returnType = s, this.body = i
         }
         get astNodeType() {
             return "function"
         }
     },
     Qc = class extends Q {
-        constructor(e) {
-            super(), this.expression = e
+        constructor(t) {
+            super(), this.expression = t
         }
         get astNodeType() {
             return "staticAssert"
         }
     },
     Jc = class extends Q {
-        constructor(e, r) {
-            super(), this.condition = e, this.body = r
+        constructor(t, r) {
+            super(), this.condition = t, this.body = r
         }
         get astNodeType() {
             return "while"
         }
     },
     Gc = class extends Q {
-        constructor(e) {
-            super(), this.body = e
+        constructor(t) {
+            super(), this.body = t
         }
         get astNodeType() {
             return "continuing"
         }
     },
-    el = class extends Q {
-        constructor(e, r, s, i) {
-            super(), this.init = e, this.condition = r, this.increment = s, this.body = i
+    tl = class extends Q {
+        constructor(t, r, s, i) {
+            super(), this.init = t, this.condition = r, this.increment = s, this.body = i
         }
         get astNodeType() {
             return "for"
         }
     },
-    Ht = class extends Q {
-        constructor(e, r, s, i, n) {
-            super(), this.name = e, this.type = r, this.storage = s, this.access = i, this.value = n
+    je = class extends Q {
+        constructor(t, r, s, i, n) {
+            super(), this.name = t, this.type = r, this.storage = s, this.access = i, this.value = n
         }
         get astNodeType() {
             return "var"
         }
     },
-    ho = class extends Q {
-        constructor(e, r, s) {
-            super(), this.name = e, this.type = r, this.value = s
+    fo = class extends Q {
+        constructor(t, r, s) {
+            super(), this.name = t, this.type = r, this.value = s
         }
         get astNodeType() {
             return "override"
         }
     },
-    fo = class extends Q {
-        constructor(e, r, s, i, n) {
-            super(), this.name = e, this.type = r, this.storage = s, this.access = i, this.value = n
+    ho = class extends Q {
+        constructor(t, r, s, i, n) {
+            super(), this.name = t, this.type = r, this.storage = s, this.access = i, this.value = n
         }
         get astNodeType() {
             return "let"
         }
     },
     uo = class extends Q {
-        constructor(e, r, s, i, n) {
-            super(), this.name = e, this.type = r, this.storage = s, this.access = i, this.value = n
+        constructor(t, r, s, i, n) {
+            super(), this.name = t, this.type = r, this.storage = s, this.access = i, this.value = n
         }
         get astNodeType() {
             return "const"
         }
-        evaluate(e) {
-            return this.value.evaluate(e)
+        evaluate(t) {
+            return this.value.evaluate(t)
         }
     },
-    ts;
-(function(t) {
-    t.increment = "++", t.decrement = "--"
-})(ts || (ts = {}));
-(function(t) {
-    function e(r) {
+    es;
+(function(e) {
+    e.increment = "++", e.decrement = "--"
+})(es || (es = {}));
+(function(e) {
+    function t(r) {
         let s = r;
         if (s == "parse") throw new Error("Invalid value for IncrementOperator");
-        return t[s]
+        return e[s]
     }
-    t.parse = e
-})(ts || (ts = {}));
-var tl = class extends Q {
-        constructor(e, r) {
-            super(), this.operator = e, this.variable = r
+    e.parse = t
+})(es || (es = {}));
+var el = class extends Q {
+        constructor(t, r) {
+            super(), this.operator = t, this.variable = r
         }
         get astNodeType() {
             return "increment"
         }
     },
-    gi;
-(function(t) {
-    t.assign = "=", t.addAssign = "+=", t.subtractAssin = "-=", t.multiplyAssign = "*=", t.divideAssign = "/=", t.moduloAssign = "%=", t.andAssign = "&=", t.orAssign = "|=", t.xorAssign = "^=", t.shiftLeftAssign = "<<=", t.shiftRightAssign = ">>="
-})(gi || (gi = {}));
-(function(t) {
-    function e(r) {
+    _i;
+(function(e) {
+    e.assign = "=", e.addAssign = "+=", e.subtractAssin = "-=", e.multiplyAssign = "*=", e.divideAssign = "/=", e.moduloAssign = "%=", e.andAssign = "&=", e.orAssign = "|=", e.xorAssign = "^=", e.shiftLeftAssign = "<<=", e.shiftRightAssign = ">>="
+})(_i || (_i = {}));
+(function(e) {
+    function t(r) {
         let s = r;
         if (s == "parse") throw new Error("Invalid value for AssignOperator");
-        return t[s]
+        return e[s]
     }
-    t.parse = e
-})(gi || (gi = {}));
+    e.parse = t
+})(_i || (_i = {}));
 var rl = class extends Q {
-        constructor(e, r, s) {
-            super(), this.operator = e, this.variable = r, this.value = s
+        constructor(t, r, s) {
+            super(), this.operator = t, this.variable = r, this.value = s
         }
         get astNodeType() {
             return "assign"
         }
     },
     sl = class extends Q {
-        constructor(e, r) {
-            super(), this.name = e, this.args = r
+        constructor(t, r) {
+            super(), this.name = t, this.args = r
         }
         get astNodeType() {
             return "call"
         }
     },
     il = class extends Q {
-        constructor(e, r) {
-            super(), this.body = e, this.continuing = r
+        constructor(t, r) {
+            super(), this.body = t, this.continuing = r
         }
         get astNodeType() {
             return "loop"
         }
     },
     nl = class extends Q {
-        constructor(e, r) {
-            super(), this.condition = e, this.body = r
+        constructor(t, r) {
+            super(), this.condition = t, this.body = r
         }
         get astNodeType() {
             return "body"
         }
     },
     ol = class extends Q {
-        constructor(e, r, s, i) {
-            super(), this.condition = e, this.body = r, this.elseif = s, this.else = i
+        constructor(t, r, s, i) {
+            super(), this.condition = t, this.body = r, this.elseif = s, this.else = i
         }
         get astNodeType() {
             return "if"
         }
     },
     al = class extends Q {
-        constructor(e) {
-            super(), this.value = e
+        constructor(t) {
+            super(), this.value = t
         }
         get astNodeType() {
             return "return"
         }
     },
     cl = class extends Q {
-        constructor(e) {
-            super(), this.name = e
+        constructor(t) {
+            super(), this.name = t
         }
         get astNodeType() {
             return "enable"
         }
     },
     po = class extends Q {
-        constructor(e, r) {
-            super(), this.name = e, this.type = r
+        constructor(t, r) {
+            super(), this.name = t, this.type = r
         }
         get astNodeType() {
             return "alias"
         }
     },
     ll = class extends Q {
         constructor() {
             super()
         }
         get astNodeType() {
             return "discard"
         }
     },
-    hl = class extends Q {
+    fl = class extends Q {
         constructor() {
             super()
         }
         get astNodeType() {
             return "break"
         }
     },
-    fl = class extends Q {
+    hl = class extends Q {
         constructor() {
             super()
         }
         get astNodeType() {
             return "continue"
         }
     },
-    xt = class extends Q {
-        constructor(e) {
-            super(), this.name = e
+    Ee = class extends Q {
+        constructor(t) {
+            super(), this.name = t
         }
         get astNodeType() {
             return "type"
         }
         get isStruct() {
             return !1
         }
         get isArray() {
             return !1
         }
     },
-    Et = class extends xt {
-        constructor(e, r) {
-            super(e), this.members = r
+    we = class extends Ee {
+        constructor(t, r) {
+            super(t), this.members = r
         }
         get astNodeType() {
             return "struct"
         }
         get isStruct() {
             return !0
         }
-        getMemberIndex(e) {
+        getMemberIndex(t) {
             for (let r = 0; r < this.members.length; r++)
-                if (this.members[r].name == e) return r;
+                if (this.members[r].name == t) return r;
             return -1
         }
     },
-    go = class extends xt {
-        constructor(e, r, s) {
-            super(e), this.format = r, this.access = s
+    _o = class extends Ee {
+        constructor(t, r, s) {
+            super(t), this.format = r, this.access = s
         }
         get astNodeType() {
             return "template"
         }
     },
-    ul = class extends xt {
-        constructor(e, r, s, i) {
-            super(e), this.storage = r, this.type = s, this.access = i
+    ul = class extends Ee {
+        constructor(t, r, s, i) {
+            super(t), this.storage = r, this.type = s, this.access = i
         }
         get astNodeType() {
             return "pointer"
         }
     },
-    _o = class extends xt {
-        constructor(e, r, s, i) {
-            super(e), this.attributes = r, this.format = s, this.count = i
+    go = class extends Ee {
+        constructor(t, r, s, i) {
+            super(t), this.attributes = r, this.format = s, this.count = i
         }
         get astNodeType() {
             return "array"
         }
         get isArray() {
             return !0
         }
     },
-    Sr = class extends xt {
-        constructor(e, r, s) {
-            super(e), this.format = r, this.access = s
+    xr = class extends Ee {
+        constructor(t, r, s) {
+            super(t), this.format = r, this.access = s
         }
         get astNodeType() {
             return "sampler"
         }
     },
-    Ue = class extends At {
+    Ut = class extends Ae {
         constructor() {
             super()
         }
     },
-    mo = class extends Ue {
-        constructor(e) {
-            super(), this.value = e
+    mo = class extends Ut {
+        constructor(t) {
+            super(), this.value = t
         }
         get astNodeType() {
             return "stringExpr"
         }
         toString() {
             return this.value
         }
         evaluateString() {
             return this.value
         }
     },
-    wr = class extends Ue {
-        constructor(e, r) {
-            super(), this.type = e, this.args = r
+    Sr = class extends Ut {
+        constructor(t, r) {
+            super(), this.type = t, this.args = r
         }
         get astNodeType() {
             return "createExpr"
         }
     },
-    dl = class extends Ue {
-        constructor(e, r) {
-            super(), this.name = e, this.args = r
+    dl = class extends Ut {
+        constructor(t, r) {
+            super(), this.name = t, this.args = r
         }
         get astNodeType() {
             return "callExpr"
         }
-        evaluate(e) {
+        evaluate(t) {
             switch (this.name) {
                 case "abs":
-                    return Math.abs(this.args[0].evaluate(e));
+                    return Math.abs(this.args[0].evaluate(t));
                 case "acos":
-                    return Math.acos(this.args[0].evaluate(e));
+                    return Math.acos(this.args[0].evaluate(t));
                 case "acosh":
-                    return Math.acosh(this.args[0].evaluate(e));
+                    return Math.acosh(this.args[0].evaluate(t));
                 case "asin":
-                    return Math.asin(this.args[0].evaluate(e));
+                    return Math.asin(this.args[0].evaluate(t));
                 case "asinh":
-                    return Math.asinh(this.args[0].evaluate(e));
+                    return Math.asinh(this.args[0].evaluate(t));
                 case "atan":
-                    return Math.atan(this.args[0].evaluate(e));
+                    return Math.atan(this.args[0].evaluate(t));
                 case "atan2":
-                    return Math.atan2(this.args[0].evaluate(e), this.args[1].evaluate(e));
+                    return Math.atan2(this.args[0].evaluate(t), this.args[1].evaluate(t));
                 case "atanh":
-                    return Math.atanh(this.args[0].evaluate(e));
+                    return Math.atanh(this.args[0].evaluate(t));
                 case "ceil":
-                    return Math.ceil(this.args[0].evaluate(e));
+                    return Math.ceil(this.args[0].evaluate(t));
                 case "clamp":
-                    return Math.min(Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e)), this.args[2].evaluate(e));
+                    return Math.min(Math.max(this.args[0].evaluate(t), this.args[1].evaluate(t)), this.args[2].evaluate(t));
                 case "cos":
-                    return Math.cos(this.args[0].evaluate(e));
+                    return Math.cos(this.args[0].evaluate(t));
                 case "degrees":
-                    return this.args[0].evaluate(e) * 180 / Math.PI;
+                    return this.args[0].evaluate(t) * 180 / Math.PI;
                 case "distance":
-                    return Math.sqrt(Math.pow(this.args[0].evaluate(e) - this.args[1].evaluate(e), 2));
+                    return Math.sqrt(Math.pow(this.args[0].evaluate(t) - this.args[1].evaluate(t), 2));
                 case "dot":
                 case "exp":
-                    return Math.exp(this.args[0].evaluate(e));
+                    return Math.exp(this.args[0].evaluate(t));
                 case "exp2":
-                    return Math.pow(2, this.args[0].evaluate(e));
+                    return Math.pow(2, this.args[0].evaluate(t));
                 case "floor":
-                    return Math.floor(this.args[0].evaluate(e));
+                    return Math.floor(this.args[0].evaluate(t));
                 case "fma":
-                    return this.args[0].evaluate(e) * this.args[1].evaluate(e) + this.args[2].evaluate(e);
+                    return this.args[0].evaluate(t) * this.args[1].evaluate(t) + this.args[2].evaluate(t);
                 case "fract":
-                    return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
+                    return this.args[0].evaluate(t) - Math.floor(this.args[0].evaluate(t));
                 case "inverseSqrt":
-                    return 1 / Math.sqrt(this.args[0].evaluate(e));
+                    return 1 / Math.sqrt(this.args[0].evaluate(t));
                 case "log":
-                    return Math.log(this.args[0].evaluate(e));
+                    return Math.log(this.args[0].evaluate(t));
                 case "log2":
-                    return Math.log2(this.args[0].evaluate(e));
+                    return Math.log2(this.args[0].evaluate(t));
                 case "max":
-                    return Math.max(this.args[0].evaluate(e), this.args[1].evaluate(e));
+                    return Math.max(this.args[0].evaluate(t), this.args[1].evaluate(t));
                 case "min":
-                    return Math.min(this.args[0].evaluate(e), this.args[1].evaluate(e));
+                    return Math.min(this.args[0].evaluate(t), this.args[1].evaluate(t));
                 case "mix":
-                    return this.args[0].evaluate(e) * (1 - this.args[2].evaluate(e)) + this.args[1].evaluate(e) * this.args[2].evaluate(e);
+                    return this.args[0].evaluate(t) * (1 - this.args[2].evaluate(t)) + this.args[1].evaluate(t) * this.args[2].evaluate(t);
                 case "modf":
-                    return this.args[0].evaluate(e) - Math.floor(this.args[0].evaluate(e));
+                    return this.args[0].evaluate(t) - Math.floor(this.args[0].evaluate(t));
                 case "pow":
-                    return Math.pow(this.args[0].evaluate(e), this.args[1].evaluate(e));
+                    return Math.pow(this.args[0].evaluate(t), this.args[1].evaluate(t));
                 case "radians":
-                    return this.args[0].evaluate(e) * Math.PI / 180;
+                    return this.args[0].evaluate(t) * Math.PI / 180;
                 case "round":
-                    return Math.round(this.args[0].evaluate(e));
+                    return Math.round(this.args[0].evaluate(t));
                 case "sign":
-                    return Math.sign(this.args[0].evaluate(e));
+                    return Math.sign(this.args[0].evaluate(t));
                 case "sin":
-                    return Math.sin(this.args[0].evaluate(e));
+                    return Math.sin(this.args[0].evaluate(t));
                 case "sinh":
-                    return Math.sinh(this.args[0].evaluate(e));
+                    return Math.sinh(this.args[0].evaluate(t));
                 case "saturate":
-                    return Math.min(Math.max(this.args[0].evaluate(e), 0), 1);
+                    return Math.min(Math.max(this.args[0].evaluate(t), 0), 1);
                 case "smoothstep":
-                    return this.args[0].evaluate(e) * this.args[0].evaluate(e) * (3 - 2 * this.args[0].evaluate(e));
+                    return this.args[0].evaluate(t) * this.args[0].evaluate(t) * (3 - 2 * this.args[0].evaluate(t));
                 case "sqrt":
-                    return Math.sqrt(this.args[0].evaluate(e));
+                    return Math.sqrt(this.args[0].evaluate(t));
                 case "step":
-                    return this.args[0].evaluate(e) < this.args[1].evaluate(e) ? 0 : 1;
+                    return this.args[0].evaluate(t) < this.args[1].evaluate(t) ? 0 : 1;
                 case "tan":
-                    return Math.tan(this.args[0].evaluate(e));
+                    return Math.tan(this.args[0].evaluate(t));
                 case "tanh":
-                    return Math.tanh(this.args[0].evaluate(e));
+                    return Math.tanh(this.args[0].evaluate(t));
                 case "trunc":
-                    return Math.trunc(this.args[0].evaluate(e));
+                    return Math.trunc(this.args[0].evaluate(t));
                 default:
                     throw new Error("Non const function: " + this.name)
             }
         }
     },
-    pl = class extends Ue {
-        constructor(e) {
-            super(), this.name = e
+    pl = class extends Ut {
+        constructor(t) {
+            super(), this.name = t
         }
         get astNodeType() {
             return "varExpr"
         }
     },
-    To = class extends Ue {
-        constructor(e, r) {
-            super(), this.name = e, this.initializer = r
+    bo = class extends Ut {
+        constructor(t, r) {
+            super(), this.name = t, this.initializer = r
         }
         get astNodeType() {
             return "constExpr"
         }
-        evaluate(e) {
+        evaluate(t) {
             var r, s;
-            if (this.initializer instanceof wr) {
-                let i = (r = this.postfix) === null || r === void 0 ? void 0 : r.evaluateString(e),
+            if (this.initializer instanceof Sr) {
+                let i = (r = this.postfix) === null || r === void 0 ? void 0 : r.evaluateString(t),
                     n = (s = this.initializer.type) === null || s === void 0 ? void 0 : s.name,
-                    o = e.structs.get(n),
+                    o = t.structs.get(n),
                     a = o?.getMemberIndex(i);
-                if (a != -1) return this.initializer.args[a].evaluate(e);
+                if (a != -1) return this.initializer.args[a].evaluate(t);
                 console.log(a)
             }
-            return this.initializer.evaluate(e)
+            return this.initializer.evaluate(t)
         }
     },
-    yo = class extends Ue {
-        constructor(e) {
-            super(), this.value = e
+    yo = class extends Ut {
+        constructor(t) {
+            super(), this.value = t
         }
         get astNodeType() {
             return "literalExpr"
         }
         evaluate() {
             return this.value
         }
     },
-    gl = class extends Ue {
-        constructor(e, r) {
-            super(), this.type = e, this.value = r
+    _l = class extends Ut {
+        constructor(t, r) {
+            super(), this.type = t, this.value = r
         }
         get astNodeType() {
             return "bitcastExpr"
         }
     },
-    _l = class extends Ue {
-        constructor(e, r) {
-            super(), this.type = e, this.args = r
+    gl = class extends Ut {
+        constructor(t, r) {
+            super(), this.type = t, this.args = r
         }
         get astNodeType() {
             return "typecastExpr"
         }
-        evaluate(e) {
-            return this.args[0].evaluate(e)
+        evaluate(t) {
+            return this.args[0].evaluate(t)
         }
     },
-    bo = class extends Ue {
-        constructor(e) {
-            super(), this.contents = e
+    To = class extends Ut {
+        constructor(t) {
+            super(), this.contents = t
         }
         get astNodeType() {
             return "groupExpr"
         }
-        evaluate(e) {
-            return this.contents[0].evaluate(e)
+        evaluate(t) {
+            return this.contents[0].evaluate(t)
         }
     },
-    Eo = class extends Ue {
+    wo = class extends Ut {
         constructor() {
             super()
         }
     },
-    ml = class extends Eo {
-        constructor(e, r) {
-            super(), this.operator = e, this.right = r
+    ml = class extends wo {
+        constructor(t, r) {
+            super(), this.operator = t, this.right = r
         }
         get astNodeType() {
             return "unaryOp"
         }
-        evaluate(e) {
+        evaluate(t) {
             switch (this.operator) {
                 case "+":
-                    return this.right.evaluate(e);
+                    return this.right.evaluate(t);
                 case "-":
-                    return -this.right.evaluate(e);
+                    return -this.right.evaluate(t);
                 case "!":
-                    return this.right.evaluate(e) ? 0 : 1;
+                    return this.right.evaluate(t) ? 0 : 1;
                 case "~":
-                    return ~this.right.evaluate(e);
+                    return ~this.right.evaluate(t);
                 default:
                     throw new Error("Unknown unary operator: " + this.operator)
             }
         }
     },
-    Be = class extends Eo {
-        constructor(e, r, s) {
-            super(), this.operator = e, this.left = r, this.right = s
+    Bt = class extends wo {
+        constructor(t, r, s) {
+            super(), this.operator = t, this.left = r, this.right = s
         }
         get astNodeType() {
             return "binaryOp"
         }
-        evaluate(e) {
+        evaluate(t) {
             switch (this.operator) {
                 case "+":
-                    return this.left.evaluate(e) + this.right.evaluate(e);
+                    return this.left.evaluate(t) + this.right.evaluate(t);
                 case "-":
-                    return this.left.evaluate(e) - this.right.evaluate(e);
+                    return this.left.evaluate(t) - this.right.evaluate(t);
                 case "*":
-                    return this.left.evaluate(e) * this.right.evaluate(e);
+                    return this.left.evaluate(t) * this.right.evaluate(t);
                 case "/":
-                    return this.left.evaluate(e) / this.right.evaluate(e);
+                    return this.left.evaluate(t) / this.right.evaluate(t);
                 case "%":
-                    return this.left.evaluate(e) % this.right.evaluate(e);
+                    return this.left.evaluate(t) % this.right.evaluate(t);
                 case "==":
-                    return this.left.evaluate(e) == this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) == this.right.evaluate(t) ? 1 : 0;
                 case "!=":
-                    return this.left.evaluate(e) != this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) != this.right.evaluate(t) ? 1 : 0;
                 case "<":
-                    return this.left.evaluate(e) < this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) < this.right.evaluate(t) ? 1 : 0;
                 case ">":
-                    return this.left.evaluate(e) > this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) > this.right.evaluate(t) ? 1 : 0;
                 case "<=":
-                    return this.left.evaluate(e) <= this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) <= this.right.evaluate(t) ? 1 : 0;
                 case ">=":
-                    return this.left.evaluate(e) >= this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) >= this.right.evaluate(t) ? 1 : 0;
                 case "&&":
-                    return this.left.evaluate(e) && this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) && this.right.evaluate(t) ? 1 : 0;
                 case "||":
-                    return this.left.evaluate(e) || this.right.evaluate(e) ? 1 : 0;
+                    return this.left.evaluate(t) || this.right.evaluate(t) ? 1 : 0;
                 default:
                     throw new Error(`Unknown operator ${this.operator}`)
             }
         }
     },
-    Ao = class extends At {
+    Ao = class extends Ae {
         constructor() {
             super()
         }
     },
-    Tl = class extends Ao {
-        constructor(e, r) {
-            super(), this.selector = e, this.body = r
+    bl = class extends Ao {
+        constructor(t, r) {
+            super(), this.selector = t, this.body = r
         }
         get astNodeType() {
             return "case"
         }
     },
     yl = class extends Ao {
-        constructor(e) {
-            super(), this.body = e
+        constructor(t) {
+            super(), this.body = t
         }
         get astNodeType() {
             return "default"
         }
     },
-    bl = class extends At {
-        constructor(e, r, s) {
-            super(), this.name = e, this.type = r, this.attributes = s
+    Tl = class extends Ae {
+        constructor(t, r, s) {
+            super(), this.name = t, this.type = r, this.attributes = s
         }
         get astNodeType() {
             return "argument"
         }
     },
-    El = class extends At {
-        constructor(e, r) {
-            super(), this.condition = e, this.body = r
+    wl = class extends Ae {
+        constructor(t, r) {
+            super(), this.condition = t, this.body = r
         }
         get astNodeType() {
             return "elseif"
         }
     },
-    Al = class extends At {
-        constructor(e, r, s) {
-            super(), this.name = e, this.type = r, this.attributes = s
+    Al = class extends Ae {
+        constructor(t, r, s) {
+            super(), this.name = t, this.type = r, this.attributes = s
         }
         get astNodeType() {
             return "member"
         }
     },
-    xo = class extends At {
-        constructor(e, r) {
-            super(), this.name = e, this.value = r
+    Eo = class extends Ae {
+        constructor(t, r) {
+            super(), this.name = t, this.value = r
         }
         get astNodeType() {
             return "attribute"
         }
     },
     M, A;
-(function(t) {
-    t[t.token = 0] = "token", t[t.keyword = 1] = "keyword", t[t.reserved = 2] = "reserved"
+(function(e) {
+    e[e.token = 0] = "token", e[e.keyword = 1] = "keyword", e[e.reserved = 2] = "reserved"
 })(A || (A = {}));
-var E = class {
-        constructor(e, r, s) {
-            this.name = e, this.type = r, this.rule = s
+var w = class {
+        constructor(t, r, s) {
+            this.name = t, this.type = r, this.rule = s
         }
         toString() {
             return this.name
         }
     },
-    _ = class {};
-M = _;
-_.none = new E("", A.reserved, "");
-_.eof = new E("EOF", A.token, "");
-_.reserved = {
-    asm: new E("asm", A.reserved, "asm"),
-    bf16: new E("bf16", A.reserved, "bf16"),
-    do: new E("do", A.reserved, "do"),
-    enum: new E("enum", A.reserved, "enum"),
-    f16: new E("f16", A.reserved, "f16"),
-    f64: new E("f64", A.reserved, "f64"),
-    handle: new E("handle", A.reserved, "handle"),
-    i8: new E("i8", A.reserved, "i8"),
-    i16: new E("i16", A.reserved, "i16"),
-    i64: new E("i64", A.reserved, "i64"),
-    mat: new E("mat", A.reserved, "mat"),
-    premerge: new E("premerge", A.reserved, "premerge"),
-    regardless: new E("regardless", A.reserved, "regardless"),
-    typedef: new E("typedef", A.reserved, "typedef"),
-    u8: new E("u8", A.reserved, "u8"),
-    u16: new E("u16", A.reserved, "u16"),
-    u64: new E("u64", A.reserved, "u64"),
-    unless: new E("unless", A.reserved, "unless"),
-    using: new E("using", A.reserved, "using"),
-    vec: new E("vec", A.reserved, "vec"),
-    void: new E("void", A.reserved, "void")
-};
-_.keywords = {
-    array: new E("array", A.keyword, "array"),
-    atomic: new E("atomic", A.keyword, "atomic"),
-    bool: new E("bool", A.keyword, "bool"),
-    f32: new E("f32", A.keyword, "f32"),
-    i32: new E("i32", A.keyword, "i32"),
-    mat2x2: new E("mat2x2", A.keyword, "mat2x2"),
-    mat2x3: new E("mat2x3", A.keyword, "mat2x3"),
-    mat2x4: new E("mat2x4", A.keyword, "mat2x4"),
-    mat3x2: new E("mat3x2", A.keyword, "mat3x2"),
-    mat3x3: new E("mat3x3", A.keyword, "mat3x3"),
-    mat3x4: new E("mat3x4", A.keyword, "mat3x4"),
-    mat4x2: new E("mat4x2", A.keyword, "mat4x2"),
-    mat4x3: new E("mat4x3", A.keyword, "mat4x3"),
-    mat4x4: new E("mat4x4", A.keyword, "mat4x4"),
-    ptr: new E("ptr", A.keyword, "ptr"),
-    sampler: new E("sampler", A.keyword, "sampler"),
-    sampler_comparison: new E("sampler_comparison", A.keyword, "sampler_comparison"),
-    struct: new E("struct", A.keyword, "struct"),
-    texture_1d: new E("texture_1d", A.keyword, "texture_1d"),
-    texture_2d: new E("texture_2d", A.keyword, "texture_2d"),
-    texture_2d_array: new E("texture_2d_array", A.keyword, "texture_2d_array"),
-    texture_3d: new E("texture_3d", A.keyword, "texture_3d"),
-    texture_cube: new E("texture_cube", A.keyword, "texture_cube"),
-    texture_cube_array: new E("texture_cube_array", A.keyword, "texture_cube_array"),
-    texture_multisampled_2d: new E("texture_multisampled_2d", A.keyword, "texture_multisampled_2d"),
-    texture_storage_1d: new E("texture_storage_1d", A.keyword, "texture_storage_1d"),
-    texture_storage_2d: new E("texture_storage_2d", A.keyword, "texture_storage_2d"),
-    texture_storage_2d_array: new E("texture_storage_2d_array", A.keyword, "texture_storage_2d_array"),
-    texture_storage_3d: new E("texture_storage_3d", A.keyword, "texture_storage_3d"),
-    texture_depth_2d: new E("texture_depth_2d", A.keyword, "texture_depth_2d"),
-    texture_depth_2d_array: new E("texture_depth_2d_array", A.keyword, "texture_depth_2d_array"),
-    texture_depth_cube: new E("texture_depth_cube", A.keyword, "texture_depth_cube"),
-    texture_depth_cube_array: new E("texture_depth_cube_array", A.keyword, "texture_depth_cube_array"),
-    texture_depth_multisampled_2d: new E("texture_depth_multisampled_2d", A.keyword, "texture_depth_multisampled_2d"),
-    texture_external: new E("texture_external", A.keyword, "texture_external"),
-    u32: new E("u32", A.keyword, "u32"),
-    vec2: new E("vec2", A.keyword, "vec2"),
-    vec3: new E("vec3", A.keyword, "vec3"),
-    vec4: new E("vec4", A.keyword, "vec4"),
-    bitcast: new E("bitcast", A.keyword, "bitcast"),
-    block: new E("block", A.keyword, "block"),
-    break: new E("break", A.keyword, "break"),
-    case: new E("case", A.keyword, "case"),
-    continue: new E("continue", A.keyword, "continue"),
-    continuing: new E("continuing", A.keyword, "continuing"),
-    default: new E("default", A.keyword, "default"),
-    discard: new E("discard", A.keyword, "discard"),
-    else: new E("else", A.keyword, "else"),
-    enable: new E("enable", A.keyword, "enable"),
-    fallthrough: new E("fallthrough", A.keyword, "fallthrough"),
-    false: new E("false", A.keyword, "false"),
-    fn: new E("fn", A.keyword, "fn"),
-    for: new E("for", A.keyword, "for"),
-    function: new E("function", A.keyword, "function"),
-    if: new E("if", A.keyword, "if"),
-    let: new E("let", A.keyword, "let"),
-    const: new E("const", A.keyword, "const"),
-    loop: new E("loop", A.keyword, "loop"),
-    while: new E("while", A.keyword, "while"),
-    private: new E("private", A.keyword, "private"),
-    read: new E("read", A.keyword, "read"),
-    read_write: new E("read_write", A.keyword, "read_write"),
-    return: new E("return", A.keyword, "return"),
-    storage: new E("storage", A.keyword, "storage"),
-    switch: new E("switch", A.keyword, "switch"),
-    true: new E("true", A.keyword, "true"),
-    alias: new E("alias", A.keyword, "alias"),
-    type: new E("type", A.keyword, "type"),
-    uniform: new E("uniform", A.keyword, "uniform"),
-    var: new E("var", A.keyword, "var"),
-    override: new E("override", A.keyword, "override"),
-    workgroup: new E("workgroup", A.keyword, "workgroup"),
-    write: new E("write", A.keyword, "write"),
-    r8unorm: new E("r8unorm", A.keyword, "r8unorm"),
-    r8snorm: new E("r8snorm", A.keyword, "r8snorm"),
-    r8uint: new E("r8uint", A.keyword, "r8uint"),
-    r8sint: new E("r8sint", A.keyword, "r8sint"),
-    r16uint: new E("r16uint", A.keyword, "r16uint"),
-    r16sint: new E("r16sint", A.keyword, "r16sint"),
-    r16float: new E("r16float", A.keyword, "r16float"),
-    rg8unorm: new E("rg8unorm", A.keyword, "rg8unorm"),
-    rg8snorm: new E("rg8snorm", A.keyword, "rg8snorm"),
-    rg8uint: new E("rg8uint", A.keyword, "rg8uint"),
-    rg8sint: new E("rg8sint", A.keyword, "rg8sint"),
-    r32uint: new E("r32uint", A.keyword, "r32uint"),
-    r32sint: new E("r32sint", A.keyword, "r32sint"),
-    r32float: new E("r32float", A.keyword, "r32float"),
-    rg16uint: new E("rg16uint", A.keyword, "rg16uint"),
-    rg16sint: new E("rg16sint", A.keyword, "rg16sint"),
-    rg16float: new E("rg16float", A.keyword, "rg16float"),
-    rgba8unorm: new E("rgba8unorm", A.keyword, "rgba8unorm"),
-    rgba8unorm_srgb: new E("rgba8unorm_srgb", A.keyword, "rgba8unorm_srgb"),
-    rgba8snorm: new E("rgba8snorm", A.keyword, "rgba8snorm"),
-    rgba8uint: new E("rgba8uint", A.keyword, "rgba8uint"),
-    rgba8sint: new E("rgba8sint", A.keyword, "rgba8sint"),
-    bgra8unorm: new E("bgra8unorm", A.keyword, "bgra8unorm"),
-    bgra8unorm_srgb: new E("bgra8unorm_srgb", A.keyword, "bgra8unorm_srgb"),
-    rgb10a2unorm: new E("rgb10a2unorm", A.keyword, "rgb10a2unorm"),
-    rg11b10float: new E("rg11b10float", A.keyword, "rg11b10float"),
-    rg32uint: new E("rg32uint", A.keyword, "rg32uint"),
-    rg32sint: new E("rg32sint", A.keyword, "rg32sint"),
-    rg32float: new E("rg32float", A.keyword, "rg32float"),
-    rgba16uint: new E("rgba16uint", A.keyword, "rgba16uint"),
-    rgba16sint: new E("rgba16sint", A.keyword, "rgba16sint"),
-    rgba16float: new E("rgba16float", A.keyword, "rgba16float"),
-    rgba32uint: new E("rgba32uint", A.keyword, "rgba32uint"),
-    rgba32sint: new E("rgba32sint", A.keyword, "rgba32sint"),
-    rgba32float: new E("rgba32float", A.keyword, "rgba32float"),
-    static_assert: new E("static_assert", A.keyword, "static_assert")
-};
-_.tokens = {
-    decimal_float_literal: new E("decimal_float_literal", A.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
-    hex_float_literal: new E("hex_float_literal", A.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
-    int_literal: new E("int_literal", A.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
-    uint_literal: new E("uint_literal", A.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
-    ident: new E("ident", A.token, /[a-zA-Z][0-9a-zA-Z_]*/),
-    and: new E("and", A.token, "&"),
-    and_and: new E("and_and", A.token, "&&"),
-    arrow: new E("arrow ", A.token, "->"),
-    attr: new E("attr", A.token, "@"),
-    attr_left: new E("attr_left", A.token, "[["),
-    attr_right: new E("attr_right", A.token, "]]"),
-    forward_slash: new E("forward_slash", A.token, "/"),
-    bang: new E("bang", A.token, "!"),
-    bracket_left: new E("bracket_left", A.token, "["),
-    bracket_right: new E("bracket_right", A.token, "]"),
-    brace_left: new E("brace_left", A.token, "{"),
-    brace_right: new E("brace_right", A.token, "}"),
-    colon: new E("colon", A.token, ":"),
-    comma: new E("comma", A.token, ","),
-    equal: new E("equal", A.token, "="),
-    equal_equal: new E("equal_equal", A.token, "=="),
-    not_equal: new E("not_equal", A.token, "!="),
-    greater_than: new E("greater_than", A.token, ">"),
-    greater_than_equal: new E("greater_than_equal", A.token, ">="),
-    shift_right: new E("shift_right", A.token, ">>"),
-    less_than: new E("less_than", A.token, "<"),
-    less_than_equal: new E("less_than_equal", A.token, "<="),
-    shift_left: new E("shift_left", A.token, "<<"),
-    modulo: new E("modulo", A.token, "%"),
-    minus: new E("minus", A.token, "-"),
-    minus_minus: new E("minus_minus", A.token, "--"),
-    period: new E("period", A.token, "."),
-    plus: new E("plus", A.token, "+"),
-    plus_plus: new E("plus_plus", A.token, "++"),
-    or: new E("or", A.token, "|"),
-    or_or: new E("or_or", A.token, "||"),
-    paren_left: new E("paren_left", A.token, "("),
-    paren_right: new E("paren_right", A.token, ")"),
-    semicolon: new E("semicolon", A.token, ";"),
-    star: new E("star", A.token, "*"),
-    tilde: new E("tilde", A.token, "~"),
-    underscore: new E("underscore", A.token, "_"),
-    xor: new E("xor", A.token, "^"),
-    plus_equal: new E("plus_equal", A.token, "+="),
-    minus_equal: new E("minus_equal", A.token, "-="),
-    times_equal: new E("times_equal", A.token, "*="),
-    division_equal: new E("division_equal", A.token, "/="),
-    modulo_equal: new E("modulo_equal", A.token, "%="),
-    and_equal: new E("and_equal", A.token, "&="),
-    or_equal: new E("or_equal", A.token, "|="),
-    xor_equal: new E("xor_equal", A.token, "^="),
-    shift_right_equal: new E("shift_right_equal", A.token, ">>="),
-    shift_left_equal: new E("shift_left_equal", A.token, "<<=")
-};
-_.storage_class = [M.keywords.function, M.keywords.private, M.keywords.workgroup, M.keywords.uniform, M.keywords.storage];
-_.access_mode = [M.keywords.read, M.keywords.write, M.keywords.read_write];
-_.sampler_type = [M.keywords.sampler, M.keywords.sampler_comparison];
-_.sampled_texture_type = [M.keywords.texture_1d, M.keywords.texture_2d, M.keywords.texture_2d_array, M.keywords.texture_3d, M.keywords.texture_cube, M.keywords.texture_cube_array];
-_.multisampled_texture_type = [M.keywords.texture_multisampled_2d];
-_.storage_texture_type = [M.keywords.texture_storage_1d, M.keywords.texture_storage_2d, M.keywords.texture_storage_2d_array, M.keywords.texture_storage_3d];
-_.depth_texture_type = [M.keywords.texture_depth_2d, M.keywords.texture_depth_2d_array, M.keywords.texture_depth_cube, M.keywords.texture_depth_cube_array, M.keywords.texture_depth_multisampled_2d];
-_.texture_external_type = [M.keywords.texture_external];
-_.any_texture_type = [...M.sampled_texture_type, ...M.multisampled_texture_type, ...M.storage_texture_type, ...M.depth_texture_type, ...M.texture_external_type];
-_.texel_format = [M.keywords.r8unorm, M.keywords.r8snorm, M.keywords.r8uint, M.keywords.r8sint, M.keywords.r16uint, M.keywords.r16sint, M.keywords.r16float, M.keywords.rg8unorm, M.keywords.rg8snorm, M.keywords.rg8uint, M.keywords.rg8sint, M.keywords.r32uint, M.keywords.r32sint, M.keywords.r32float, M.keywords.rg16uint, M.keywords.rg16sint, M.keywords.rg16float, M.keywords.rgba8unorm, M.keywords.rgba8unorm_srgb, M.keywords.rgba8snorm, M.keywords.rgba8uint, M.keywords.rgba8sint, M.keywords.bgra8unorm, M.keywords.bgra8unorm_srgb, M.keywords.rgb10a2unorm, M.keywords.rg11b10float, M.keywords.rg32uint, M.keywords.rg32sint, M.keywords.rg32float, M.keywords.rgba16uint, M.keywords.rgba16sint, M.keywords.rgba16float, M.keywords.rgba32uint, M.keywords.rgba32sint, M.keywords.rgba32float];
-_.const_literal = [M.tokens.int_literal, M.tokens.uint_literal, M.tokens.decimal_float_literal, M.tokens.hex_float_literal, M.keywords.true, M.keywords.false];
-_.literal_or_ident = [M.tokens.ident, M.tokens.int_literal, M.tokens.uint_literal, M.tokens.decimal_float_literal, M.tokens.hex_float_literal];
-_.element_count_expression = [M.tokens.int_literal, M.tokens.uint_literal, M.tokens.ident];
-_.template_types = [M.keywords.vec2, M.keywords.vec3, M.keywords.vec4, M.keywords.mat2x2, M.keywords.mat2x3, M.keywords.mat2x4, M.keywords.mat3x2, M.keywords.mat3x3, M.keywords.mat3x4, M.keywords.mat4x2, M.keywords.mat4x3, M.keywords.mat4x4, M.keywords.atomic, M.keywords.bitcast, ...M.any_texture_type];
-_.attribute_name = [M.tokens.ident, M.keywords.block];
-_.assignment_operators = [M.tokens.equal, M.tokens.plus_equal, M.tokens.minus_equal, M.tokens.times_equal, M.tokens.division_equal, M.tokens.modulo_equal, M.tokens.and_equal, M.tokens.or_equal, M.tokens.xor_equal, M.tokens.shift_right_equal, M.tokens.shift_left_equal];
-_.increment_operators = [M.tokens.plus_plus, M.tokens.minus_minus];
-var So = class {
-        constructor(e, r, s) {
-            this.type = e, this.lexeme = r, this.line = s
+    g = class {};
+M = g;
+g.none = new w("", A.reserved, "");
+g.eof = new w("EOF", A.token, "");
+g.reserved = {
+    asm: new w("asm", A.reserved, "asm"),
+    bf16: new w("bf16", A.reserved, "bf16"),
+    do: new w("do", A.reserved, "do"),
+    enum: new w("enum", A.reserved, "enum"),
+    f16: new w("f16", A.reserved, "f16"),
+    f64: new w("f64", A.reserved, "f64"),
+    handle: new w("handle", A.reserved, "handle"),
+    i8: new w("i8", A.reserved, "i8"),
+    i16: new w("i16", A.reserved, "i16"),
+    i64: new w("i64", A.reserved, "i64"),
+    mat: new w("mat", A.reserved, "mat"),
+    premerge: new w("premerge", A.reserved, "premerge"),
+    regardless: new w("regardless", A.reserved, "regardless"),
+    typedef: new w("typedef", A.reserved, "typedef"),
+    u8: new w("u8", A.reserved, "u8"),
+    u16: new w("u16", A.reserved, "u16"),
+    u64: new w("u64", A.reserved, "u64"),
+    unless: new w("unless", A.reserved, "unless"),
+    using: new w("using", A.reserved, "using"),
+    vec: new w("vec", A.reserved, "vec"),
+    void: new w("void", A.reserved, "void")
+};
+g.keywords = {
+    array: new w("array", A.keyword, "array"),
+    atomic: new w("atomic", A.keyword, "atomic"),
+    bool: new w("bool", A.keyword, "bool"),
+    f32: new w("f32", A.keyword, "f32"),
+    i32: new w("i32", A.keyword, "i32"),
+    mat2x2: new w("mat2x2", A.keyword, "mat2x2"),
+    mat2x3: new w("mat2x3", A.keyword, "mat2x3"),
+    mat2x4: new w("mat2x4", A.keyword, "mat2x4"),
+    mat3x2: new w("mat3x2", A.keyword, "mat3x2"),
+    mat3x3: new w("mat3x3", A.keyword, "mat3x3"),
+    mat3x4: new w("mat3x4", A.keyword, "mat3x4"),
+    mat4x2: new w("mat4x2", A.keyword, "mat4x2"),
+    mat4x3: new w("mat4x3", A.keyword, "mat4x3"),
+    mat4x4: new w("mat4x4", A.keyword, "mat4x4"),
+    ptr: new w("ptr", A.keyword, "ptr"),
+    sampler: new w("sampler", A.keyword, "sampler"),
+    sampler_comparison: new w("sampler_comparison", A.keyword, "sampler_comparison"),
+    struct: new w("struct", A.keyword, "struct"),
+    texture_1d: new w("texture_1d", A.keyword, "texture_1d"),
+    texture_2d: new w("texture_2d", A.keyword, "texture_2d"),
+    texture_2d_array: new w("texture_2d_array", A.keyword, "texture_2d_array"),
+    texture_3d: new w("texture_3d", A.keyword, "texture_3d"),
+    texture_cube: new w("texture_cube", A.keyword, "texture_cube"),
+    texture_cube_array: new w("texture_cube_array", A.keyword, "texture_cube_array"),
+    texture_multisampled_2d: new w("texture_multisampled_2d", A.keyword, "texture_multisampled_2d"),
+    texture_storage_1d: new w("texture_storage_1d", A.keyword, "texture_storage_1d"),
+    texture_storage_2d: new w("texture_storage_2d", A.keyword, "texture_storage_2d"),
+    texture_storage_2d_array: new w("texture_storage_2d_array", A.keyword, "texture_storage_2d_array"),
+    texture_storage_3d: new w("texture_storage_3d", A.keyword, "texture_storage_3d"),
+    texture_depth_2d: new w("texture_depth_2d", A.keyword, "texture_depth_2d"),
+    texture_depth_2d_array: new w("texture_depth_2d_array", A.keyword, "texture_depth_2d_array"),
+    texture_depth_cube: new w("texture_depth_cube", A.keyword, "texture_depth_cube"),
+    texture_depth_cube_array: new w("texture_depth_cube_array", A.keyword, "texture_depth_cube_array"),
+    texture_depth_multisampled_2d: new w("texture_depth_multisampled_2d", A.keyword, "texture_depth_multisampled_2d"),
+    texture_external: new w("texture_external", A.keyword, "texture_external"),
+    u32: new w("u32", A.keyword, "u32"),
+    vec2: new w("vec2", A.keyword, "vec2"),
+    vec3: new w("vec3", A.keyword, "vec3"),
+    vec4: new w("vec4", A.keyword, "vec4"),
+    bitcast: new w("bitcast", A.keyword, "bitcast"),
+    block: new w("block", A.keyword, "block"),
+    break: new w("break", A.keyword, "break"),
+    case: new w("case", A.keyword, "case"),
+    continue: new w("continue", A.keyword, "continue"),
+    continuing: new w("continuing", A.keyword, "continuing"),
+    default: new w("default", A.keyword, "default"),
+    discard: new w("discard", A.keyword, "discard"),
+    else: new w("else", A.keyword, "else"),
+    enable: new w("enable", A.keyword, "enable"),
+    fallthrough: new w("fallthrough", A.keyword, "fallthrough"),
+    false: new w("false", A.keyword, "false"),
+    fn: new w("fn", A.keyword, "fn"),
+    for: new w("for", A.keyword, "for"),
+    function: new w("function", A.keyword, "function"),
+    if: new w("if", A.keyword, "if"),
+    let: new w("let", A.keyword, "let"),
+    const: new w("const", A.keyword, "const"),
+    loop: new w("loop", A.keyword, "loop"),
+    while: new w("while", A.keyword, "while"),
+    private: new w("private", A.keyword, "private"),
+    read: new w("read", A.keyword, "read"),
+    read_write: new w("read_write", A.keyword, "read_write"),
+    return: new w("return", A.keyword, "return"),
+    storage: new w("storage", A.keyword, "storage"),
+    switch: new w("switch", A.keyword, "switch"),
+    true: new w("true", A.keyword, "true"),
+    alias: new w("alias", A.keyword, "alias"),
+    type: new w("type", A.keyword, "type"),
+    uniform: new w("uniform", A.keyword, "uniform"),
+    var: new w("var", A.keyword, "var"),
+    override: new w("override", A.keyword, "override"),
+    workgroup: new w("workgroup", A.keyword, "workgroup"),
+    write: new w("write", A.keyword, "write"),
+    r8unorm: new w("r8unorm", A.keyword, "r8unorm"),
+    r8snorm: new w("r8snorm", A.keyword, "r8snorm"),
+    r8uint: new w("r8uint", A.keyword, "r8uint"),
+    r8sint: new w("r8sint", A.keyword, "r8sint"),
+    r16uint: new w("r16uint", A.keyword, "r16uint"),
+    r16sint: new w("r16sint", A.keyword, "r16sint"),
+    r16float: new w("r16float", A.keyword, "r16float"),
+    rg8unorm: new w("rg8unorm", A.keyword, "rg8unorm"),
+    rg8snorm: new w("rg8snorm", A.keyword, "rg8snorm"),
+    rg8uint: new w("rg8uint", A.keyword, "rg8uint"),
+    rg8sint: new w("rg8sint", A.keyword, "rg8sint"),
+    r32uint: new w("r32uint", A.keyword, "r32uint"),
+    r32sint: new w("r32sint", A.keyword, "r32sint"),
+    r32float: new w("r32float", A.keyword, "r32float"),
+    rg16uint: new w("rg16uint", A.keyword, "rg16uint"),
+    rg16sint: new w("rg16sint", A.keyword, "rg16sint"),
+    rg16float: new w("rg16float", A.keyword, "rg16float"),
+    rgba8unorm: new w("rgba8unorm", A.keyword, "rgba8unorm"),
+    rgba8unorm_srgb: new w("rgba8unorm_srgb", A.keyword, "rgba8unorm_srgb"),
+    rgba8snorm: new w("rgba8snorm", A.keyword, "rgba8snorm"),
+    rgba8uint: new w("rgba8uint", A.keyword, "rgba8uint"),
+    rgba8sint: new w("rgba8sint", A.keyword, "rgba8sint"),
+    bgra8unorm: new w("bgra8unorm", A.keyword, "bgra8unorm"),
+    bgra8unorm_srgb: new w("bgra8unorm_srgb", A.keyword, "bgra8unorm_srgb"),
+    rgb10a2unorm: new w("rgb10a2unorm", A.keyword, "rgb10a2unorm"),
+    rg11b10float: new w("rg11b10float", A.keyword, "rg11b10float"),
+    rg32uint: new w("rg32uint", A.keyword, "rg32uint"),
+    rg32sint: new w("rg32sint", A.keyword, "rg32sint"),
+    rg32float: new w("rg32float", A.keyword, "rg32float"),
+    rgba16uint: new w("rgba16uint", A.keyword, "rgba16uint"),
+    rgba16sint: new w("rgba16sint", A.keyword, "rgba16sint"),
+    rgba16float: new w("rgba16float", A.keyword, "rgba16float"),
+    rgba32uint: new w("rgba32uint", A.keyword, "rgba32uint"),
+    rgba32sint: new w("rgba32sint", A.keyword, "rgba32sint"),
+    rgba32float: new w("rgba32float", A.keyword, "rgba32float"),
+    static_assert: new w("static_assert", A.keyword, "static_assert")
+};
+g.tokens = {
+    decimal_float_literal: new w("decimal_float_literal", A.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
+    hex_float_literal: new w("hex_float_literal", A.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
+    int_literal: new w("int_literal", A.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
+    uint_literal: new w("uint_literal", A.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
+    ident: new w("ident", A.token, /[a-zA-Z][0-9a-zA-Z_]*/),
+    and: new w("and", A.token, "&"),
+    and_and: new w("and_and", A.token, "&&"),
+    arrow: new w("arrow ", A.token, "->"),
+    attr: new w("attr", A.token, "@"),
+    attr_left: new w("attr_left", A.token, "[["),
+    attr_right: new w("attr_right", A.token, "]]"),
+    forward_slash: new w("forward_slash", A.token, "/"),
+    bang: new w("bang", A.token, "!"),
+    bracket_left: new w("bracket_left", A.token, "["),
+    bracket_right: new w("bracket_right", A.token, "]"),
+    brace_left: new w("brace_left", A.token, "{"),
+    brace_right: new w("brace_right", A.token, "}"),
+    colon: new w("colon", A.token, ":"),
+    comma: new w("comma", A.token, ","),
+    equal: new w("equal", A.token, "="),
+    equal_equal: new w("equal_equal", A.token, "=="),
+    not_equal: new w("not_equal", A.token, "!="),
+    greater_than: new w("greater_than", A.token, ">"),
+    greater_than_equal: new w("greater_than_equal", A.token, ">="),
+    shift_right: new w("shift_right", A.token, ">>"),
+    less_than: new w("less_than", A.token, "<"),
+    less_than_equal: new w("less_than_equal", A.token, "<="),
+    shift_left: new w("shift_left", A.token, "<<"),
+    modulo: new w("modulo", A.token, "%"),
+    minus: new w("minus", A.token, "-"),
+    minus_minus: new w("minus_minus", A.token, "--"),
+    period: new w("period", A.token, "."),
+    plus: new w("plus", A.token, "+"),
+    plus_plus: new w("plus_plus", A.token, "++"),
+    or: new w("or", A.token, "|"),
+    or_or: new w("or_or", A.token, "||"),
+    paren_left: new w("paren_left", A.token, "("),
+    paren_right: new w("paren_right", A.token, ")"),
+    semicolon: new w("semicolon", A.token, ";"),
+    star: new w("star", A.token, "*"),
+    tilde: new w("tilde", A.token, "~"),
+    underscore: new w("underscore", A.token, "_"),
+    xor: new w("xor", A.token, "^"),
+    plus_equal: new w("plus_equal", A.token, "+="),
+    minus_equal: new w("minus_equal", A.token, "-="),
+    times_equal: new w("times_equal", A.token, "*="),
+    division_equal: new w("division_equal", A.token, "/="),
+    modulo_equal: new w("modulo_equal", A.token, "%="),
+    and_equal: new w("and_equal", A.token, "&="),
+    or_equal: new w("or_equal", A.token, "|="),
+    xor_equal: new w("xor_equal", A.token, "^="),
+    shift_right_equal: new w("shift_right_equal", A.token, ">>="),
+    shift_left_equal: new w("shift_left_equal", A.token, "<<=")
+};
+g.storage_class = [M.keywords.function, M.keywords.private, M.keywords.workgroup, M.keywords.uniform, M.keywords.storage];
+g.access_mode = [M.keywords.read, M.keywords.write, M.keywords.read_write];
+g.sampler_type = [M.keywords.sampler, M.keywords.sampler_comparison];
+g.sampled_texture_type = [M.keywords.texture_1d, M.keywords.texture_2d, M.keywords.texture_2d_array, M.keywords.texture_3d, M.keywords.texture_cube, M.keywords.texture_cube_array];
+g.multisampled_texture_type = [M.keywords.texture_multisampled_2d];
+g.storage_texture_type = [M.keywords.texture_storage_1d, M.keywords.texture_storage_2d, M.keywords.texture_storage_2d_array, M.keywords.texture_storage_3d];
+g.depth_texture_type = [M.keywords.texture_depth_2d, M.keywords.texture_depth_2d_array, M.keywords.texture_depth_cube, M.keywords.texture_depth_cube_array, M.keywords.texture_depth_multisampled_2d];
+g.texture_external_type = [M.keywords.texture_external];
+g.any_texture_type = [...M.sampled_texture_type, ...M.multisampled_texture_type, ...M.storage_texture_type, ...M.depth_texture_type, ...M.texture_external_type];
+g.texel_format = [M.keywords.r8unorm, M.keywords.r8snorm, M.keywords.r8uint, M.keywords.r8sint, M.keywords.r16uint, M.keywords.r16sint, M.keywords.r16float, M.keywords.rg8unorm, M.keywords.rg8snorm, M.keywords.rg8uint, M.keywords.rg8sint, M.keywords.r32uint, M.keywords.r32sint, M.keywords.r32float, M.keywords.rg16uint, M.keywords.rg16sint, M.keywords.rg16float, M.keywords.rgba8unorm, M.keywords.rgba8unorm_srgb, M.keywords.rgba8snorm, M.keywords.rgba8uint, M.keywords.rgba8sint, M.keywords.bgra8unorm, M.keywords.bgra8unorm_srgb, M.keywords.rgb10a2unorm, M.keywords.rg11b10float, M.keywords.rg32uint, M.keywords.rg32sint, M.keywords.rg32float, M.keywords.rgba16uint, M.keywords.rgba16sint, M.keywords.rgba16float, M.keywords.rgba32uint, M.keywords.rgba32sint, M.keywords.rgba32float];
+g.const_literal = [M.tokens.int_literal, M.tokens.uint_literal, M.tokens.decimal_float_literal, M.tokens.hex_float_literal, M.keywords.true, M.keywords.false];
+g.literal_or_ident = [M.tokens.ident, M.tokens.int_literal, M.tokens.uint_literal, M.tokens.decimal_float_literal, M.tokens.hex_float_literal];
+g.element_count_expression = [M.tokens.int_literal, M.tokens.uint_literal, M.tokens.ident];
+g.template_types = [M.keywords.vec2, M.keywords.vec3, M.keywords.vec4, M.keywords.mat2x2, M.keywords.mat2x3, M.keywords.mat2x4, M.keywords.mat3x2, M.keywords.mat3x3, M.keywords.mat3x4, M.keywords.mat4x2, M.keywords.mat4x3, M.keywords.mat4x4, M.keywords.atomic, M.keywords.bitcast, ...M.any_texture_type];
+g.attribute_name = [M.tokens.ident, M.keywords.block];
+g.assignment_operators = [M.tokens.equal, M.tokens.plus_equal, M.tokens.minus_equal, M.tokens.times_equal, M.tokens.division_equal, M.tokens.modulo_equal, M.tokens.and_equal, M.tokens.or_equal, M.tokens.xor_equal, M.tokens.shift_right_equal, M.tokens.shift_left_equal];
+g.increment_operators = [M.tokens.plus_plus, M.tokens.minus_minus];
+var xo = class {
+        constructor(t, r, s) {
+            this.type = t, this.lexeme = r, this.line = s
         }
         toString() {
             return this.lexeme
         }
         isTemplateType() {
-            return _.template_types.indexOf(this.type) != -1
+            return g.template_types.indexOf(this.type) != -1
         }
         isArrayType() {
-            return this.type == _.keywords.array
+            return this.type == g.keywords.array
         }
         isArrayOrTemplateType() {
             return this.isArrayType() || this.isTemplateType()
         }
     },
-    xl = class {
-        constructor(e) {
-            this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? ""
+    El = class {
+        constructor(t) {
+            this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = t ?? ""
         }
         scanTokens() {
             for (; !this._isAtEnd();)
                 if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
-            return this._tokens.push(new So(_.eof, "", this._line)), this._tokens
+            return this._tokens.push(new xo(g.eof, "", this._line)), this._tokens
         }
         scanToken() {
-            let e = this._advance();
-            if (e == `
+            let t = this._advance();
+            if (t == `
 `) return this._line++, !0;
-            if (this._isWhitespace(e)) return !0;
-            if (e == "/") {
+            if (this._isWhitespace(t)) return !0;
+            if (t == "/") {
                 if (this._peekAhead() == "/") {
-                    for (; e != `
+                    for (; t != `
 `;) {
                         if (this._isAtEnd()) return !0;
-                        e = this._advance()
+                        t = this._advance()
                     }
                     return this._line++, !0
                 } else if (this._peekAhead() == "*") {
                     this._advance();
                     let s = 1;
                     for (; s > 0;) {
                         if (this._isAtEnd()) return !0;
-                        if (e = this._advance(), e == `
+                        if (t = this._advance(), t == `
 `) this._line++;
-                        else if (e == "*") {
+                        else if (t == "*") {
                             if (this._peekAhead() == "/" && (this._advance(), s--, s == 0)) return !0
-                        } else e == "/" && this._peekAhead() == "*" && (this._advance(), s++)
+                        } else t == "/" && this._peekAhead() == "*" && (this._advance(), s++)
                     }
                     return !0
                 }
             }
-            let r = _.none;
+            let r = g.none;
             for (;;) {
-                let s = this._findType(e),
+                let s = this._findType(t),
                     i = this._peekAhead();
-                if (e == ">" && (i == ">" || i == "=")) {
+                if (t == ">" && (i == ">" || i == "=")) {
                     let n = !1,
                         o = this._tokens.length - 1;
                     for (let a = 0; a < 5 && o >= 0; ++a, --o)
-                        if (this._tokens[o].type === _.tokens.less_than) {
+                        if (this._tokens[o].type === g.tokens.less_than) {
                             o > 0 && this._tokens[o - 1].isArrayOrTemplateType() && (n = !0);
                             break
                         } if (n) return this._addToken(s), !0
                 }
-                if (s === _.none) {
-                    let n = e,
+                if (s === g.none) {
+                    let n = t,
                         o = 0,
                         a = 2;
                     for (let c = 0; c < a; ++c)
-                        if (n += this._peekAhead(c), s = this._findType(n), s !== _.none) {
+                        if (n += this._peekAhead(c), s = this._findType(n), s !== g.none) {
                             o = c;
                             break
-                        } if (s === _.none) return r === _.none ? !1 : (this._current--, this._addToken(r), !0);
-                    e = n, this._current += o + 1
+                        } if (s === g.none) return r === g.none ? !1 : (this._current--, this._addToken(r), !0);
+                    t = n, this._current += o + 1
                 }
                 if (r = s, this._isAtEnd()) break;
-                e += this._advance()
+                t += this._advance()
             }
-            return r === _.none ? !1 : (this._addToken(r), !0)
+            return r === g.none ? !1 : (this._addToken(r), !0)
         }
-        _findType(e) {
-            for (let r in _.keywords) {
-                let s = _.keywords[r];
-                if (this._match(e, s.rule)) return s
+        _findType(t) {
+            for (let r in g.keywords) {
+                let s = g.keywords[r];
+                if (this._match(t, s.rule)) return s
             }
-            for (let r in _.tokens) {
-                let s = _.tokens[r];
-                if (this._match(e, s.rule)) return s
+            for (let r in g.tokens) {
+                let s = g.tokens[r];
+                if (this._match(t, s.rule)) return s
             }
-            return _.none
+            return g.none
         }
-        _match(e, r) {
+        _match(t, r) {
             if (typeof r == "string") {
-                if (r == e) return !0
+                if (r == t) return !0
             } else {
-                let s = r.exec(e);
-                if (s && s.index == 0 && s[0] == e) return !0
+                let s = r.exec(t);
+                if (s && s.index == 0 && s[0] == t) return !0
             }
             return !1
         }
         _isAtEnd() {
             return this._current >= this._source.length
         }
-        _isWhitespace(e) {
-            return e == " " || e == "	" || e == "\r"
+        _isWhitespace(t) {
+            return t == " " || t == "	" || t == "\r"
         }
-        _advance(e = 0) {
+        _advance(t = 0) {
             let r = this._source[this._current];
-            return e = e || 0, e++, this._current += e, r
+            return t = t || 0, t++, this._current += t, r
         }
-        _peekAhead(e = 0) {
-            return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e]
+        _peekAhead(t = 0) {
+            return t = t || 0, this._current + t >= this._source.length ? "\0" : this._source[this._current + t]
         }
-        _addToken(e) {
+        _addToken(t) {
             let r = this._source.substring(this._start, this._current);
-            this._tokens.push(new So(e, r, this._line))
+            this._tokens.push(new xo(t, r, this._line))
         }
     },
-    Sl = class {
+    xl = class {
         constructor() {
             this._tokens = [], this._current = 0, this._context = new Zc
         }
-        parse(e) {
-            this._initialize(e);
+        parse(t) {
+            this._initialize(t);
             let r = [];
             for (; !this._isAtEnd();) {
                 let s = this._global_decl_or_directive();
                 if (!s) break;
                 r.push(s)
             }
             return r
         }
-        _initialize(e) {
-            if (e)
-                if (typeof e == "string") {
-                    let r = new xl(e);
+        _initialize(t) {
+            if (t)
+                if (typeof t == "string") {
+                    let r = new El(t);
                     this._tokens = r.scanTokens()
-                } else this._tokens = e;
+                } else this._tokens = t;
             else this._tokens = [];
             this._current = 0
         }
-        _error(e, r) {
-            return console.error(e, r), {
-                token: e,
+        _error(t, r) {
+            return console.error(t, r), {
+                token: t,
                 message: r,
                 toString: function() {
                     return `${r}`
                 }
             }
         }
         _isAtEnd() {
-            return this._current >= this._tokens.length || this._peek().type == _.eof
+            return this._current >= this._tokens.length || this._peek().type == g.eof
         }
-        _match(e) {
-            if (e instanceof E) return this._check(e) ? (this._advance(), !0) : !1;
-            for (let r = 0, s = e.length; r < s; ++r) {
-                let i = e[r];
+        _match(t) {
+            if (t instanceof w) return this._check(t) ? (this._advance(), !0) : !1;
+            for (let r = 0, s = t.length; r < s; ++r) {
+                let i = t[r];
                 if (this._check(i)) return this._advance(), !0
             }
             return !1
         }
-        _consume(e, r) {
-            if (this._check(e)) return this._advance();
+        _consume(t, r) {
+            if (this._check(t)) return this._advance();
             throw this._error(this._peek(), r)
         }
-        _check(e) {
+        _check(t) {
             if (this._isAtEnd()) return !1;
             let r = this._peek();
-            if (e instanceof Array) {
+            if (t instanceof Array) {
                 let s = r.type;
-                return e.indexOf(s) != -1
+                return t.indexOf(s) != -1
             }
-            return r.type == e
+            return r.type == t
         }
         _advance() {
             return this._isAtEnd() || this._current++, this._previous()
         }
         _peek() {
             return this._tokens[this._current]
         }
         _previous() {
             return this._tokens[this._current - 1]
         }
         _global_decl_or_directive() {
-            for (; this._match(_.tokens.semicolon) && !this._isAtEnd(););
-            if (this._match(_.keywords.alias)) {
+            for (; this._match(g.tokens.semicolon) && !this._isAtEnd(););
+            if (this._match(g.keywords.alias)) {
                 let r = this._type_alias();
-                return this._consume(_.tokens.semicolon, "Expected ';'"), r
+                return this._consume(g.tokens.semicolon, "Expected ';'"), r
             }
-            if (this._match(_.keywords.enable)) {
+            if (this._match(g.keywords.enable)) {
                 let r = this._enable_directive();
-                return this._consume(_.tokens.semicolon, "Expected ';'"), r
+                return this._consume(g.tokens.semicolon, "Expected ';'"), r
             }
-            let e = this._attribute();
-            if (this._check(_.keywords.var)) {
+            let t = this._attribute();
+            if (this._check(g.keywords.var)) {
                 let r = this._global_variable_decl();
-                return r != null && (r.attributes = e), this._consume(_.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(g.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(_.keywords.override)) {
+            if (this._check(g.keywords.override)) {
                 let r = this._override_variable_decl();
-                return r != null && (r.attributes = e), this._consume(_.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(g.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(_.keywords.let)) {
+            if (this._check(g.keywords.let)) {
                 let r = this._global_let_decl();
-                return r != null && (r.attributes = e), this._consume(_.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(g.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(_.keywords.const)) {
+            if (this._check(g.keywords.const)) {
                 let r = this._global_const_decl();
-                return r != null && (r.attributes = e), this._consume(_.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(g.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(_.keywords.struct)) {
+            if (this._check(g.keywords.struct)) {
                 let r = this._struct_decl();
-                return r != null && (r.attributes = e), r
+                return r != null && (r.attributes = t), r
             }
-            if (this._check(_.keywords.fn)) {
+            if (this._check(g.keywords.fn)) {
                 let r = this._function_decl();
-                return r != null && (r.attributes = e), r
+                return r != null && (r.attributes = t), r
             }
             return null
         }
         _function_decl() {
-            if (!this._match(_.keywords.fn)) return null;
-            let e = this._consume(_.tokens.ident, "Expected function name.").toString();
-            this._consume(_.tokens.paren_left, "Expected '(' for function arguments.");
+            if (!this._match(g.keywords.fn)) return null;
+            let t = this._consume(g.tokens.ident, "Expected function name.").toString();
+            this._consume(g.tokens.paren_left, "Expected '(' for function arguments.");
             let r = [];
-            if (!this._check(_.tokens.paren_right))
+            if (!this._check(g.tokens.paren_right))
                 do {
-                    if (this._check(_.tokens.paren_right)) break;
+                    if (this._check(g.tokens.paren_right)) break;
                     let n = this._attribute(),
-                        o = this._consume(_.tokens.ident, "Expected argument name.").toString();
-                    this._consume(_.tokens.colon, "Expected ':' for argument type.");
+                        o = this._consume(g.tokens.ident, "Expected argument name.").toString();
+                    this._consume(g.tokens.colon, "Expected ':' for argument type.");
                     let a = this._attribute(),
                         c = this._type_decl();
-                    c != null && (c.attributes = a, r.push(new bl(o, c, n)))
-                } while (this._match(_.tokens.comma));
-            this._consume(_.tokens.paren_right, "Expected ')' after function arguments.");
+                    c != null && (c.attributes = a, r.push(new Tl(o, c, n)))
+                } while (this._match(g.tokens.comma));
+            this._consume(g.tokens.paren_right, "Expected ')' after function arguments.");
             let s = null;
-            if (this._match(_.tokens.arrow)) {
+            if (this._match(g.tokens.arrow)) {
                 let n = this._attribute();
                 s = this._type_decl(), s != null && (s.attributes = n)
             }
             let i = this._compound_statement();
-            return new lo(e, r, s, i)
+            return new lo(t, r, s, i)
         }
         _compound_statement() {
-            let e = [];
-            for (this._consume(_.tokens.brace_left, "Expected '{' for block."); !this._check(_.tokens.brace_right);) {
+            let t = [];
+            for (this._consume(g.tokens.brace_left, "Expected '{' for block."); !this._check(g.tokens.brace_right);) {
                 let r = this._statement();
-                r !== null && e.push(r)
+                r !== null && t.push(r)
             }
-            return this._consume(_.tokens.brace_right, "Expected '}' for block."), e
+            return this._consume(g.tokens.brace_right, "Expected '}' for block."), t
         }
         _statement() {
-            for (; this._match(_.tokens.semicolon) && !this._isAtEnd(););
-            if (this._check(_.keywords.if)) return this._if_statement();
-            if (this._check(_.keywords.switch)) return this._switch_statement();
-            if (this._check(_.keywords.loop)) return this._loop_statement();
-            if (this._check(_.keywords.for)) return this._for_statement();
-            if (this._check(_.keywords.while)) return this._while_statement();
-            if (this._check(_.keywords.continuing)) return this._continuing_statement();
-            if (this._check(_.keywords.static_assert)) return this._static_assert_statement();
-            if (this._check(_.tokens.brace_left)) return this._compound_statement();
-            let e = null;
-            return this._check(_.keywords.return) ? e = this._return_statement() : this._check([_.keywords.var, _.keywords.let, _.keywords.const]) ? e = this._variable_statement() : this._match(_.keywords.discard) ? e = new ll : this._match(_.keywords.break) ? e = new hl : this._match(_.keywords.continue) ? e = new fl : e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), e != null && this._consume(_.tokens.semicolon, "Expected ';' after statement."), e
+            for (; this._match(g.tokens.semicolon) && !this._isAtEnd(););
+            if (this._check(g.keywords.if)) return this._if_statement();
+            if (this._check(g.keywords.switch)) return this._switch_statement();
+            if (this._check(g.keywords.loop)) return this._loop_statement();
+            if (this._check(g.keywords.for)) return this._for_statement();
+            if (this._check(g.keywords.while)) return this._while_statement();
+            if (this._check(g.keywords.continuing)) return this._continuing_statement();
+            if (this._check(g.keywords.static_assert)) return this._static_assert_statement();
+            if (this._check(g.tokens.brace_left)) return this._compound_statement();
+            let t = null;
+            return this._check(g.keywords.return) ? t = this._return_statement() : this._check([g.keywords.var, g.keywords.let, g.keywords.const]) ? t = this._variable_statement() : this._match(g.keywords.discard) ? t = new ll : this._match(g.keywords.break) ? t = new fl : this._match(g.keywords.continue) ? t = new hl : t = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), t != null && this._consume(g.tokens.semicolon, "Expected ';' after statement."), t
         }
         _static_assert_statement() {
-            if (!this._match(_.keywords.static_assert)) return null;
-            let e = this._optional_paren_expression();
-            return new Qc(e)
+            if (!this._match(g.keywords.static_assert)) return null;
+            let t = this._optional_paren_expression();
+            return new Qc(t)
         }
         _while_statement() {
-            if (!this._match(_.keywords.while)) return null;
-            let e = this._optional_paren_expression(),
+            if (!this._match(g.keywords.while)) return null;
+            let t = this._optional_paren_expression(),
                 r = this._compound_statement();
-            return new Jc(e, r)
+            return new Jc(t, r)
         }
         _continuing_statement() {
-            if (!this._match(_.keywords.continuing)) return null;
-            let e = this._compound_statement();
-            return new Gc(e)
+            if (!this._match(g.keywords.continuing)) return null;
+            let t = this._compound_statement();
+            return new Gc(t)
         }
         _for_statement() {
-            if (!this._match(_.keywords.for)) return null;
-            this._consume(_.tokens.paren_left, "Expected '('.");
-            let e = this._check(_.tokens.semicolon) ? null : this._for_init();
-            this._consume(_.tokens.semicolon, "Expected ';'.");
-            let r = this._check(_.tokens.semicolon) ? null : this._short_circuit_or_expression();
-            this._consume(_.tokens.semicolon, "Expected ';'.");
-            let s = this._check(_.tokens.paren_right) ? null : this._for_increment();
-            this._consume(_.tokens.paren_right, "Expected ')'.");
+            if (!this._match(g.keywords.for)) return null;
+            this._consume(g.tokens.paren_left, "Expected '('.");
+            let t = this._check(g.tokens.semicolon) ? null : this._for_init();
+            this._consume(g.tokens.semicolon, "Expected ';'.");
+            let r = this._check(g.tokens.semicolon) ? null : this._short_circuit_or_expression();
+            this._consume(g.tokens.semicolon, "Expected ';'.");
+            let s = this._check(g.tokens.paren_right) ? null : this._for_increment();
+            this._consume(g.tokens.paren_right, "Expected ')'.");
             let i = this._compound_statement();
-            return new el(e, r, s, i)
+            return new tl(t, r, s, i)
         }
         _for_init() {
             return this._variable_statement() || this._func_call_statement() || this._assignment_statement()
         }
         _for_increment() {
             return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement()
         }
         _variable_statement() {
-            if (this._check(_.keywords.var)) {
-                let e = this._variable_decl();
-                if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
+            if (this._check(g.keywords.var)) {
+                let t = this._variable_decl();
+                if (t === null) throw this._error(this._peek(), "Variable declaration expected.");
                 let r = null;
-                return this._match(_.tokens.equal) && (r = this._short_circuit_or_expression()), new Ht(e.name, e.type, e.storage, e.access, r)
+                return this._match(g.tokens.equal) && (r = this._short_circuit_or_expression()), new je(t.name, t.type, t.storage, t.access, r)
             }
-            if (this._match(_.keywords.let)) {
-                let e = this._consume(_.tokens.ident, "Expected name for let.").toString(),
+            if (this._match(g.keywords.let)) {
+                let t = this._consume(g.tokens.ident, "Expected name for let.").toString(),
                     r = null;
-                if (this._match(_.tokens.colon)) {
+                if (this._match(g.tokens.colon)) {
                     let i = this._attribute();
                     r = this._type_decl(), r != null && (r.attributes = i)
                 }
-                this._consume(_.tokens.equal, "Expected '=' for let.");
+                this._consume(g.tokens.equal, "Expected '=' for let.");
                 let s = this._short_circuit_or_expression();
-                return new fo(e, r, null, null, s)
+                return new ho(t, r, null, null, s)
             }
-            if (this._match(_.keywords.const)) {
-                let e = this._consume(_.tokens.ident, "Expected name for const.").toString(),
+            if (this._match(g.keywords.const)) {
+                let t = this._consume(g.tokens.ident, "Expected name for const.").toString(),
                     r = null;
-                if (this._match(_.tokens.colon)) {
+                if (this._match(g.tokens.colon)) {
                     let i = this._attribute();
                     r = this._type_decl(), r != null && (r.attributes = i)
                 }
-                this._consume(_.tokens.equal, "Expected '=' for const.");
+                this._consume(g.tokens.equal, "Expected '=' for const.");
                 let s = this._short_circuit_or_expression();
-                return new uo(e, r, null, null, s)
+                return new uo(t, r, null, null, s)
             }
             return null
         }
         _increment_decrement_statement() {
-            let e = this._current,
+            let t = this._current,
                 r = this._unary_expression();
             if (r == null) return null;
-            if (!this._check(_.increment_operators)) return this._current = e, null;
-            let s = this._consume(_.increment_operators, "Expected increment operator");
-            return new tl(s.type === _.tokens.plus_plus ? ts.increment : ts.decrement, r)
+            if (!this._check(g.increment_operators)) return this._current = t, null;
+            let s = this._consume(g.increment_operators, "Expected increment operator");
+            return new el(s.type === g.tokens.plus_plus ? es.increment : es.decrement, r)
         }
         _assignment_statement() {
-            let e = null;
-            if (this._check(_.tokens.brace_right)) return null;
-            let r = this._match(_.tokens.underscore);
-            if (r || (e = this._unary_expression()), !r && e == null) return null;
-            let s = this._consume(_.assignment_operators, "Expected assignment operator."),
+            let t = null;
+            if (this._check(g.tokens.brace_right)) return null;
+            let r = this._match(g.tokens.underscore);
+            if (r || (t = this._unary_expression()), !r && t == null) return null;
+            let s = this._consume(g.assignment_operators, "Expected assignment operator."),
                 i = this._short_circuit_or_expression();
-            return new rl(gi.parse(s.lexeme), e, i)
+            return new rl(_i.parse(s.lexeme), t, i)
         }
         _func_call_statement() {
-            if (!this._check(_.tokens.ident)) return null;
-            let e = this._current,
-                r = this._consume(_.tokens.ident, "Expected function name."),
+            if (!this._check(g.tokens.ident)) return null;
+            let t = this._current,
+                r = this._consume(g.tokens.ident, "Expected function name."),
                 s = this._argument_expression_list();
-            return s === null ? (this._current = e, null) : new sl(r.lexeme, s)
+            return s === null ? (this._current = t, null) : new sl(r.lexeme, s)
         }
         _loop_statement() {
-            if (!this._match(_.keywords.loop)) return null;
-            this._consume(_.tokens.brace_left, "Expected '{' for loop.");
-            let e = [],
+            if (!this._match(g.keywords.loop)) return null;
+            this._consume(g.tokens.brace_left, "Expected '{' for loop.");
+            let t = [],
                 r = this._statement();
             for (; r !== null;) {
                 if (Array.isArray(r))
-                    for (let i of r) e.push(i);
-                else e.push(r);
+                    for (let i of r) t.push(i);
+                else t.push(r);
                 r = this._statement()
             }
             let s = null;
-            return this._match(_.keywords.continuing) && (s = this._compound_statement()), this._consume(_.tokens.brace_right, "Expected '}' for loop."), new il(e, s)
+            return this._match(g.keywords.continuing) && (s = this._compound_statement()), this._consume(g.tokens.brace_right, "Expected '}' for loop."), new il(t, s)
         }
         _switch_statement() {
-            if (!this._match(_.keywords.switch)) return null;
-            let e = this._optional_paren_expression();
-            this._consume(_.tokens.brace_left, "Expected '{' for switch.");
+            if (!this._match(g.keywords.switch)) return null;
+            let t = this._optional_paren_expression();
+            this._consume(g.tokens.brace_left, "Expected '{' for switch.");
             let r = this._switch_body();
             if (r == null || r.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
-            return this._consume(_.tokens.brace_right, "Expected '}' for switch."), new nl(e, r)
+            return this._consume(g.tokens.brace_right, "Expected '}' for switch."), new nl(t, r)
         }
         _switch_body() {
-            let e = [];
-            if (this._match(_.keywords.case)) {
+            let t = [];
+            if (this._match(g.keywords.case)) {
                 let r = this._case_selectors();
-                this._match(_.tokens.colon), this._consume(_.tokens.brace_left, "Exected '{' for switch case.");
+                this._match(g.tokens.colon), this._consume(g.tokens.brace_left, "Exected '{' for switch case.");
                 let s = this._case_body();
-                this._consume(_.tokens.brace_right, "Exected '}' for switch case."), e.push(new Tl(r, s))
+                this._consume(g.tokens.brace_right, "Exected '}' for switch case."), t.push(new bl(r, s))
             }
-            if (this._match(_.keywords.default)) {
-                this._match(_.tokens.colon), this._consume(_.tokens.brace_left, "Exected '{' for switch default.");
+            if (this._match(g.keywords.default)) {
+                this._match(g.tokens.colon), this._consume(g.tokens.brace_left, "Exected '{' for switch default.");
                 let r = this._case_body();
-                this._consume(_.tokens.brace_right, "Exected '}' for switch default."), e.push(new yl(r))
+                this._consume(g.tokens.brace_right, "Exected '}' for switch default."), t.push(new yl(r))
             }
-            if (this._check([_.keywords.default, _.keywords.case])) {
+            if (this._check([g.keywords.default, g.keywords.case])) {
                 let r = this._switch_body();
-                e.push(r[0])
+                t.push(r[0])
             }
-            return e
+            return t
         }
         _case_selectors() {
-            var e, r, s, i;
-            let n = [(r = (e = this._shift_expression()) === null || e === void 0 ? void 0 : e.evaluate(this._context).toString()) !== null && r !== void 0 ? r : ""];
-            for (; this._match(_.tokens.comma);) n.push((i = (s = this._shift_expression()) === null || s === void 0 ? void 0 : s.evaluate(this._context).toString()) !== null && i !== void 0 ? i : "");
+            var t, r, s, i;
+            let n = [(r = (t = this._shift_expression()) === null || t === void 0 ? void 0 : t.evaluate(this._context).toString()) !== null && r !== void 0 ? r : ""];
+            for (; this._match(g.tokens.comma);) n.push((i = (s = this._shift_expression()) === null || s === void 0 ? void 0 : s.evaluate(this._context).toString()) !== null && i !== void 0 ? i : "");
             return n
         }
         _case_body() {
-            if (this._match(_.keywords.fallthrough)) return this._consume(_.tokens.semicolon, "Expected ';'"), [];
-            let e = this._statement();
-            if (e == null) return [];
-            e instanceof Array || (e = [e]);
+            if (this._match(g.keywords.fallthrough)) return this._consume(g.tokens.semicolon, "Expected ';'"), [];
+            let t = this._statement();
+            if (t == null) return [];
+            t instanceof Array || (t = [t]);
             let r = this._case_body();
-            return r.length == 0 ? e : [...e, r[0]]
+            return r.length == 0 ? t : [...t, r[0]]
         }
         _if_statement() {
-            if (!this._match(_.keywords.if)) return null;
-            let e = this._optional_paren_expression(),
+            if (!this._match(g.keywords.if)) return null;
+            let t = this._optional_paren_expression(),
                 r = this._compound_statement(),
                 s = [];
             this._match_elseif() && (s = this._elseif_statement(s));
             let i = null;
-            return this._match(_.keywords.else) && (i = this._compound_statement()), new ol(e, r, s, i)
+            return this._match(g.keywords.else) && (i = this._compound_statement()), new ol(t, r, s, i)
         }
         _match_elseif() {
-            return this._tokens[this._current].type === _.keywords.else && this._tokens[this._current + 1].type === _.keywords.if ? (this._advance(), this._advance(), !0) : !1
+            return this._tokens[this._current].type === g.keywords.else && this._tokens[this._current + 1].type === g.keywords.if ? (this._advance(), this._advance(), !0) : !1
         }
-        _elseif_statement(e = []) {
+        _elseif_statement(t = []) {
             let r = this._optional_paren_expression(),
                 s = this._compound_statement();
-            return e.push(new El(r, s)), this._match_elseif() && this._elseif_statement(e), e
+            return t.push(new wl(r, s)), this._match_elseif() && this._elseif_statement(t), t
         }
         _return_statement() {
-            if (!this._match(_.keywords.return)) return null;
-            let e = this._short_circuit_or_expression();
-            return new al(e)
+            if (!this._match(g.keywords.return)) return null;
+            let t = this._short_circuit_or_expression();
+            return new al(t)
         }
         _short_circuit_or_expression() {
-            let e = this._short_circuit_and_expr();
-            for (; this._match(_.tokens.or_or);) e = new Be(this._previous().toString(), e, this._short_circuit_and_expr());
-            return e
+            let t = this._short_circuit_and_expr();
+            for (; this._match(g.tokens.or_or);) t = new Bt(this._previous().toString(), t, this._short_circuit_and_expr());
+            return t
         }
         _short_circuit_and_expr() {
-            let e = this._inclusive_or_expression();
-            for (; this._match(_.tokens.and_and);) e = new Be(this._previous().toString(), e, this._inclusive_or_expression());
-            return e
+            let t = this._inclusive_or_expression();
+            for (; this._match(g.tokens.and_and);) t = new Bt(this._previous().toString(), t, this._inclusive_or_expression());
+            return t
         }
         _inclusive_or_expression() {
-            let e = this._exclusive_or_expression();
-            for (; this._match(_.tokens.or);) e = new Be(this._previous().toString(), e, this._exclusive_or_expression());
-            return e
+            let t = this._exclusive_or_expression();
+            for (; this._match(g.tokens.or);) t = new Bt(this._previous().toString(), t, this._exclusive_or_expression());
+            return t
         }
         _exclusive_or_expression() {
-            let e = this._and_expression();
-            for (; this._match(_.tokens.xor);) e = new Be(this._previous().toString(), e, this._and_expression());
-            return e
+            let t = this._and_expression();
+            for (; this._match(g.tokens.xor);) t = new Bt(this._previous().toString(), t, this._and_expression());
+            return t
         }
         _and_expression() {
-            let e = this._equality_expression();
-            for (; this._match(_.tokens.and);) e = new Be(this._previous().toString(), e, this._equality_expression());
-            return e
+            let t = this._equality_expression();
+            for (; this._match(g.tokens.and);) t = new Bt(this._previous().toString(), t, this._equality_expression());
+            return t
         }
         _equality_expression() {
-            let e = this._relational_expression();
-            return this._match([_.tokens.equal_equal, _.tokens.not_equal]) ? new Be(this._previous().toString(), e, this._relational_expression()) : e
+            let t = this._relational_expression();
+            return this._match([g.tokens.equal_equal, g.tokens.not_equal]) ? new Bt(this._previous().toString(), t, this._relational_expression()) : t
         }
         _relational_expression() {
-            let e = this._shift_expression();
-            for (; this._match([_.tokens.less_than, _.tokens.greater_than, _.tokens.less_than_equal, _.tokens.greater_than_equal]);) e = new Be(this._previous().toString(), e, this._shift_expression());
-            return e
+            let t = this._shift_expression();
+            for (; this._match([g.tokens.less_than, g.tokens.greater_than, g.tokens.less_than_equal, g.tokens.greater_than_equal]);) t = new Bt(this._previous().toString(), t, this._shift_expression());
+            return t
         }
         _shift_expression() {
-            let e = this._additive_expression();
-            for (; this._match([_.tokens.shift_left, _.tokens.shift_right]);) e = new Be(this._previous().toString(), e, this._additive_expression());
-            return e
+            let t = this._additive_expression();
+            for (; this._match([g.tokens.shift_left, g.tokens.shift_right]);) t = new Bt(this._previous().toString(), t, this._additive_expression());
+            return t
         }
         _additive_expression() {
-            let e = this._multiplicative_expression();
-            for (; this._match([_.tokens.plus, _.tokens.minus]);) e = new Be(this._previous().toString(), e, this._multiplicative_expression());
-            return e
+            let t = this._multiplicative_expression();
+            for (; this._match([g.tokens.plus, g.tokens.minus]);) t = new Bt(this._previous().toString(), t, this._multiplicative_expression());
+            return t
         }
         _multiplicative_expression() {
-            let e = this._unary_expression();
-            for (; this._match([_.tokens.star, _.tokens.forward_slash, _.tokens.modulo]);) e = new Be(this._previous().toString(), e, this._unary_expression());
-            return e
+            let t = this._unary_expression();
+            for (; this._match([g.tokens.star, g.tokens.forward_slash, g.tokens.modulo]);) t = new Bt(this._previous().toString(), t, this._unary_expression());
+            return t
         }
         _unary_expression() {
-            return this._match([_.tokens.minus, _.tokens.bang, _.tokens.tilde, _.tokens.star, _.tokens.and]) ? new ml(this._previous().toString(), this._unary_expression()) : this._singular_expression()
+            return this._match([g.tokens.minus, g.tokens.bang, g.tokens.tilde, g.tokens.star, g.tokens.and]) ? new ml(this._previous().toString(), this._unary_expression()) : this._singular_expression()
         }
         _singular_expression() {
-            let e = this._primary_expression(),
+            let t = this._primary_expression(),
                 r = this._postfix_expression();
-            return r && (e.postfix = r), e
+            return r && (t.postfix = r), t
         }
         _postfix_expression() {
-            if (this._match(_.tokens.bracket_left)) {
-                let e = this._short_circuit_or_expression();
-                this._consume(_.tokens.bracket_right, "Expected ']'.");
+            if (this._match(g.tokens.bracket_left)) {
+                let t = this._short_circuit_or_expression();
+                this._consume(g.tokens.bracket_right, "Expected ']'.");
                 let r = this._postfix_expression();
-                return r && (e.postfix = r), e
+                return r && (t.postfix = r), t
             }
-            if (this._match(_.tokens.period)) {
-                let e = this._consume(_.tokens.ident, "Expected member name."),
+            if (this._match(g.tokens.period)) {
+                let t = this._consume(g.tokens.ident, "Expected member name."),
                     r = this._postfix_expression(),
-                    s = new mo(e.lexeme);
+                    s = new mo(t.lexeme);
                 return r && (s.postfix = r), s
             }
             return null
         }
-        _getStruct(e) {
-            return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null
+        _getStruct(t) {
+            return this._context.aliases.has(t) ? this._context.aliases.get(t).type : this._context.structs.has(t) ? this._context.structs.get(t) : null
         }
         _primary_expression() {
-            if (this._match(_.tokens.ident)) {
+            if (this._match(g.tokens.ident)) {
                 let s = this._previous().toString();
-                if (this._check(_.tokens.paren_left)) {
+                if (this._check(g.tokens.paren_left)) {
                     let i = this._argument_expression_list(),
                         n = this._getStruct(s);
-                    return n != null ? new wr(n, i) : new dl(s, i)
+                    return n != null ? new Sr(n, i) : new dl(s, i)
                 }
                 if (this._context.constants.has(s)) {
                     let i = this._context.constants.get(s);
-                    return new To(s, i.value)
+                    return new bo(s, i.value)
                 }
                 return new pl(s)
             }
-            if (this._match(_.const_literal)) return new yo(parseFloat(this._previous().toString()));
-            if (this._check(_.tokens.paren_left)) return this._paren_expression();
-            if (this._match(_.keywords.bitcast)) {
-                this._consume(_.tokens.less_than, "Expected '<'.");
+            if (this._match(g.const_literal)) return new yo(parseFloat(this._previous().toString()));
+            if (this._check(g.tokens.paren_left)) return this._paren_expression();
+            if (this._match(g.keywords.bitcast)) {
+                this._consume(g.tokens.less_than, "Expected '<'.");
                 let s = this._type_decl();
-                this._consume(_.tokens.greater_than, "Expected '>'.");
+                this._consume(g.tokens.greater_than, "Expected '>'.");
                 let i = this._paren_expression();
-                return new gl(s, i)
+                return new _l(s, i)
             }
-            let e = this._type_decl(),
+            let t = this._type_decl(),
                 r = this._argument_expression_list();
-            return new _l(e, r)
+            return new gl(t, r)
         }
         _argument_expression_list() {
-            if (!this._match(_.tokens.paren_left)) return null;
-            let e = [];
+            if (!this._match(g.tokens.paren_left)) return null;
+            let t = [];
             do {
-                if (this._check(_.tokens.paren_right)) break;
+                if (this._check(g.tokens.paren_right)) break;
                 let r = this._short_circuit_or_expression();
-                e.push(r)
-            } while (this._match(_.tokens.comma));
-            return this._consume(_.tokens.paren_right, "Expected ')' for agument list"), e
+                t.push(r)
+            } while (this._match(g.tokens.comma));
+            return this._consume(g.tokens.paren_right, "Expected ')' for agument list"), t
         }
         _optional_paren_expression() {
-            this._match(_.tokens.paren_left);
-            let e = this._short_circuit_or_expression();
-            return this._match(_.tokens.paren_right), new bo([e])
+            this._match(g.tokens.paren_left);
+            let t = this._short_circuit_or_expression();
+            return this._match(g.tokens.paren_right), new To([t])
         }
         _paren_expression() {
-            this._consume(_.tokens.paren_left, "Expected '('.");
-            let e = this._short_circuit_or_expression();
-            return this._consume(_.tokens.paren_right, "Expected ')'."), new bo([e])
+            this._consume(g.tokens.paren_left, "Expected '('.");
+            let t = this._short_circuit_or_expression();
+            return this._consume(g.tokens.paren_right, "Expected ')'."), new To([t])
         }
         _struct_decl() {
-            if (!this._match(_.keywords.struct)) return null;
-            let e = this._consume(_.tokens.ident, "Expected name for struct.").toString();
-            this._consume(_.tokens.brace_left, "Expected '{' for struct body.");
+            if (!this._match(g.keywords.struct)) return null;
+            let t = this._consume(g.tokens.ident, "Expected name for struct.").toString();
+            this._consume(g.tokens.brace_left, "Expected '{' for struct body.");
             let r = [];
-            for (; !this._check(_.tokens.brace_right);) {
+            for (; !this._check(g.tokens.brace_right);) {
                 let i = this._attribute(),
-                    n = this._consume(_.tokens.ident, "Expected variable name.").toString();
-                this._consume(_.tokens.colon, "Expected ':' for struct member type.");
+                    n = this._consume(g.tokens.ident, "Expected variable name.").toString();
+                this._consume(g.tokens.colon, "Expected ':' for struct member type.");
                 let o = this._attribute(),
                     a = this._type_decl();
-                a != null && (a.attributes = o), this._check(_.tokens.brace_right) ? this._match(_.tokens.comma) : this._consume(_.tokens.comma, "Expected ',' for struct member."), r.push(new Al(n, a, i))
+                a != null && (a.attributes = o), this._check(g.tokens.brace_right) ? this._match(g.tokens.comma) : this._consume(g.tokens.comma, "Expected ',' for struct member."), r.push(new Al(n, a, i))
             }
-            this._consume(_.tokens.brace_right, "Expected '}' after struct body.");
-            let s = new Et(e, r);
-            return this._context.structs.set(e, s), s
+            this._consume(g.tokens.brace_right, "Expected '}' after struct body.");
+            let s = new we(t, r);
+            return this._context.structs.set(t, s), s
         }
         _global_variable_decl() {
-            let e = this._variable_decl();
-            return e && this._match(_.tokens.equal) && (e.value = this._const_expression()), e
+            let t = this._variable_decl();
+            return t && this._match(g.tokens.equal) && (t.value = this._const_expression()), t
         }
         _override_variable_decl() {
-            let e = this._override_decl();
-            return e && this._match(_.tokens.equal) && (e.value = this._const_expression()), e
+            let t = this._override_decl();
+            return t && this._match(g.tokens.equal) && (t.value = this._const_expression()), t
         }
         _global_const_decl() {
-            if (!this._match(_.keywords.const)) return null;
-            let e = this._consume(_.tokens.ident, "Expected variable name"),
+            if (!this._match(g.keywords.const)) return null;
+            let t = this._consume(g.tokens.ident, "Expected variable name"),
                 r = null;
-            if (this._match(_.tokens.colon)) {
+            if (this._match(g.tokens.colon)) {
                 let n = this._attribute();
                 r = this._type_decl(), r != null && (r.attributes = n)
             }
             let s = null;
-            if (this._match(_.tokens.equal)) {
+            if (this._match(g.tokens.equal)) {
                 let n = this._short_circuit_or_expression();
-                if (n instanceof wr) s = n;
-                else if (n instanceof To && n.initializer instanceof wr) s = n.initializer;
+                if (n instanceof Sr) s = n;
+                else if (n instanceof bo && n.initializer instanceof Sr) s = n.initializer;
                 else try {
                     let o = n.evaluate(this._context);
                     s = new yo(o)
                 } catch {
                     s = n
                 }
             }
-            let i = new uo(e.toString(), r, "", "", s);
+            let i = new uo(t.toString(), r, "", "", s);
             return this._context.constants.set(i.name, i), i
         }
         _global_let_decl() {
-            if (!this._match(_.keywords.let)) return null;
-            let e = this._consume(_.tokens.ident, "Expected variable name"),
+            if (!this._match(g.keywords.let)) return null;
+            let t = this._consume(g.tokens.ident, "Expected variable name"),
                 r = null;
-            if (this._match(_.tokens.colon)) {
+            if (this._match(g.tokens.colon)) {
                 let i = this._attribute();
                 r = this._type_decl(), r != null && (r.attributes = i)
             }
             let s = null;
-            return this._match(_.tokens.equal) && (s = this._const_expression()), new fo(e.toString(), r, "", "", s)
+            return this._match(g.tokens.equal) && (s = this._const_expression()), new ho(t.toString(), r, "", "", s)
         }
         _const_expression() {
-            if (this._match(_.const_literal)) return new mo(this._previous().toString());
-            let e = this._type_decl();
-            this._consume(_.tokens.paren_left, "Expected '('.");
+            if (this._match(g.const_literal)) return new mo(this._previous().toString());
+            let t = this._type_decl();
+            this._consume(g.tokens.paren_left, "Expected '('.");
             let r = [];
-            for (; !this._check(_.tokens.paren_right) && (r.push(this._const_expression()), !!this._check(_.tokens.comma));) this._advance();
-            return this._consume(_.tokens.paren_right, "Expected ')'."), new wr(e, r)
+            for (; !this._check(g.tokens.paren_right) && (r.push(this._const_expression()), !!this._check(g.tokens.comma));) this._advance();
+            return this._consume(g.tokens.paren_right, "Expected ')'."), new Sr(t, r)
         }
         _variable_decl() {
-            if (!this._match(_.keywords.var)) return null;
-            let e = "",
+            if (!this._match(g.keywords.var)) return null;
+            let t = "",
                 r = "";
-            this._match(_.tokens.less_than) && (e = this._consume(_.storage_class, "Expected storage_class.").toString(), this._match(_.tokens.comma) && (r = this._consume(_.access_mode, "Expected access_mode.").toString()), this._consume(_.tokens.greater_than, "Expected '>'."));
-            let s = this._consume(_.tokens.ident, "Expected variable name"),
+            this._match(g.tokens.less_than) && (t = this._consume(g.storage_class, "Expected storage_class.").toString(), this._match(g.tokens.comma) && (r = this._consume(g.access_mode, "Expected access_mode.").toString()), this._consume(g.tokens.greater_than, "Expected '>'."));
+            let s = this._consume(g.tokens.ident, "Expected variable name"),
                 i = null;
-            if (this._match(_.tokens.colon)) {
+            if (this._match(g.tokens.colon)) {
                 let n = this._attribute();
                 i = this._type_decl(), i != null && (i.attributes = n)
             }
-            return new Ht(s.toString(), i, e, r, null)
+            return new je(s.toString(), i, t, r, null)
         }
         _override_decl() {
-            if (!this._match(_.keywords.override)) return null;
-            let e = this._consume(_.tokens.ident, "Expected variable name"),
+            if (!this._match(g.keywords.override)) return null;
+            let t = this._consume(g.tokens.ident, "Expected variable name"),
                 r = null;
-            if (this._match(_.tokens.colon)) {
+            if (this._match(g.tokens.colon)) {
                 let s = this._attribute();
                 r = this._type_decl(), r != null && (r.attributes = s)
             }
-            return new ho(e.toString(), r, null)
+            return new fo(t.toString(), r, null)
         }
         _enable_directive() {
-            let e = this._consume(_.tokens.ident, "identity expected.");
-            return new cl(e.toString())
+            let t = this._consume(g.tokens.ident, "identity expected.");
+            return new cl(t.toString())
         }
         _type_alias() {
-            let e = this._consume(_.tokens.ident, "identity expected.");
-            this._consume(_.tokens.equal, "Expected '=' for type alias.");
+            let t = this._consume(g.tokens.ident, "identity expected.");
+            this._consume(g.tokens.equal, "Expected '=' for type alias.");
             let r = this._type_decl();
             if (r === null) throw this._error(this._peek(), "Expected Type for Alias.");
             this._context.aliases.has(r.name) && (r = this._context.aliases.get(r.name).type);
-            let s = new po(e.toString(), r);
+            let s = new po(t.toString(), r);
             return this._context.aliases.set(s.name, s), s
         }
         _type_decl() {
-            if (this._check([_.tokens.ident, ..._.texel_format, _.keywords.bool, _.keywords.f32, _.keywords.i32, _.keywords.u32])) {
+            if (this._check([g.tokens.ident, ...g.texel_format, g.keywords.bool, g.keywords.f32, g.keywords.i32, g.keywords.u32])) {
                 let s = this._advance(),
                     i = s.toString();
-                return this._context.structs.has(i) ? this._context.structs.get(i) : this._context.aliases.has(i) ? this._context.aliases.get(i).type : new xt(s.toString())
+                return this._context.structs.has(i) ? this._context.structs.get(i) : this._context.aliases.has(i) ? this._context.aliases.get(i).type : new Ee(s.toString())
             }
-            let e = this._texture_sampler_types();
-            if (e) return e;
-            if (this._check(_.template_types)) {
+            let t = this._texture_sampler_types();
+            if (t) return t;
+            if (this._check(g.template_types)) {
                 let s = this._advance().toString(),
                     i = null,
                     n = null;
-                return this._match(_.tokens.less_than) && (i = this._type_decl(), n = null, this._match(_.tokens.comma) && (n = this._consume(_.access_mode, "Expected access_mode for pointer").toString()), this._consume(_.tokens.greater_than, "Expected '>' for type.")), new go(s, i, n)
+                return this._match(g.tokens.less_than) && (i = this._type_decl(), n = null, this._match(g.tokens.comma) && (n = this._consume(g.access_mode, "Expected access_mode for pointer").toString()), this._consume(g.tokens.greater_than, "Expected '>' for type.")), new _o(s, i, n)
             }
-            if (this._match(_.keywords.ptr)) {
+            if (this._match(g.keywords.ptr)) {
                 let s = this._previous().toString();
-                this._consume(_.tokens.less_than, "Expected '<' for pointer.");
-                let i = this._consume(_.storage_class, "Expected storage_class for pointer");
-                this._consume(_.tokens.comma, "Expected ',' for pointer.");
+                this._consume(g.tokens.less_than, "Expected '<' for pointer.");
+                let i = this._consume(g.storage_class, "Expected storage_class for pointer");
+                this._consume(g.tokens.comma, "Expected ',' for pointer.");
                 let n = this._type_decl(),
                     o = null;
-                return this._match(_.tokens.comma) && (o = this._consume(_.access_mode, "Expected access_mode for pointer").toString()), this._consume(_.tokens.greater_than, "Expected '>' for pointer."), new ul(s, i.toString(), n, o)
+                return this._match(g.tokens.comma) && (o = this._consume(g.access_mode, "Expected access_mode for pointer").toString()), this._consume(g.tokens.greater_than, "Expected '>' for pointer."), new ul(s, i.toString(), n, o)
             }
             let r = this._attribute();
-            if (this._match(_.keywords.array)) {
+            if (this._match(g.keywords.array)) {
                 let s = null,
                     i = -1,
                     n = this._previous();
-                if (this._match(_.tokens.less_than)) {
+                if (this._match(g.tokens.less_than)) {
                     s = this._type_decl(), this._context.aliases.has(s.name) && (s = this._context.aliases.get(s.name).type);
                     let o = "";
-                    this._match(_.tokens.comma) && (o = this._shift_expression().evaluate(this._context).toString()), this._consume(_.tokens.greater_than, "Expected '>' for array."), i = o ? parseInt(o) : 0
+                    this._match(g.tokens.comma) && (o = this._shift_expression().evaluate(this._context).toString()), this._consume(g.tokens.greater_than, "Expected '>' for array."), i = o ? parseInt(o) : 0
                 }
-                return new _o(n.toString(), r, s, i)
+                return new go(n.toString(), r, s, i)
             }
             return null
         }
         _texture_sampler_types() {
-            if (this._match(_.sampler_type)) return new Sr(this._previous().toString(), null, null);
-            if (this._match(_.depth_texture_type)) return new Sr(this._previous().toString(), null, null);
-            if (this._match(_.sampled_texture_type) || this._match(_.multisampled_texture_type)) {
-                let e = this._previous();
-                this._consume(_.tokens.less_than, "Expected '<' for sampler type.");
+            if (this._match(g.sampler_type)) return new xr(this._previous().toString(), null, null);
+            if (this._match(g.depth_texture_type)) return new xr(this._previous().toString(), null, null);
+            if (this._match(g.sampled_texture_type) || this._match(g.multisampled_texture_type)) {
+                let t = this._previous();
+                this._consume(g.tokens.less_than, "Expected '<' for sampler type.");
                 let r = this._type_decl();
-                return this._consume(_.tokens.greater_than, "Expected '>' for sampler type."), new Sr(e.toString(), r, null)
+                return this._consume(g.tokens.greater_than, "Expected '>' for sampler type."), new xr(t.toString(), r, null)
             }
-            if (this._match(_.storage_texture_type)) {
-                let e = this._previous();
-                this._consume(_.tokens.less_than, "Expected '<' for sampler type.");
-                let r = this._consume(_.texel_format, "Invalid texel format.").toString();
-                this._consume(_.tokens.comma, "Expected ',' after texel format.");
-                let s = this._consume(_.access_mode, "Expected access mode for storage texture type.").toString();
-                return this._consume(_.tokens.greater_than, "Expected '>' for sampler type."), new Sr(e.toString(), r, s)
+            if (this._match(g.storage_texture_type)) {
+                let t = this._previous();
+                this._consume(g.tokens.less_than, "Expected '<' for sampler type.");
+                let r = this._consume(g.texel_format, "Invalid texel format.").toString();
+                this._consume(g.tokens.comma, "Expected ',' after texel format.");
+                let s = this._consume(g.access_mode, "Expected access mode for storage texture type.").toString();
+                return this._consume(g.tokens.greater_than, "Expected '>' for sampler type."), new xr(t.toString(), r, s)
             }
             return null
         }
         _attribute() {
-            let e = [];
-            for (; this._match(_.tokens.attr);) {
-                let r = this._consume(_.attribute_name, "Expected attribute name"),
-                    s = new xo(r.toString(), null);
-                if (this._match(_.tokens.paren_left)) {
-                    if (s.value = this._consume(_.literal_or_ident, "Expected attribute value").toString(), this._check(_.tokens.comma)) {
+            let t = [];
+            for (; this._match(g.tokens.attr);) {
+                let r = this._consume(g.attribute_name, "Expected attribute name"),
+                    s = new Eo(r.toString(), null);
+                if (this._match(g.tokens.paren_left)) {
+                    if (s.value = this._consume(g.literal_or_ident, "Expected attribute value").toString(), this._check(g.tokens.comma)) {
                         this._advance();
                         do {
-                            let i = this._consume(_.literal_or_ident, "Expected attribute value").toString();
+                            let i = this._consume(g.literal_or_ident, "Expected attribute value").toString();
                             s.value instanceof Array || (s.value = [s.value]), s.value.push(i)
-                        } while (this._match(_.tokens.comma))
+                        } while (this._match(g.tokens.comma))
                     }
-                    this._consume(_.tokens.paren_right, "Expected ')'")
+                    this._consume(g.tokens.paren_right, "Expected ')'")
                 }
-                e.push(s)
+                t.push(s)
             }
-            for (; this._match(_.tokens.attr_left);) {
-                if (!this._check(_.tokens.attr_right))
+            for (; this._match(g.tokens.attr_left);) {
+                if (!this._check(g.tokens.attr_right))
                     do {
-                        let r = this._consume(_.attribute_name, "Expected attribute name"),
-                            s = new xo(r.toString(), null);
-                        if (this._match(_.tokens.paren_left)) {
-                            if (s.value = [this._consume(_.literal_or_ident, "Expected attribute value").toString()], this._check(_.tokens.comma)) {
+                        let r = this._consume(g.attribute_name, "Expected attribute name"),
+                            s = new Eo(r.toString(), null);
+                        if (this._match(g.tokens.paren_left)) {
+                            if (s.value = [this._consume(g.literal_or_ident, "Expected attribute value").toString()], this._check(g.tokens.comma)) {
                                 this._advance();
                                 do {
-                                    let i = this._consume(_.literal_or_ident, "Expected attribute value").toString();
+                                    let i = this._consume(g.literal_or_ident, "Expected attribute value").toString();
                                     s.value.push(i)
-                                } while (this._match(_.tokens.comma))
+                                } while (this._match(g.tokens.comma))
                             }
-                            this._consume(_.tokens.paren_right, "Expected ')'")
+                            this._consume(g.tokens.paren_right, "Expected ')'")
                         }
-                        e.push(s)
-                    } while (this._match(_.tokens.comma));
-                this._consume(_.tokens.attr_right, "Expected ']]' after attribute declarations")
+                        t.push(s)
+                    } while (this._match(g.tokens.comma));
+                this._consume(g.tokens.attr_right, "Expected ']]' after attribute declarations")
             }
-            return e.length == 0 ? null : e
+            return t.length == 0 ? null : t
         }
     },
-    jt = class {
-        constructor(e, r) {
-            this.name = e, this.attributes = r, this.size = 0
+    He = class {
+        constructor(t, r) {
+            this.name = t, this.attributes = r, this.size = 0
         }
         get isArray() {
             return !1
         }
         get isStruct() {
             return !1
         }
         get isTemplate() {
             return !1
         }
     },
-    wo = class {
-        constructor(e, r, s) {
-            this.name = e, this.type = r, this.attributes = s, this.offset = 0, this.size = 0
+    So = class {
+        constructor(t, r, s) {
+            this.name = t, this.type = r, this.attributes = s, this.offset = 0, this.size = 0
         }
         get isArray() {
             return this.type.isArray
         }
         get isStruct() {
             return this.type.isStruct
         }
@@ -7069,45 +7069,45 @@
         get count() {
             return this.type.isArray ? this.type.count : 0
         }
         get stride() {
             return this.type.isArray ? this.type.stride : this.size
         }
     },
-    Jr = class extends jt {
-        constructor(e, r) {
-            super(e, r), this.members = [], this.align = 0
+    Jr = class extends He {
+        constructor(t, r) {
+            super(t, r), this.members = [], this.align = 0
         }
         get isStruct() {
             return !0
         }
     },
-    pi = class extends jt {
-        constructor(e, r) {
-            super(e, r), this.count = 0, this.stride = 0
+    pi = class extends He {
+        constructor(t, r) {
+            super(t, r), this.count = 0, this.stride = 0
         }
         get isArray() {
             return !0
         }
     },
-    Ro = class extends jt {
-        constructor(e, r, s, i) {
-            super(e, s), this.format = r, this.access = i
+    Ro = class extends He {
+        constructor(t, r, s, i) {
+            super(t, s), this.format = r, this.access = i
         }
         get isTemplate() {
             return !0
         }
     },
-    zt;
-(function(t) {
-    t[t.Uniform = 0] = "Uniform", t[t.Storage = 1] = "Storage", t[t.Texture = 2] = "Texture", t[t.Sampler = 3] = "Sampler", t[t.StorageTexture = 4] = "StorageTexture"
-})(zt || (zt = {}));
+    ze;
+(function(e) {
+    e[e.Uniform = 0] = "Uniform", e[e.Storage = 1] = "Storage", e[e.Texture = 2] = "Texture", e[e.Sampler = 3] = "Sampler", e[e.StorageTexture = 4] = "StorageTexture"
+})(ze || (ze = {}));
 var Gr = class {
-        constructor(e, r, s, i, n, o, a) {
-            this.name = e, this.type = r, this.group = s, this.binding = i, this.attributes = n, this.resourceType = o, this.access = a
+        constructor(t, r, s, i, n, o, a) {
+            this.name = t, this.type = r, this.group = s, this.binding = i, this.attributes = n, this.resourceType = o, this.access = a
         }
         get isArray() {
             return this.type.isArray
         }
         get isStruct() {
             return this.type.isStruct
         }
@@ -7129,110 +7129,110 @@
         get count() {
             return this.type.isArray ? this.type.count : 0
         }
         get stride() {
             return this.type.isArray ? this.type.stride : this.size
         }
     },
-    wl = class {
-        constructor(e, r) {
-            this.name = e, this.type = r
+    Sl = class {
+        constructor(t, r) {
+            this.name = t, this.type = r
         }
     },
-    es = class {
-        constructor(e, r) {
-            this.align = e, this.size = r
+    ts = class {
+        constructor(t, r) {
+            this.align = t, this.size = r
         }
     },
     Rl = class {
-        constructor(e, r, s, i) {
-            this.name = e, this.type = r, this.locationType = s, this.location = i, this.interpolation = null
+        constructor(t, r, s, i) {
+            this.name = t, this.type = r, this.locationType = s, this.location = i, this.interpolation = null
         }
     },
     vo = class {
-        constructor(e, r, s, i) {
-            this.name = e, this.type = r, this.locationType = s, this.location = i
+        constructor(t, r, s, i) {
+            this.name = t, this.type = r, this.locationType = s, this.location = i
         }
     },
     vl = class {
-        constructor(e, r = null) {
-            this.stage = null, this.inputs = [], this.outputs = [], this.name = e, this.stage = r
+        constructor(t, r = null) {
+            this.stage = null, this.inputs = [], this.outputs = [], this.name = t, this.stage = r
         }
     },
     Ml = class {
         constructor() {
             this.vertex = [], this.fragment = [], this.compute = []
         }
     },
     Pl = class {
-        constructor(e, r, s, i) {
-            this.name = e, this.type = r, this.attributes = s, this.id = i
+        constructor(t, r, s, i) {
+            this.name = t, this.type = r, this.attributes = s, this.id = i
         }
     },
-    Rr = class t {
-        constructor(e) {
-            this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new Ml, this._types = new Map, e && this.update(e)
+    Rr = class e {
+        constructor(t) {
+            this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new Ml, this._types = new Map, t && this.update(t)
         }
-        _isStorageTexture(e) {
-            return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d"
+        _isStorageTexture(t) {
+            return t.name == "texture_storage_1d" || t.name == "texture_storage_2d" || t.name == "texture_storage_2d_array" || t.name == "texture_storage_3d"
         }
-        update(e) {
-            let s = new Sl().parse(e);
+        update(t) {
+            let s = new xl().parse(t);
             for (let i of s) {
-                if (i instanceof Et) {
+                if (i instanceof we) {
                     let n = this._getTypeInfo(i, null);
                     n instanceof Jr && this.structs.push(n);
                     continue
                 }
                 if (i instanceof po) {
                     this.aliases.push(this._getAliasInfo(i));
                     continue
                 }
-                if (i instanceof ho) {
+                if (i instanceof fo) {
                     let n = i,
                         o = this._getAttributeNum(n.attributes, "id", 0),
                         a = n.type != null ? this._getTypeInfo(n.type, n.attributes) : null;
                     this.overrides.push(new Pl(n.name, a, n.attributes, o));
                     continue
                 }
                 if (this._isUniformVar(i)) {
                     let n = i,
                         o = this._getAttributeNum(n.attributes, "group", 0),
                         a = this._getAttributeNum(n.attributes, "binding", 0),
                         c = this._getTypeInfo(n.type, n.attributes),
-                        l = new Gr(n.name, c, o, a, n.attributes, zt.Uniform, n.access);
+                        l = new Gr(n.name, c, o, a, n.attributes, ze.Uniform, n.access);
                     this.uniforms.push(l);
                     continue
                 }
                 if (this._isStorageVar(i)) {
                     let n = i,
                         o = this._getAttributeNum(n.attributes, "group", 0),
                         a = this._getAttributeNum(n.attributes, "binding", 0),
                         c = this._getTypeInfo(n.type, n.attributes),
                         l = this._isStorageTexture(c),
-                        h = new Gr(n.name, c, o, a, n.attributes, l ? zt.StorageTexture : zt.Storage, n.access);
-                    this.storage.push(h);
+                        f = new Gr(n.name, c, o, a, n.attributes, l ? ze.StorageTexture : ze.Storage, n.access);
+                    this.storage.push(f);
                     continue
                 }
                 if (this._isTextureVar(i)) {
                     let n = i,
                         o = this._getAttributeNum(n.attributes, "group", 0),
                         a = this._getAttributeNum(n.attributes, "binding", 0),
                         c = this._getTypeInfo(n.type, n.attributes),
                         l = this._isStorageTexture(c),
-                        h = new Gr(n.name, c, o, a, n.attributes, l ? zt.StorageTexture : zt.Texture, n.access);
-                    l ? this.storage.push(h) : this.textures.push(h);
+                        f = new Gr(n.name, c, o, a, n.attributes, l ? ze.StorageTexture : ze.Texture, n.access);
+                    l ? this.storage.push(f) : this.textures.push(f);
                     continue
                 }
                 if (this._isSamplerVar(i)) {
                     let n = i,
                         o = this._getAttributeNum(n.attributes, "group", 0),
                         a = this._getAttributeNum(n.attributes, "binding", 0),
                         c = this._getTypeInfo(n.type, n.attributes),
-                        l = new Gr(n.name, c, o, a, n.attributes, zt.Sampler, n.access);
+                        l = new Gr(n.name, c, o, a, n.attributes, ze.Sampler, n.access);
                     this.samplers.push(l);
                     continue
                 }
                 if (i instanceof lo) {
                     let n = this._getAttribute(i, "vertex"),
                         o = this._getAttribute(i, "fragment"),
                         a = this._getAttribute(i, "compute"),
@@ -7242,249 +7242,249 @@
                         l.inputs = this._getInputs(i.args), l.outputs = this._getOutputs(i.returnType), this.entry[c.name].push(l)
                     }
                     continue
                 }
             }
         }
         getBindGroups() {
-            let e = [];
+            let t = [];
 
             function r(s, i) {
-                s >= e.length && (e.length = s + 1), e[s] === void 0 && (e[s] = []), i >= e[s].length && (e[s].length = i + 1)
+                s >= t.length && (t.length = s + 1), t[s] === void 0 && (t[s] = []), i >= t[s].length && (t[s].length = i + 1)
             }
             for (let s of this.uniforms) {
                 r(s.group, s.binding);
-                let i = e[s.group];
+                let i = t[s.group];
                 i[s.binding] = s
             }
             for (let s of this.storage) {
                 r(s.group, s.binding);
-                let i = e[s.group];
+                let i = t[s.group];
                 i[s.binding] = s
             }
             for (let s of this.textures) {
                 r(s.group, s.binding);
-                let i = e[s.group];
+                let i = t[s.group];
                 i[s.binding] = s
             }
             for (let s of this.samplers) {
                 r(s.group, s.binding);
-                let i = e[s.group];
+                let i = t[s.group];
                 i[s.binding] = s
             }
-            return e
+            return t
         }
-        _getOutputs(e, r = void 0) {
-            if (r === void 0 && (r = []), e instanceof Et) this._getStructOutputs(e, r);
+        _getOutputs(t, r = void 0) {
+            if (r === void 0 && (r = []), t instanceof we) this._getStructOutputs(t, r);
             else {
-                let s = this._getOutputInfo(e);
+                let s = this._getOutputInfo(t);
                 s !== null && r.push(s)
             }
             return r
         }
-        _getStructOutputs(e, r) {
-            for (let s of e.members)
-                if (s.type instanceof Et) this._getStructOutputs(s.type, r);
+        _getStructOutputs(t, r) {
+            for (let s of t.members)
+                if (s.type instanceof we) this._getStructOutputs(s.type, r);
                 else {
                     let i = this._getAttribute(s, "location") || this._getAttribute(s, "builtin");
                     if (i !== null) {
                         let n = this._getTypeInfo(s.type, s.type.attributes),
                             o = this._parseInt(i.value),
                             a = new vo(s.name, n, i.name, o);
                         r.push(a)
                     }
                 }
         }
-        _getOutputInfo(e) {
-            let r = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
+        _getOutputInfo(t) {
+            let r = this._getAttribute(t, "location") || this._getAttribute(t, "builtin");
             if (r !== null) {
-                let s = this._getTypeInfo(e, e.attributes),
+                let s = this._getTypeInfo(t, t.attributes),
                     i = this._parseInt(r.value);
                 return new vo("", s, r.name, i)
             }
             return null
         }
-        _getInputs(e, r = void 0) {
+        _getInputs(t, r = void 0) {
             r === void 0 && (r = []);
-            for (let s of e)
-                if (s.type instanceof Et) this._getStructInputs(s.type, r);
+            for (let s of t)
+                if (s.type instanceof we) this._getStructInputs(s.type, r);
                 else {
                     let i = this._getInputInfo(s);
                     i !== null && r.push(i)
                 } return r
         }
-        _getStructInputs(e, r) {
-            for (let s of e.members)
-                if (s.type instanceof Et) this._getStructInputs(s.type, r);
+        _getStructInputs(t, r) {
+            for (let s of t.members)
+                if (s.type instanceof we) this._getStructInputs(s.type, r);
                 else {
                     let i = this._getInputInfo(s);
                     i !== null && r.push(i)
                 }
         }
-        _getInputInfo(e) {
-            let r = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
+        _getInputInfo(t) {
+            let r = this._getAttribute(t, "location") || this._getAttribute(t, "builtin");
             if (r !== null) {
-                let s = this._getAttribute(e, "interpolation"),
-                    i = this._getTypeInfo(e.type, e.attributes),
+                let s = this._getAttribute(t, "interpolation"),
+                    i = this._getTypeInfo(t.type, t.attributes),
                     n = this._parseInt(r.value),
-                    o = new Rl(e.name, i, r.name, n);
+                    o = new Rl(t.name, i, r.name, n);
                 return s !== null && (o.interpolation = this._parseString(s.value)), o
             }
             return null
         }
-        _parseString(e) {
-            return e instanceof Array && (e = e[0]), e
+        _parseString(t) {
+            return t instanceof Array && (t = t[0]), t
         }
-        _parseInt(e) {
-            e instanceof Array && (e = e[0]);
-            let r = parseInt(e);
-            return isNaN(r) ? e : r
+        _parseInt(t) {
+            t instanceof Array && (t = t[0]);
+            let r = parseInt(t);
+            return isNaN(r) ? t : r
         }
-        _getAlias(e) {
+        _getAlias(t) {
             for (let r of this.aliases)
-                if (r.name == e) return r.type;
+                if (r.name == t) return r.type;
             return null
         }
-        _getAliasInfo(e) {
-            return new wl(e.name, this._getTypeInfo(e.type, null))
+        _getAliasInfo(t) {
+            return new Sl(t.name, this._getTypeInfo(t.type, null))
         }
-        _getTypeInfo(e, r) {
-            if (this._types.has(e)) return this._types.get(e);
-            if (e instanceof _o) {
-                let i = e,
+        _getTypeInfo(t, r) {
+            if (this._types.has(t)) return this._types.get(t);
+            if (t instanceof go) {
+                let i = t,
                     n = this._getTypeInfo(i.format, i.attributes),
                     o = new pi(i.name, r);
-                return o.format = n, o.count = i.count, this._types.set(e, o), this._updateTypeInfo(o), o
+                return o.format = n, o.count = i.count, this._types.set(t, o), this._updateTypeInfo(o), o
             }
-            if (e instanceof Et) {
-                let i = e,
+            if (t instanceof we) {
+                let i = t,
                     n = new Jr(i.name, r);
                 for (let o of i.members) {
                     let a = this._getTypeInfo(o.type, o.attributes);
-                    n.members.push(new wo(o.name, a, o.attributes))
+                    n.members.push(new So(o.name, a, o.attributes))
                 }
-                return this._types.set(e, n), this._updateTypeInfo(n), n
+                return this._types.set(t, n), this._updateTypeInfo(n), n
             }
-            if (e instanceof Sr) {
-                let i = e,
-                    n = i.format instanceof xt,
-                    o = i.format ? n ? this._getTypeInfo(i.format, null) : new jt(i.format, null) : null,
+            if (t instanceof xr) {
+                let i = t,
+                    n = i.format instanceof Ee,
+                    o = i.format ? n ? this._getTypeInfo(i.format, null) : new He(i.format, null) : null,
                     a = new Ro(i.name, o, r, i.access);
-                return this._types.set(e, a), this._updateTypeInfo(a), a
+                return this._types.set(t, a), this._updateTypeInfo(a), a
             }
-            if (e instanceof go) {
-                let i = e,
+            if (t instanceof _o) {
+                let i = t,
                     n = i.format ? this._getTypeInfo(i.format, null) : null,
                     o = new Ro(i.name, n, r, i.access);
-                return this._types.set(e, o), this._updateTypeInfo(o), o
+                return this._types.set(t, o), this._updateTypeInfo(o), o
             }
-            let s = new jt(e.name, r);
-            return this._types.set(e, s), this._updateTypeInfo(s), s
+            let s = new He(t.name, r);
+            return this._types.set(t, s), this._updateTypeInfo(s), s
         }
-        _updateTypeInfo(e) {
+        _updateTypeInfo(t) {
             var r, s;
-            let i = this._getTypeSize(e);
-            if (e.size = (r = i?.size) !== null && r !== void 0 ? r : 0, e instanceof pi) {
-                let n = this._getTypeSize(e.format);
-                e.stride = (s = n?.size) !== null && s !== void 0 ? s : 0, this._updateTypeInfo(e.format)
+            let i = this._getTypeSize(t);
+            if (t.size = (r = i?.size) !== null && r !== void 0 ? r : 0, t instanceof pi) {
+                let n = this._getTypeSize(t.format);
+                t.stride = (s = n?.size) !== null && s !== void 0 ? s : 0, this._updateTypeInfo(t.format)
             }
-            e instanceof Jr && this._updateStructInfo(e)
+            t instanceof Jr && this._updateStructInfo(t)
         }
-        _updateStructInfo(e) {
+        _updateStructInfo(t) {
             var r;
             let s = 0,
                 i = 0,
                 n = 0,
                 o = 0;
-            for (let a = 0, c = e.members.length; a < c; ++a) {
-                let l = e.members[a],
-                    h = this._getTypeSize(l);
-                if (!h) continue;
+            for (let a = 0, c = t.members.length; a < c; ++a) {
+                let l = t.members[a],
+                    f = this._getTypeSize(l);
+                if (!f) continue;
                 (r = this._getAlias(l.type.name)) !== null && r !== void 0 || l.type;
-                let d = h.align,
-                    p = h.size;
+                let d = f.align,
+                    p = f.size;
                 s = this._roundUp(d, s + i), i = p, n = s, o = Math.max(o, d), l.offset = s, l.size = p, this._updateTypeInfo(l.type)
             }
-            e.size = this._roundUp(o, n + i), e.align = o
+            t.size = this._roundUp(o, n + i), t.align = o
         }
-        _getTypeSize(e) {
+        _getTypeSize(t) {
             var r;
-            if (e == null) return null;
-            let s = this._getAttributeNum(e.attributes, "size", 0),
-                i = this._getAttributeNum(e.attributes, "align", 0);
-            if (e instanceof wo && (e = e.type), e instanceof jt) {
-                let n = this._getAlias(e.name);
-                n !== null && (e = n)
+            if (t == null) return null;
+            let s = this._getAttributeNum(t.attributes, "size", 0),
+                i = this._getAttributeNum(t.attributes, "align", 0);
+            if (t instanceof So && (t = t.type), t instanceof He) {
+                let n = this._getAlias(t.name);
+                n !== null && (t = n)
             } {
-                let n = t._typeInfo[e.name];
+                let n = e._typeInfo[t.name];
                 if (n !== void 0) {
-                    let o = e.format === "f16" ? 2 : 1;
-                    return new es(Math.max(i, n.align / o), Math.max(s, n.size / o))
+                    let o = t.format === "f16" ? 2 : 1;
+                    return new ts(Math.max(i, n.align / o), Math.max(s, n.size / o))
                 }
             } {
-                let n = t._typeInfo[e.name.substring(0, e.name.length - 1)];
+                let n = e._typeInfo[t.name.substring(0, t.name.length - 1)];
                 if (n) {
-                    let o = e.name[e.name.length - 1] === "h" ? 2 : 1;
-                    return new es(Math.max(i, n.align / o), Math.max(s, n.size / o))
+                    let o = t.name[t.name.length - 1] === "h" ? 2 : 1;
+                    return new ts(Math.max(i, n.align / o), Math.max(s, n.size / o))
                 }
             }
-            if (e instanceof pi) {
-                let n = e,
+            if (t instanceof pi) {
+                let n = t,
                     o = 8,
                     a = 8,
                     c = this._getTypeSize(n.format);
                 c !== null && (a = c.size, o = c.align);
                 let l = n.count,
-                    h = this._getAttributeNum((r = e?.attributes) !== null && r !== void 0 ? r : null, "stride", this._roundUp(o, a));
-                return a = l * h, s && (a = s), new es(Math.max(i, o), Math.max(s, a))
+                    f = this._getAttributeNum((r = t?.attributes) !== null && r !== void 0 ? r : null, "stride", this._roundUp(o, a));
+                return a = l * f, s && (a = s), new ts(Math.max(i, o), Math.max(s, a))
             }
-            if (e instanceof Jr) {
+            if (t instanceof Jr) {
                 let n = 0,
                     o = 0,
                     a = 0,
                     c = 0,
                     l = 0;
-                for (let h of e.members) {
-                    let d = this._getTypeSize(h.type);
+                for (let f of t.members) {
+                    let d = this._getTypeSize(f.type);
                     d !== null && (n = Math.max(d.align, n), a = this._roundUp(d.align, a + c), c = d.size, l = a)
                 }
-                return o = this._roundUp(n, l + c), new es(Math.max(i, n), Math.max(s, o))
+                return o = this._roundUp(n, l + c), new ts(Math.max(i, n), Math.max(s, o))
             }
             return null
         }
-        _isUniformVar(e) {
-            return e instanceof Ht && e.storage == "uniform"
+        _isUniformVar(t) {
+            return t instanceof je && t.storage == "uniform"
         }
-        _isStorageVar(e) {
-            return e instanceof Ht && e.storage == "storage"
+        _isStorageVar(t) {
+            return t instanceof je && t.storage == "storage"
         }
-        _isTextureVar(e) {
-            return e instanceof Ht && e.type !== null && t._textureTypes.indexOf(e.type.name) != -1
+        _isTextureVar(t) {
+            return t instanceof je && t.type !== null && e._textureTypes.indexOf(t.type.name) != -1
         }
-        _isSamplerVar(e) {
-            return e instanceof Ht && e.type !== null && t._samplerTypes.indexOf(e.type.name) != -1
+        _isSamplerVar(t) {
+            return t instanceof je && t.type !== null && e._samplerTypes.indexOf(t.type.name) != -1
         }
-        _getAttribute(e, r) {
-            let s = e;
+        _getAttribute(t, r) {
+            let s = t;
             if (!s || !s.attributes) return null;
             let i = s.attributes;
             for (let n of i)
                 if (n.name == r) return n;
             return null
         }
-        _getAttributeNum(e, r, s) {
-            if (e === null) return s;
-            for (let i of e)
+        _getAttributeNum(t, r, s) {
+            if (t === null) return s;
+            for (let i of t)
                 if (i.name == r) {
                     let n = i !== null && i.value !== null ? i.value : s;
                     return n instanceof Array && (n = n[0]), typeof n == "number" ? n : typeof n == "string" ? parseInt(n) : s
                 } return s
         }
-        _roundUp(e, r) {
-            return Math.ceil(r / e) * e
+        _roundUp(t, r) {
+            return Math.ceil(r / t) * t
         }
     };
 Rr._typeInfo = {
     f16: {
         align: 2,
         size: 2
     },
@@ -7549,74 +7549,74 @@
         size: 48
     },
     mat4x4: {
         align: 16,
         size: 64
     }
 };
-Rr._textureTypes = _.any_texture_type.map(t => t.name);
-Rr._samplerTypes = _.sampler_type.map(t => t.name);
+Rr._textureTypes = g.any_texture_type.map(e => e.name);
+Rr._samplerTypes = g.sampler_type.map(e => e.name);
 
-function Cl(t) {
-    let e = {
+function Cl(e) {
+    let t = {
             attributes: [],
             bindings: []
         },
         r;
     try {
-        r = xy(t)
+        r = Sy(e)
     } catch (n) {
-        return P.error(n.message)(), e
+        return P.error(n.message)(), t
     }
     for (let n of r.uniforms) {
         let o = [];
         for (let a of n.type.members) o.push({
             name: a.name,
-            type: dd(a.type)
+            type: pd(a.type)
         });
-        e.bindings.push({
+        t.bindings.push({
             type: "uniform",
             name: n.name,
             location: n.binding,
             group: n.group,
             members: o
         })
     }
     let s = r.entry.vertex[0],
         i = s?.inputs.length || 0;
     for (let n = 0; n < i; n++) {
         let o = s.inputs[n];
         if (o.locationType === "location") {
-            let a = dd(o.type);
-            e.attributes.push({
+            let a = pd(o.type);
+            t.attributes.push({
                 name: o.name,
                 location: o.location,
                 type: a
             })
         }
     }
-    return e
+    return t
 }
 
-function dd(t) {
-    return t.format ? `${t.name}<${t.format.name}>` : t.name
+function pd(e) {
+    return e.format ? `${e.name}<${e.format.name}>` : e.name
 }
 
-function xy(t) {
+function Sy(e) {
     try {
-        return new Rr(t)
-    } catch (e) {
-        if (e instanceof Error) throw e;
+        return new Rr(e)
+    } catch (t) {
+        if (t instanceof Error) throw t;
         let r = "WGSL parse error";
-        throw typeof e == "object" && e?.message && (r += `: ${e.message} `), typeof e == "object" && e?.token && (r += e.token.line || ""), new Error(r, {
-            cause: e
+        throw typeof t == "object" && t?.message && (r += `: ${t.message} `), typeof t == "object" && t?.token && (r += t.token.line || ""), new Error(r, {
+            cause: t
         })
     }
 }
-var Sy = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
+var Ry = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
 const float TWO_PI = 6.2831854820251465;
 const float PI_2 = 1.5707963705062866;
 const float PI_16 = 0.1963495463132858;
 const float SIN_TABLE_0 = 0.19509032368659973;
 const float SIN_TABLE_1 = 0.3826834261417389;
 const float SIN_TABLE_2 = 0.5555702447891235;
 const float SIN_TABLE_3 = 0.7071067690849304;
@@ -7733,18 +7733,18 @@
 #else
 return tan(a);
 #endif
 }
 `,
     Il = {
         name: "fp32",
-        vs: Sy
+        vs: Ry
     };
-var wy = new Float32Array([0, 1, 1, 1]),
-    Ry = `uniform pickingUniforms {
+var vy = new Float32Array([0, 1, 1, 1]),
+    My = `uniform pickingUniforms {
 float isActive;
 float isAttribute;
 float isHighlightActive;
 float useFloatColors;
 vec3 highlightedObjectColor;
 vec4 highlightColor;
 } picking;
@@ -7789,15 +7789,15 @@
 }
 void picking_setPickingAttribute(vec3 value) {
 if (bool(picking.isAttribute)) {
 picking_vRGBcolor_Avalid.rgb = value;
 }
 }
 `,
-    vy = `uniform pickingUniforms {
+    Py = `uniform pickingUniforms {
 float isActive;
 float isAttribute;
 float isHighlightActive;
 float useFloatColors;
 vec3 highlightedObjectColor;
 vec4 highlightColor;
 } picking;
@@ -7829,2207 +7829,2207 @@
 vec4 picking_filterColor(vec4 color) {
 vec4 highlightColor = picking_filterHighlightColor(color);
 return picking_filterPickingColor(highlightColor);
 }
 `,
     Mo = {
         name: "picking",
-        vs: Ry,
-        fs: vy,
+        vs: My,
+        fs: Py,
         uniformTypes: {
             isActive: "f32",
             isAttribute: "f32",
             isHighlightActive: "f32",
             useFloatColors: "f32",
             highlightedObjectColor: "vec3<f32>",
             highlightColor: "vec4<f32>"
         },
         defaultUniforms: {
             isActive: !1,
             isAttribute: !1,
             isHighlightActive: !1,
             useFloatColors: !0,
             highlightedObjectColor: new Float32Array([0, 0, 0]),
-            highlightColor: wy
+            highlightColor: vy
         },
-        getUniforms: My
+        getUniforms: Cy
     };
 
-function My(t = {}, e) {
+function Cy(e = {}, t) {
     let r = {};
-    if (t.highlightedObjectColor !== void 0)
-        if (t.highlightedObjectColor === null) r.isHighlightActive = !1;
+    if (e.highlightedObjectColor !== void 0)
+        if (e.highlightedObjectColor === null) r.isHighlightActive = !1;
         else {
             r.isHighlightActive = !0;
-            let s = t.highlightedObjectColor.slice(0, 3);
+            let s = e.highlightedObjectColor.slice(0, 3);
             r.highlightedObjectColor = s
-        } if (t.highlightColor) {
-        let s = Array.from(t.highlightColor, i => i / 255);
+        } if (e.highlightColor) {
+        let s = Array.from(e.highlightColor, i => i / 255);
         Number.isFinite(s[3]) || (s[3] = 1), r.highlightColor = s
     }
-    return t.isActive !== void 0 && (r.isActive = !!t.isActive, r.isAttribute = !!t.isAttribute), t.useFloatColors !== void 0 && (r.useFloatColors = !!t.useFloatColors), r
+    return e.isActive !== void 0 && (r.isActive = !!e.isActive, r.isAttribute = !!e.isAttribute), e.useFloatColors !== void 0 && (r.useFloatColors = !!e.useFloatColors), r
 }
-var iC = 1 / Math.PI * 180,
-    nC = 1 / 180 * Math.PI,
-    Py = {
+var aC = 1 / Math.PI * 180,
+    cC = 1 / 180 * Math.PI,
+    Iy = {
         EPSILON: 1e-12,
         debug: !1,
         precision: 4,
         printTypes: !1,
         printDegrees: !1,
         printRowMajor: !0,
         _cartographicRadians: !1
     };
 globalThis.mathgl = globalThis.mathgl || {
     config: {
-        ...Py
+        ...Iy
     }
 };
-var ae = globalThis.mathgl.config;
+var at = globalThis.mathgl.config;
 
-function Ol(t, {
-    precision: e = ae.precision
+function Ol(e, {
+    precision: t = at.precision
 } = {}) {
-    return t = Cy(t), `${parseFloat(t.toPrecision(e))}`
+    return e = Oy(e), `${parseFloat(e.toPrecision(t))}`
 }
 
-function St(t) {
-    return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView)
+function xe(e) {
+    return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView)
 }
 
-function Le(t, e, r) {
-    return Oy(t, s => Math.max(e, Math.min(r, s)))
+function Lt(e, t, r) {
+    return Fy(e, s => Math.max(t, Math.min(r, s)))
 }
 
-function vr(t, e, r) {
-    return St(t) ? t.map((s, i) => vr(s, e[i], r)) : r * e + (1 - r) * t
+function vr(e, t, r) {
+    return xe(e) ? e.map((s, i) => vr(s, t[i], r)) : r * t + (1 - r) * e
 }
 
-function wt(t, e, r) {
-    let s = ae.EPSILON;
-    r && (ae.EPSILON = r);
+function Se(e, t, r) {
+    let s = at.EPSILON;
+    r && (at.EPSILON = r);
     try {
-        if (t === e) return !0;
-        if (St(t) && St(e)) {
-            if (t.length !== e.length) return !1;
-            for (let i = 0; i < t.length; ++i)
-                if (!wt(t[i], e[i])) return !1;
+        if (e === t) return !0;
+        if (xe(e) && xe(t)) {
+            if (e.length !== t.length) return !1;
+            for (let i = 0; i < e.length; ++i)
+                if (!Se(e[i], t[i])) return !1;
             return !0
         }
-        return t && t.equals ? t.equals(e) : e && e.equals ? e.equals(t) : typeof t == "number" && typeof e == "number" ? Math.abs(t - e) <= ae.EPSILON * Math.max(1, Math.abs(t), Math.abs(e)) : !1
+        return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == "number" && typeof t == "number" ? Math.abs(e - t) <= at.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1
     } finally {
-        ae.EPSILON = s
+        at.EPSILON = s
     }
 }
 
-function Cy(t) {
-    return Math.round(t / ae.EPSILON) * ae.EPSILON
+function Oy(e) {
+    return Math.round(e / at.EPSILON) * at.EPSILON
 }
 
-function Iy(t) {
-    return t.clone ? t.clone() : new Array(t.length)
+function Ny(e) {
+    return e.clone ? e.clone() : new Array(e.length)
 }
 
-function Oy(t, e, r) {
-    if (St(t)) {
-        let s = t;
-        r = r || Iy(s);
+function Fy(e, t, r) {
+    if (xe(e)) {
+        let s = e;
+        r = r || Ny(s);
         for (let i = 0; i < r.length && i < s.length; ++i) {
-            let n = typeof t == "number" ? t : t[i];
-            r[i] = e(n, i, r)
+            let n = typeof e == "number" ? e : e[i];
+            r[i] = t(n, i, r)
         }
         return r
     }
-    return e(t)
+    return t(e)
 }
 var rs = class extends Array {
     clone() {
         return new this.constructor().copy(this)
     }
-    fromArray(e, r = 0) {
-        for (let s = 0; s < this.ELEMENTS; ++s) this[s] = e[s + r];
+    fromArray(t, r = 0) {
+        for (let s = 0; s < this.ELEMENTS; ++s) this[s] = t[s + r];
         return this.check()
     }
-    toArray(e = [], r = 0) {
-        for (let s = 0; s < this.ELEMENTS; ++s) e[r + s] = this[s];
-        return e
+    toArray(t = [], r = 0) {
+        for (let s = 0; s < this.ELEMENTS; ++s) t[r + s] = this[s];
+        return t
     }
-    toObject(e) {
-        return e
+    toObject(t) {
+        return t
     }
-    from(e) {
-        return Array.isArray(e) ? this.copy(e) : this.fromObject(e)
+    from(t) {
+        return Array.isArray(t) ? this.copy(t) : this.fromObject(t)
     }
-    to(e) {
-        return e === this ? this : St(e) ? this.toArray(e) : this.toObject(e)
+    to(t) {
+        return t === this ? this : xe(t) ? this.toArray(t) : this.toObject(t)
     }
-    toTarget(e) {
-        return e ? this.to(e) : this
+    toTarget(t) {
+        return t ? this.to(t) : this
     }
     toFloat32Array() {
         return new Float32Array(this)
     }
     toString() {
-        return this.formatString(ae)
+        return this.formatString(at)
     }
-    formatString(e) {
+    formatString(t) {
         let r = "";
-        for (let s = 0; s < this.ELEMENTS; ++s) r += (s > 0 ? ", " : "") + Ol(this[s], e);
-        return `${e.printTypes?this.constructor.name:""}[${r}]`
+        for (let s = 0; s < this.ELEMENTS; ++s) r += (s > 0 ? ", " : "") + Ol(this[s], t);
+        return `${t.printTypes?this.constructor.name:""}[${r}]`
     }
-    equals(e) {
-        if (!e || this.length !== e.length) return !1;
+    equals(t) {
+        if (!t || this.length !== t.length) return !1;
         for (let r = 0; r < this.ELEMENTS; ++r)
-            if (!wt(this[r], e[r])) return !1;
+            if (!Se(this[r], t[r])) return !1;
         return !0
     }
-    exactEquals(e) {
-        if (!e || this.length !== e.length) return !1;
+    exactEquals(t) {
+        if (!t || this.length !== t.length) return !1;
         for (let r = 0; r < this.ELEMENTS; ++r)
-            if (this[r] !== e[r]) return !1;
+            if (this[r] !== t[r]) return !1;
         return !0
     }
     negate() {
-        for (let e = 0; e < this.ELEMENTS; ++e) this[e] = -this[e];
+        for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];
         return this.check()
     }
-    lerp(e, r, s) {
-        if (s === void 0) return this.lerp(this, e, r);
+    lerp(t, r, s) {
+        if (s === void 0) return this.lerp(this, t, r);
         for (let i = 0; i < this.ELEMENTS; ++i) {
-            let n = e[i],
+            let n = t[i],
                 o = typeof r == "number" ? r : r[i];
             this[i] = n + s * (o - n)
         }
         return this.check()
     }
-    min(e) {
-        for (let r = 0; r < this.ELEMENTS; ++r) this[r] = Math.min(e[r], this[r]);
+    min(t) {
+        for (let r = 0; r < this.ELEMENTS; ++r) this[r] = Math.min(t[r], this[r]);
         return this.check()
     }
-    max(e) {
-        for (let r = 0; r < this.ELEMENTS; ++r) this[r] = Math.max(e[r], this[r]);
+    max(t) {
+        for (let r = 0; r < this.ELEMENTS; ++r) this[r] = Math.max(t[r], this[r]);
         return this.check()
     }
-    clamp(e, r) {
-        for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], e[s]), r[s]);
+    clamp(t, r) {
+        for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], t[s]), r[s]);
         return this.check()
     }
-    add(...e) {
-        for (let r of e)
+    add(...t) {
+        for (let r of t)
             for (let s = 0; s < this.ELEMENTS; ++s) this[s] += r[s];
         return this.check()
     }
-    subtract(...e) {
-        for (let r of e)
+    subtract(...t) {
+        for (let r of t)
             for (let s = 0; s < this.ELEMENTS; ++s) this[s] -= r[s];
         return this.check()
     }
-    scale(e) {
-        if (typeof e == "number")
-            for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= e;
+    scale(t) {
+        if (typeof t == "number")
+            for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= t;
         else
-            for (let r = 0; r < this.ELEMENTS && r < e.length; ++r) this[r] *= e[r];
+            for (let r = 0; r < this.ELEMENTS && r < t.length; ++r) this[r] *= t[r];
         return this.check()
     }
-    multiplyByScalar(e) {
-        for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= e;
+    multiplyByScalar(t) {
+        for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= t;
         return this.check()
     }
     check() {
-        if (ae.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
+        if (at.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
         return this
     }
     validate() {
-        let e = this.length === this.ELEMENTS;
-        for (let r = 0; r < this.ELEMENTS; ++r) e = e && Number.isFinite(this[r]);
-        return e
+        let t = this.length === this.ELEMENTS;
+        for (let r = 0; r < this.ELEMENTS; ++r) t = t && Number.isFinite(this[r]);
+        return t
     }
-    sub(e) {
-        return this.subtract(e)
+    sub(t) {
+        return this.subtract(t)
     }
-    setScalar(e) {
-        for (let r = 0; r < this.ELEMENTS; ++r) this[r] = e;
+    setScalar(t) {
+        for (let r = 0; r < this.ELEMENTS; ++r) this[r] = t;
         return this.check()
     }
-    addScalar(e) {
-        for (let r = 0; r < this.ELEMENTS; ++r) this[r] += e;
+    addScalar(t) {
+        for (let r = 0; r < this.ELEMENTS; ++r) this[r] += t;
         return this.check()
     }
-    subScalar(e) {
-        return this.addScalar(-e)
+    subScalar(t) {
+        return this.addScalar(-t)
     }
-    multiplyScalar(e) {
-        for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= e;
+    multiplyScalar(t) {
+        for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= t;
         return this.check()
     }
-    divideScalar(e) {
-        return this.multiplyByScalar(1 / e)
+    divideScalar(t) {
+        return this.multiplyByScalar(1 / t)
     }
-    clampScalar(e, r) {
-        for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], e), r);
+    clampScalar(t, r) {
+        for (let s = 0; s < this.ELEMENTS; ++s) this[s] = Math.min(Math.max(this[s], t), r);
         return this.check()
     }
     get elements() {
         return this
     }
 };
 
-function Ny(t, e) {
-    if (t.length !== e) return !1;
-    for (let r = 0; r < t.length; ++r)
-        if (!Number.isFinite(t[r])) return !1;
+function ky(e, t) {
+    if (e.length !== t) return !1;
+    for (let r = 0; r < e.length; ++r)
+        if (!Number.isFinite(e[r])) return !1;
     return !0
 }
 
-function ge(t) {
-    if (!Number.isFinite(t)) throw new Error(`Invalid number ${JSON.stringify(t)}`);
-    return t
+function _t(e) {
+    if (!Number.isFinite(e)) throw new Error(`Invalid number ${JSON.stringify(e)}`);
+    return e
 }
 
-function Po(t, e, r = "") {
-    if (ae.debug && !Ny(t, e)) throw new Error(`math.gl: ${r} some fields set to invalid numbers'`);
-    return t
+function Po(e, t, r = "") {
+    if (at.debug && !ky(e, t)) throw new Error(`math.gl: ${r} some fields set to invalid numbers'`);
+    return e
 }
 
-function Nl(t, e) {
-    if (!t) throw new Error(`math.gl assertion ${e}`)
+function Nl(e, t) {
+    if (!e) throw new Error(`math.gl assertion ${t}`)
 }
 var Co = class extends rs {
     get x() {
         return this[0]
     }
-    set x(e) {
-        this[0] = ge(e)
+    set x(t) {
+        this[0] = _t(t)
     }
     get y() {
         return this[1]
     }
-    set y(e) {
-        this[1] = ge(e)
+    set y(t) {
+        this[1] = _t(t)
     }
     len() {
         return Math.sqrt(this.lengthSquared())
     }
     magnitude() {
         return this.len()
     }
     lengthSquared() {
-        let e = 0;
-        for (let r = 0; r < this.ELEMENTS; ++r) e += this[r] * this[r];
-        return e
+        let t = 0;
+        for (let r = 0; r < this.ELEMENTS; ++r) t += this[r] * this[r];
+        return t
     }
     magnitudeSquared() {
         return this.lengthSquared()
     }
-    distance(e) {
-        return Math.sqrt(this.distanceSquared(e))
+    distance(t) {
+        return Math.sqrt(this.distanceSquared(t))
     }
-    distanceSquared(e) {
+    distanceSquared(t) {
         let r = 0;
         for (let s = 0; s < this.ELEMENTS; ++s) {
-            let i = this[s] - e[s];
+            let i = this[s] - t[s];
             r += i * i
         }
-        return ge(r)
+        return _t(r)
     }
-    dot(e) {
+    dot(t) {
         let r = 0;
-        for (let s = 0; s < this.ELEMENTS; ++s) r += this[s] * e[s];
-        return ge(r)
+        for (let s = 0; s < this.ELEMENTS; ++s) r += this[s] * t[s];
+        return _t(r)
     }
     normalize() {
-        let e = this.magnitude();
-        if (e !== 0)
-            for (let r = 0; r < this.ELEMENTS; ++r) this[r] /= e;
+        let t = this.magnitude();
+        if (t !== 0)
+            for (let r = 0; r < this.ELEMENTS; ++r) this[r] /= t;
         return this.check()
     }
-    multiply(...e) {
-        for (let r of e)
+    multiply(...t) {
+        for (let r of t)
             for (let s = 0; s < this.ELEMENTS; ++s) this[s] *= r[s];
         return this.check()
     }
-    divide(...e) {
-        for (let r of e)
+    divide(...t) {
+        for (let r of t)
             for (let s = 0; s < this.ELEMENTS; ++s) this[s] /= r[s];
         return this.check()
     }
     lengthSq() {
         return this.lengthSquared()
     }
-    distanceTo(e) {
-        return this.distance(e)
+    distanceTo(t) {
+        return this.distance(t)
     }
-    distanceToSquared(e) {
-        return this.distanceSquared(e)
+    distanceToSquared(t) {
+        return this.distanceSquared(t)
     }
-    getComponent(e) {
-        return Nl(e >= 0 && e < this.ELEMENTS, "index is out of range"), ge(this[e])
+    getComponent(t) {
+        return Nl(t >= 0 && t < this.ELEMENTS, "index is out of range"), _t(this[t])
     }
-    setComponent(e, r) {
-        return Nl(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = r, this.check()
-    }
-    addVectors(e, r) {
-        return this.copy(e).add(r)
-    }
-    subVectors(e, r) {
-        return this.copy(e).subtract(r)
-    }
-    multiplyVectors(e, r) {
-        return this.copy(e).multiply(r)
-    }
-    addScaledVector(e, r) {
-        return this.add(new this.constructor(e).multiplyScalar(r))
-    }
-};
-var lt = {};
-Us(lt, {
-    add: () => Uy,
-    angle: () => s0,
-    ceil: () => Ly,
-    clone: () => Fy,
-    copy: () => ky,
-    create: () => pd,
-    cross: () => Zy,
-    dist: () => u0,
-    distance: () => Td,
-    div: () => f0,
-    divide: () => md,
-    dot: () => Ky,
-    equals: () => a0,
-    exactEquals: () => o0,
-    floor: () => Vy,
-    forEach: () => g0,
-    fromValues: () => Dy,
-    inverse: () => Yy,
-    len: () => c0,
-    length: () => bd,
-    lerp: () => Qy,
-    max: () => zy,
-    min: () => Wy,
-    mul: () => h0,
-    multiply: () => _d,
-    negate: () => $y,
-    normalize: () => qy,
-    random: () => Jy,
-    rotate: () => r0,
-    round: () => Hy,
-    scale: () => jy,
-    scaleAndAdd: () => Xy,
-    set: () => By,
-    sqrDist: () => d0,
-    sqrLen: () => p0,
-    squaredDistance: () => yd,
-    squaredLength: () => Ed,
-    str: () => n0,
-    sub: () => l0,
+    setComponent(t, r) {
+        return Nl(t >= 0 && t < this.ELEMENTS, "index is out of range"), this[t] = r, this.check()
+    }
+    addVectors(t, r) {
+        return this.copy(t).add(r)
+    }
+    subVectors(t, r) {
+        return this.copy(t).subtract(r)
+    }
+    multiplyVectors(t, r) {
+        return this.copy(t).multiply(r)
+    }
+    addScaledVector(t, r) {
+        return this.add(new this.constructor(t).multiplyScalar(r))
+    }
+};
+var le = {};
+Us(le, {
+    add: () => Vy,
+    angle: () => nT,
+    ceil: () => Wy,
+    clone: () => Dy,
+    copy: () => Uy,
+    create: () => _d,
+    cross: () => Jy,
+    dist: () => pT,
+    distance: () => yd,
+    div: () => dT,
+    divide: () => bd,
+    dot: () => Qy,
+    equals: () => lT,
+    exactEquals: () => cT,
+    floor: () => zy,
+    forEach: () => mT,
+    fromValues: () => By,
+    inverse: () => Ky,
+    len: () => fT,
+    length: () => wd,
+    lerp: () => Gy,
+    max: () => Hy,
+    min: () => jy,
+    mul: () => uT,
+    multiply: () => md,
+    negate: () => qy,
+    normalize: () => Zy,
+    random: () => tT,
+    rotate: () => iT,
+    round: () => Xy,
+    scale: () => $y,
+    scaleAndAdd: () => Yy,
+    set: () => Ly,
+    sqrDist: () => _T,
+    sqrLen: () => gT,
+    squaredDistance: () => Td,
+    squaredLength: () => Ad,
+    str: () => aT,
+    sub: () => hT,
     subtract: () => gd,
-    transformMat2: () => Gy,
-    transformMat2d: () => e0,
-    transformMat3: () => t0,
+    transformMat2: () => eT,
+    transformMat2d: () => rT,
+    transformMat3: () => sT,
     transformMat4: () => Fl,
-    zero: () => i0
+    zero: () => oT
 });
 var G = typeof Float32Array < "u" ? Float32Array : Array,
-    ct = Math.random;
+    ce = Math.random;
 
-function Ve(t) {
-    return t >= 0 ? Math.round(t) : t % .5 === 0 ? Math.floor(t) : Math.round(t)
+function Vt(e) {
+    return e >= 0 ? Math.round(e) : e % .5 === 0 ? Math.floor(e) : Math.round(e)
 }
-var _C = Math.PI / 180;
+var yC = Math.PI / 180;
 
-function pd() {
-    let t = new G(2);
-    return G != Float32Array && (t[0] = 0, t[1] = 0), t
+function _d() {
+    let e = new G(2);
+    return G != Float32Array && (e[0] = 0, e[1] = 0), e
 }
 
-function Fy(t) {
-    let e = new G(2);
-    return e[0] = t[0], e[1] = t[1], e
+function Dy(e) {
+    let t = new G(2);
+    return t[0] = e[0], t[1] = e[1], t
 }
 
-function Dy(t, e) {
+function By(e, t) {
     let r = new G(2);
-    return r[0] = t, r[1] = e, r
+    return r[0] = e, r[1] = t, r
 }
 
-function ky(t, e) {
-    return t[0] = e[0], t[1] = e[1], t
+function Uy(e, t) {
+    return e[0] = t[0], e[1] = t[1], e
 }
 
-function By(t, e, r) {
-    return t[0] = e, t[1] = r, t
+function Ly(e, t, r) {
+    return e[0] = t, e[1] = r, e
 }
 
-function Uy(t, e, r) {
-    return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t
+function Vy(e, t, r) {
+    return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e
 }
 
-function gd(t, e, r) {
-    return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t
+function gd(e, t, r) {
+    return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e
 }
 
-function _d(t, e, r) {
-    return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t
+function md(e, t, r) {
+    return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e
 }
 
-function md(t, e, r) {
-    return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t
+function bd(e, t, r) {
+    return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e
 }
 
-function Ly(t, e) {
-    return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t
+function Wy(e, t) {
+    return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e
 }
 
-function Vy(t, e) {
-    return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t
+function zy(e, t) {
+    return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e
 }
 
-function Wy(t, e, r) {
-    return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t
+function jy(e, t, r) {
+    return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e
 }
 
-function zy(t, e, r) {
-    return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t
+function Hy(e, t, r) {
+    return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e
 }
 
-function Hy(t, e) {
-    return t[0] = Ve(e[0]), t[1] = Ve(e[1]), t
+function Xy(e, t) {
+    return e[0] = Vt(t[0]), e[1] = Vt(t[1]), e
 }
 
-function jy(t, e, r) {
-    return t[0] = e[0] * r, t[1] = e[1] * r, t
+function $y(e, t, r) {
+    return e[0] = t[0] * r, e[1] = t[1] * r, e
 }
 
-function Xy(t, e, r, s) {
-    return t[0] = e[0] + r[0] * s, t[1] = e[1] + r[1] * s, t
+function Yy(e, t, r, s) {
+    return e[0] = t[0] + r[0] * s, e[1] = t[1] + r[1] * s, e
 }
 
-function Td(t, e) {
-    let r = e[0] - t[0],
-        s = e[1] - t[1];
+function yd(e, t) {
+    let r = t[0] - e[0],
+        s = t[1] - e[1];
     return Math.sqrt(r * r + s * s)
 }
 
-function yd(t, e) {
-    let r = e[0] - t[0],
-        s = e[1] - t[1];
+function Td(e, t) {
+    let r = t[0] - e[0],
+        s = t[1] - e[1];
     return r * r + s * s
 }
 
-function bd(t) {
-    let e = t[0],
-        r = t[1];
-    return Math.sqrt(e * e + r * r)
+function wd(e) {
+    let t = e[0],
+        r = e[1];
+    return Math.sqrt(t * t + r * r)
 }
 
-function Ed(t) {
-    let e = t[0],
-        r = t[1];
-    return e * e + r * r
+function Ad(e) {
+    let t = e[0],
+        r = e[1];
+    return t * t + r * r
 }
 
-function $y(t, e) {
-    return t[0] = -e[0], t[1] = -e[1], t
+function qy(e, t) {
+    return e[0] = -t[0], e[1] = -t[1], e
 }
 
-function Yy(t, e) {
-    return t[0] = 1 / e[0], t[1] = 1 / e[1], t
+function Ky(e, t) {
+    return e[0] = 1 / t[0], e[1] = 1 / t[1], e
 }
 
-function qy(t, e) {
-    let r = e[0],
-        s = e[1],
+function Zy(e, t) {
+    let r = t[0],
+        s = t[1],
         i = r * r + s * s;
-    return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t
+    return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e
 }
 
-function Ky(t, e) {
-    return t[0] * e[0] + t[1] * e[1]
+function Qy(e, t) {
+    return e[0] * t[0] + e[1] * t[1]
 }
 
-function Zy(t, e, r) {
-    let s = e[0] * r[1] - e[1] * r[0];
-    return t[0] = t[1] = 0, t[2] = s, t
+function Jy(e, t, r) {
+    let s = t[0] * r[1] - t[1] * r[0];
+    return e[0] = e[1] = 0, e[2] = s, e
 }
 
-function Qy(t, e, r, s) {
-    let i = e[0],
-        n = e[1];
-    return t[0] = i + s * (r[0] - i), t[1] = n + s * (r[1] - n), t
+function Gy(e, t, r, s) {
+    let i = t[0],
+        n = t[1];
+    return e[0] = i + s * (r[0] - i), e[1] = n + s * (r[1] - n), e
 }
 
-function Jy(t, e) {
-    e = e === void 0 ? 1 : e;
-    let r = ct() * 2 * Math.PI;
-    return t[0] = Math.cos(r) * e, t[1] = Math.sin(r) * e, t
+function tT(e, t) {
+    t = t === void 0 ? 1 : t;
+    let r = ce() * 2 * Math.PI;
+    return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e
 }
 
-function Gy(t, e, r) {
-    let s = e[0],
-        i = e[1];
-    return t[0] = r[0] * s + r[2] * i, t[1] = r[1] * s + r[3] * i, t
+function eT(e, t, r) {
+    let s = t[0],
+        i = t[1];
+    return e[0] = r[0] * s + r[2] * i, e[1] = r[1] * s + r[3] * i, e
 }
 
-function e0(t, e, r) {
-    let s = e[0],
-        i = e[1];
-    return t[0] = r[0] * s + r[2] * i + r[4], t[1] = r[1] * s + r[3] * i + r[5], t
+function rT(e, t, r) {
+    let s = t[0],
+        i = t[1];
+    return e[0] = r[0] * s + r[2] * i + r[4], e[1] = r[1] * s + r[3] * i + r[5], e
 }
 
-function t0(t, e, r) {
-    let s = e[0],
-        i = e[1];
-    return t[0] = r[0] * s + r[3] * i + r[6], t[1] = r[1] * s + r[4] * i + r[7], t
+function sT(e, t, r) {
+    let s = t[0],
+        i = t[1];
+    return e[0] = r[0] * s + r[3] * i + r[6], e[1] = r[1] * s + r[4] * i + r[7], e
 }
 
-function Fl(t, e, r) {
-    let s = e[0],
-        i = e[1];
-    return t[0] = r[0] * s + r[4] * i + r[12], t[1] = r[1] * s + r[5] * i + r[13], t
+function Fl(e, t, r) {
+    let s = t[0],
+        i = t[1];
+    return e[0] = r[0] * s + r[4] * i + r[12], e[1] = r[1] * s + r[5] * i + r[13], e
 }
 
-function r0(t, e, r, s) {
-    let i = e[0] - r[0],
-        n = e[1] - r[1],
+function iT(e, t, r, s) {
+    let i = t[0] - r[0],
+        n = t[1] - r[1],
         o = Math.sin(s),
         a = Math.cos(s);
-    return t[0] = i * a - n * o + r[0], t[1] = i * o + n * a + r[1], t
+    return e[0] = i * a - n * o + r[0], e[1] = i * o + n * a + r[1], e
 }
 
-function s0(t, e) {
-    let r = t[0],
-        s = t[1],
-        i = e[0],
-        n = e[1],
+function nT(e, t) {
+    let r = e[0],
+        s = e[1],
+        i = t[0],
+        n = t[1],
         o = Math.sqrt((r * r + s * s) * (i * i + n * n)),
         a = o && (r * i + s * n) / o;
     return Math.acos(Math.min(Math.max(a, -1), 1))
 }
 
-function i0(t) {
-    return t[0] = 0, t[1] = 0, t
+function oT(e) {
+    return e[0] = 0, e[1] = 0, e
 }
 
-function n0(t) {
-    return `vec2(${t[0]}, ${t[1]})`
+function aT(e) {
+    return `vec2(${e[0]}, ${e[1]})`
 }
 
-function o0(t, e) {
-    return t[0] === e[0] && t[1] === e[1]
+function cT(e, t) {
+    return e[0] === t[0] && e[1] === t[1]
 }
 
-function a0(t, e) {
-    let r = t[0],
-        s = t[1],
-        i = e[0],
-        n = e[1];
+function lT(e, t) {
+    let r = e[0],
+        s = e[1],
+        i = t[0],
+        n = t[1];
     return Math.abs(r - i) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(s - n) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(n))
 }
-var c0 = bd,
-    l0 = gd,
-    h0 = _d,
-    f0 = md,
-    u0 = Td,
-    d0 = yd,
-    p0 = Ed,
-    g0 = function() {
-        let t = pd();
-        return function(e, r, s, i, n, o) {
+var fT = wd,
+    hT = gd,
+    uT = md,
+    dT = bd,
+    pT = yd,
+    _T = Td,
+    gT = Ad,
+    mT = function() {
+        let e = _d();
+        return function(t, r, s, i, n, o) {
             let a, c;
-            for (r || (r = 2), s || (s = 0), i ? c = Math.min(i * r + s, e.length) : c = e.length, a = s; a < c; a += r) t[0] = e[a], t[1] = e[a + 1], n(t, t, o), e[a] = t[0], e[a + 1] = t[1];
-            return e
+            for (r || (r = 2), s || (s = 0), i ? c = Math.min(i * r + s, t.length) : c = t.length, a = s; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], n(e, e, o), t[a] = e[0], t[a + 1] = e[1];
+            return t
         }
     }();
 
-function Ad(t, e, r) {
-    let s = e[0],
-        i = e[1],
+function Ed(e, t, r) {
+    let s = t[0],
+        i = t[1],
         n = r[3] * s + r[7] * i || 1;
-    return t[0] = (r[0] * s + r[4] * i) / n, t[1] = (r[1] * s + r[5] * i) / n, t
+    return e[0] = (r[0] * s + r[4] * i) / n, e[1] = (r[1] * s + r[5] * i) / n, e
 }
 
-function Oo(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
+function Oo(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
         o = r[3] * s + r[7] * i + r[11] * n || 1;
-    return t[0] = (r[0] * s + r[4] * i + r[8] * n) / o, t[1] = (r[1] * s + r[5] * i + r[9] * n) / o, t[2] = (r[2] * s + r[6] * i + r[10] * n) / o, t
+    return e[0] = (r[0] * s + r[4] * i + r[8] * n) / o, e[1] = (r[1] * s + r[5] * i + r[9] * n) / o, e[2] = (r[2] * s + r[6] * i + r[10] * n) / o, e
 }
 
-function xd(t, e, r) {
-    let s = e[0],
-        i = e[1];
-    return t[0] = r[0] * s + r[2] * i, t[1] = r[1] * s + r[3] * i, t[2] = e[2], t
+function xd(e, t, r) {
+    let s = t[0],
+        i = t[1];
+    return e[0] = r[0] * s + r[2] * i, e[1] = r[1] * s + r[3] * i, e[2] = t[2], e
 }
 var ss = {};
 Us(ss, {
-    add: () => b0,
+    add: () => AT,
     angle: () => zl,
-    bezier: () => F0,
-    ceil: () => E0,
-    clone: () => _0,
-    copy: () => T0,
+    bezier: () => DT,
+    ceil: () => ET,
+    clone: () => bT,
+    copy: () => TT,
     create: () => Sd,
-    cross: () => kl,
-    dist: () => H0,
-    distance: () => Pd,
-    div: () => z0,
-    divide: () => Md,
-    dot: () => Dl,
-    equals: () => L0,
-    exactEquals: () => U0,
-    floor: () => A0,
-    forEach: () => Y0,
-    fromValues: () => m0,
-    hermite: () => N0,
-    inverse: () => P0,
-    len: () => X0,
-    length: () => wd,
-    lerp: () => I0,
-    max: () => S0,
-    min: () => x0,
-    mul: () => W0,
-    multiply: () => vd,
-    negate: () => M0,
-    normalize: () => C0,
-    random: () => D0,
+    cross: () => Dl,
+    dist: () => XT,
+    distance: () => Cd,
+    div: () => HT,
+    divide: () => Pd,
+    dot: () => kl,
+    equals: () => WT,
+    exactEquals: () => VT,
+    floor: () => xT,
+    forEach: () => KT,
+    fromValues: () => yT,
+    hermite: () => kT,
+    inverse: () => IT,
+    len: () => YT,
+    length: () => Rd,
+    lerp: () => NT,
+    max: () => RT,
+    min: () => ST,
+    mul: () => jT,
+    multiply: () => Md,
+    negate: () => CT,
+    normalize: () => OT,
+    random: () => BT,
     rotateX: () => Ll,
     rotateY: () => Vl,
     rotateZ: () => Wl,
-    round: () => w0,
-    scale: () => R0,
-    scaleAndAdd: () => v0,
-    set: () => y0,
-    slerp: () => O0,
-    sqrDist: () => j0,
-    sqrLen: () => $0,
-    squaredDistance: () => Cd,
-    squaredLength: () => Id,
-    str: () => B0,
-    sub: () => V0,
-    subtract: () => Rd,
+    round: () => vT,
+    scale: () => MT,
+    scaleAndAdd: () => PT,
+    set: () => wT,
+    slerp: () => FT,
+    sqrDist: () => $T,
+    sqrLen: () => qT,
+    squaredDistance: () => Id,
+    squaredLength: () => Od,
+    str: () => LT,
+    sub: () => zT,
+    subtract: () => vd,
     transformMat3: () => Bl,
-    transformMat4: () => _i,
+    transformMat4: () => gi,
     transformQuat: () => Ul,
-    zero: () => k0
+    zero: () => UT
 });
 
 function Sd() {
-    let t = new G(3);
-    return G != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t
+    let e = new G(3);
+    return G != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e
 }
 
-function _0(t) {
-    let e = new G(3);
-    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
+function bT(e) {
+    let t = new G(3);
+    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
 }
 
-function wd(t) {
-    let e = t[0],
-        r = t[1],
-        s = t[2];
-    return Math.sqrt(e * e + r * r + s * s)
+function Rd(e) {
+    let t = e[0],
+        r = e[1],
+        s = e[2];
+    return Math.sqrt(t * t + r * r + s * s)
 }
 
-function m0(t, e, r) {
+function yT(e, t, r) {
     let s = new G(3);
-    return s[0] = t, s[1] = e, s[2] = r, s
+    return s[0] = e, s[1] = t, s[2] = r, s
 }
 
-function T0(t, e) {
-    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
+function TT(e, t) {
+    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
 }
 
-function y0(t, e, r, s) {
-    return t[0] = e, t[1] = r, t[2] = s, t
+function wT(e, t, r, s) {
+    return e[0] = t, e[1] = r, e[2] = s, e
 }
 
-function b0(t, e, r) {
-    return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t
+function AT(e, t, r) {
+    return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e
 }
 
-function Rd(t, e, r) {
-    return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t
+function vd(e, t, r) {
+    return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e
 }
 
-function vd(t, e, r) {
-    return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t
+function Md(e, t, r) {
+    return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e
 }
 
-function Md(t, e, r) {
-    return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t
+function Pd(e, t, r) {
+    return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e
 }
 
-function E0(t, e) {
-    return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t
+function ET(e, t) {
+    return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e
 }
 
-function A0(t, e) {
-    return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t
+function xT(e, t) {
+    return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e
 }
 
-function x0(t, e, r) {
-    return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t
+function ST(e, t, r) {
+    return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e
 }
 
-function S0(t, e, r) {
-    return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t
+function RT(e, t, r) {
+    return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e
 }
 
-function w0(t, e) {
-    return t[0] = Ve(e[0]), t[1] = Ve(e[1]), t[2] = Ve(e[2]), t
+function vT(e, t) {
+    return e[0] = Vt(t[0]), e[1] = Vt(t[1]), e[2] = Vt(t[2]), e
 }
 
-function R0(t, e, r) {
-    return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t
+function MT(e, t, r) {
+    return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e
 }
 
-function v0(t, e, r, s) {
-    return t[0] = e[0] + r[0] * s, t[1] = e[1] + r[1] * s, t[2] = e[2] + r[2] * s, t
+function PT(e, t, r, s) {
+    return e[0] = t[0] + r[0] * s, e[1] = t[1] + r[1] * s, e[2] = t[2] + r[2] * s, e
 }
 
-function Pd(t, e) {
-    let r = e[0] - t[0],
-        s = e[1] - t[1],
-        i = e[2] - t[2];
+function Cd(e, t) {
+    let r = t[0] - e[0],
+        s = t[1] - e[1],
+        i = t[2] - e[2];
     return Math.sqrt(r * r + s * s + i * i)
 }
 
-function Cd(t, e) {
-    let r = e[0] - t[0],
-        s = e[1] - t[1],
-        i = e[2] - t[2];
+function Id(e, t) {
+    let r = t[0] - e[0],
+        s = t[1] - e[1],
+        i = t[2] - e[2];
     return r * r + s * s + i * i
 }
 
-function Id(t) {
-    let e = t[0],
-        r = t[1],
-        s = t[2];
-    return e * e + r * r + s * s
+function Od(e) {
+    let t = e[0],
+        r = e[1],
+        s = e[2];
+    return t * t + r * r + s * s
 }
 
-function M0(t, e) {
-    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t
+function CT(e, t) {
+    return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e
 }
 
-function P0(t, e) {
-    return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t
+function IT(e, t) {
+    return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e
 }
 
-function C0(t, e) {
-    let r = e[0],
-        s = e[1],
-        i = e[2],
+function OT(e, t) {
+    let r = t[0],
+        s = t[1],
+        i = t[2],
         n = r * r + s * s + i * i;
-    return n > 0 && (n = 1 / Math.sqrt(n)), t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t
+    return n > 0 && (n = 1 / Math.sqrt(n)), e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
 }
 
-function Dl(t, e) {
-    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
+function kl(e, t) {
+    return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
 }
 
-function kl(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
+function Dl(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
         o = r[0],
         a = r[1],
         c = r[2];
-    return t[0] = i * c - n * a, t[1] = n * o - s * c, t[2] = s * a - i * o, t
+    return e[0] = i * c - n * a, e[1] = n * o - s * c, e[2] = s * a - i * o, e
 }
 
-function I0(t, e, r, s) {
-    let i = e[0],
-        n = e[1],
-        o = e[2];
-    return t[0] = i + s * (r[0] - i), t[1] = n + s * (r[1] - n), t[2] = o + s * (r[2] - o), t
+function NT(e, t, r, s) {
+    let i = t[0],
+        n = t[1],
+        o = t[2];
+    return e[0] = i + s * (r[0] - i), e[1] = n + s * (r[1] - n), e[2] = o + s * (r[2] - o), e
 }
 
-function O0(t, e, r, s) {
-    let i = Math.acos(Math.min(Math.max(Dl(e, r), -1), 1)),
+function FT(e, t, r, s) {
+    let i = Math.acos(Math.min(Math.max(kl(t, r), -1), 1)),
         n = Math.sin(i),
         o = Math.sin((1 - s) * i) / n,
         a = Math.sin(s * i) / n;
-    return t[0] = o * e[0] + a * r[0], t[1] = o * e[1] + a * r[1], t[2] = o * e[2] + a * r[2], t
+    return e[0] = o * t[0] + a * r[0], e[1] = o * t[1] + a * r[1], e[2] = o * t[2] + a * r[2], e
 }
 
-function N0(t, e, r, s, i, n) {
+function kT(e, t, r, s, i, n) {
     let o = n * n,
         a = o * (2 * n - 3) + 1,
         c = o * (n - 2) + n,
         l = o * (n - 1),
-        h = o * (3 - 2 * n);
-    return t[0] = e[0] * a + r[0] * c + s[0] * l + i[0] * h, t[1] = e[1] * a + r[1] * c + s[1] * l + i[1] * h, t[2] = e[2] * a + r[2] * c + s[2] * l + i[2] * h, t
+        f = o * (3 - 2 * n);
+    return e[0] = t[0] * a + r[0] * c + s[0] * l + i[0] * f, e[1] = t[1] * a + r[1] * c + s[1] * l + i[1] * f, e[2] = t[2] * a + r[2] * c + s[2] * l + i[2] * f, e
 }
 
-function F0(t, e, r, s, i, n) {
+function DT(e, t, r, s, i, n) {
     let o = 1 - n,
         a = o * o,
         c = n * n,
         l = a * o,
-        h = 3 * n * a,
+        f = 3 * n * a,
         d = 3 * c * o,
         p = c * n;
-    return t[0] = e[0] * l + r[0] * h + s[0] * d + i[0] * p, t[1] = e[1] * l + r[1] * h + s[1] * d + i[1] * p, t[2] = e[2] * l + r[2] * h + s[2] * d + i[2] * p, t
+    return e[0] = t[0] * l + r[0] * f + s[0] * d + i[0] * p, e[1] = t[1] * l + r[1] * f + s[1] * d + i[1] * p, e[2] = t[2] * l + r[2] * f + s[2] * d + i[2] * p, e
 }
 
-function D0(t, e) {
-    e = e === void 0 ? 1 : e;
-    let r = ct() * 2 * Math.PI,
-        s = ct() * 2 - 1,
-        i = Math.sqrt(1 - s * s) * e;
-    return t[0] = Math.cos(r) * i, t[1] = Math.sin(r) * i, t[2] = s * e, t
+function BT(e, t) {
+    t = t === void 0 ? 1 : t;
+    let r = ce() * 2 * Math.PI,
+        s = ce() * 2 - 1,
+        i = Math.sqrt(1 - s * s) * t;
+    return e[0] = Math.cos(r) * i, e[1] = Math.sin(r) * i, e[2] = s * t, e
 }
 
-function _i(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
+function gi(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
         o = r[3] * s + r[7] * i + r[11] * n + r[15];
-    return o = o || 1, t[0] = (r[0] * s + r[4] * i + r[8] * n + r[12]) / o, t[1] = (r[1] * s + r[5] * i + r[9] * n + r[13]) / o, t[2] = (r[2] * s + r[6] * i + r[10] * n + r[14]) / o, t
+    return o = o || 1, e[0] = (r[0] * s + r[4] * i + r[8] * n + r[12]) / o, e[1] = (r[1] * s + r[5] * i + r[9] * n + r[13]) / o, e[2] = (r[2] * s + r[6] * i + r[10] * n + r[14]) / o, e
 }
 
-function Bl(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2];
-    return t[0] = s * r[0] + i * r[3] + n * r[6], t[1] = s * r[1] + i * r[4] + n * r[7], t[2] = s * r[2] + i * r[5] + n * r[8], t
+function Bl(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2];
+    return e[0] = s * r[0] + i * r[3] + n * r[6], e[1] = s * r[1] + i * r[4] + n * r[7], e[2] = s * r[2] + i * r[5] + n * r[8], e
 }
 
-function Ul(t, e, r) {
+function Ul(e, t, r) {
     let s = r[0],
         i = r[1],
         n = r[2],
         o = r[3],
-        a = e[0],
-        c = e[1],
-        l = e[2],
-        h = i * l - n * c,
+        a = t[0],
+        c = t[1],
+        l = t[2],
+        f = i * l - n * c,
         d = n * a - s * l,
         p = s * c - i * a,
         m = i * p - n * d,
-        y = n * h - s * p,
-        x = s * d - i * h,
-        b = o * 2;
-    return h *= b, d *= b, p *= b, m *= 2, y *= 2, x *= 2, t[0] = a + h + m, t[1] = c + d + y, t[2] = l + p + x, t
+        y = n * f - s * p,
+        E = s * d - i * f,
+        T = o * 2;
+    return f *= T, d *= T, p *= T, m *= 2, y *= 2, E *= 2, e[0] = a + f + m, e[1] = c + d + y, e[2] = l + p + E, e
 }
 
-function Ll(t, e, r, s) {
+function Ll(e, t, r, s) {
     let i = [],
         n = [];
-    return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], n[0] = i[0], n[1] = i[1] * Math.cos(s) - i[2] * Math.sin(s), n[2] = i[1] * Math.sin(s) + i[2] * Math.cos(s), t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t
+    return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], n[0] = i[0], n[1] = i[1] * Math.cos(s) - i[2] * Math.sin(s), n[2] = i[1] * Math.sin(s) + i[2] * Math.cos(s), e[0] = n[0] + r[0], e[1] = n[1] + r[1], e[2] = n[2] + r[2], e
 }
 
-function Vl(t, e, r, s) {
+function Vl(e, t, r, s) {
     let i = [],
         n = [];
-    return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], n[0] = i[2] * Math.sin(s) + i[0] * Math.cos(s), n[1] = i[1], n[2] = i[2] * Math.cos(s) - i[0] * Math.sin(s), t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t
+    return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], n[0] = i[2] * Math.sin(s) + i[0] * Math.cos(s), n[1] = i[1], n[2] = i[2] * Math.cos(s) - i[0] * Math.sin(s), e[0] = n[0] + r[0], e[1] = n[1] + r[1], e[2] = n[2] + r[2], e
 }
 
-function Wl(t, e, r, s) {
+function Wl(e, t, r, s) {
     let i = [],
         n = [];
-    return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], n[0] = i[0] * Math.cos(s) - i[1] * Math.sin(s), n[1] = i[0] * Math.sin(s) + i[1] * Math.cos(s), n[2] = i[2], t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t
+    return i[0] = t[0] - r[0], i[1] = t[1] - r[1], i[2] = t[2] - r[2], n[0] = i[0] * Math.cos(s) - i[1] * Math.sin(s), n[1] = i[0] * Math.sin(s) + i[1] * Math.cos(s), n[2] = i[2], e[0] = n[0] + r[0], e[1] = n[1] + r[1], e[2] = n[2] + r[2], e
 }
 
-function zl(t, e) {
-    let r = t[0],
-        s = t[1],
-        i = t[2],
-        n = e[0],
-        o = e[1],
-        a = e[2],
+function zl(e, t) {
+    let r = e[0],
+        s = e[1],
+        i = e[2],
+        n = t[0],
+        o = t[1],
+        a = t[2],
         c = Math.sqrt((r * r + s * s + i * i) * (n * n + o * o + a * a)),
-        l = c && Dl(t, e) / c;
+        l = c && kl(e, t) / c;
     return Math.acos(Math.min(Math.max(l, -1), 1))
 }
 
-function k0(t) {
-    return t[0] = 0, t[1] = 0, t[2] = 0, t
+function UT(e) {
+    return e[0] = 0, e[1] = 0, e[2] = 0, e
 }
 
-function B0(t) {
-    return `vec3(${t[0]}, ${t[1]}, ${t[2]})`
+function LT(e) {
+    return `vec3(${e[0]}, ${e[1]}, ${e[2]})`
 }
 
-function U0(t, e) {
-    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
+function VT(e, t) {
+    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
 }
 
-function L0(t, e) {
-    let r = t[0],
-        s = t[1],
-        i = t[2],
-        n = e[0],
-        o = e[1],
-        a = e[2];
+function WT(e, t) {
+    let r = e[0],
+        s = e[1],
+        i = e[2],
+        n = t[0],
+        o = t[1],
+        a = t[2];
     return Math.abs(r - n) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(n)) && Math.abs(s - o) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(i - a) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(a))
 }
-var V0 = Rd,
-    W0 = vd,
-    z0 = Md,
-    H0 = Pd,
-    j0 = Cd,
-    X0 = wd,
-    $0 = Id,
-    Y0 = function() {
-        let t = Sd();
-        return function(e, r, s, i, n, o) {
+var zT = vd,
+    jT = Md,
+    HT = Pd,
+    XT = Cd,
+    $T = Id,
+    YT = Rd,
+    qT = Od,
+    KT = function() {
+        let e = Sd();
+        return function(t, r, s, i, n, o) {
             let a, c;
-            for (r || (r = 3), s || (s = 0), i ? c = Math.min(i * r + s, e.length) : c = e.length, a = s; a < c; a += r) t[0] = e[a], t[1] = e[a + 1], t[2] = e[a + 2], n(t, t, o), e[a] = t[0], e[a + 1] = t[1], e[a + 2] = t[2];
-            return e
+            for (r || (r = 3), s || (s = 0), i ? c = Math.min(i * r + s, t.length) : c = t.length, a = s; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], n(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];
+            return t
         }
     }();
-var Hl = [0, 0, 0],
-    No, _e = class t extends Co {
+var jl = [0, 0, 0],
+    No, gt = class e extends Co {
         static get ZERO() {
-            return No || (No = new t(0, 0, 0), Object.freeze(No)), No
+            return No || (No = new e(0, 0, 0), Object.freeze(No)), No
         }
-        constructor(e = 0, r = 0, s = 0) {
-            super(-0, -0, -0), arguments.length === 1 && St(e) ? this.copy(e) : (ae.debug && (ge(e), ge(r), ge(s)), this[0] = e, this[1] = r, this[2] = s)
+        constructor(t = 0, r = 0, s = 0) {
+            super(-0, -0, -0), arguments.length === 1 && xe(t) ? this.copy(t) : (at.debug && (_t(t), _t(r), _t(s)), this[0] = t, this[1] = r, this[2] = s)
         }
-        set(e, r, s) {
-            return this[0] = e, this[1] = r, this[2] = s, this.check()
+        set(t, r, s) {
+            return this[0] = t, this[1] = r, this[2] = s, this.check()
         }
-        copy(e) {
-            return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check()
+        copy(t) {
+            return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check()
         }
-        fromObject(e) {
-            return ae.debug && (ge(e.x), ge(e.y), ge(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check()
+        fromObject(t) {
+            return at.debug && (_t(t.x), _t(t.y), _t(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check()
         }
-        toObject(e) {
-            return e.x = this[0], e.y = this[1], e.z = this[2], e
+        toObject(t) {
+            return t.x = this[0], t.y = this[1], t.z = this[2], t
         }
         get ELEMENTS() {
             return 3
         }
         get z() {
             return this[2]
         }
-        set z(e) {
-            this[2] = ge(e)
+        set z(t) {
+            this[2] = _t(t)
         }
-        angle(e) {
-            return zl(this, e)
+        angle(t) {
+            return zl(this, t)
         }
-        cross(e) {
-            return kl(this, this, e), this.check()
+        cross(t) {
+            return Dl(this, this, t), this.check()
         }
         rotateX({
-            radians: e,
-            origin: r = Hl
+            radians: t,
+            origin: r = jl
         }) {
-            return Ll(this, this, r, e), this.check()
+            return Ll(this, this, r, t), this.check()
         }
         rotateY({
-            radians: e,
-            origin: r = Hl
+            radians: t,
+            origin: r = jl
         }) {
-            return Vl(this, this, r, e), this.check()
+            return Vl(this, this, r, t), this.check()
         }
         rotateZ({
-            radians: e,
-            origin: r = Hl
+            radians: t,
+            origin: r = jl
         }) {
-            return Wl(this, this, r, e), this.check()
+            return Wl(this, this, r, t), this.check()
         }
-        transform(e) {
-            return this.transformAsPoint(e)
+        transform(t) {
+            return this.transformAsPoint(t)
         }
-        transformAsPoint(e) {
-            return _i(this, this, e), this.check()
+        transformAsPoint(t) {
+            return gi(this, this, t), this.check()
         }
-        transformAsVector(e) {
-            return Oo(this, this, e), this.check()
+        transformAsVector(t) {
+            return Oo(this, this, t), this.check()
         }
-        transformByMatrix3(e) {
-            return Bl(this, this, e), this.check()
+        transformByMatrix3(t) {
+            return Bl(this, this, t), this.check()
         }
-        transformByMatrix2(e) {
-            return xd(this, this, e), this.check()
+        transformByMatrix2(t) {
+            return xd(this, this, t), this.check()
         }
-        transformByQuaternion(e) {
-            return Ul(this, this, e), this.check()
+        transformByQuaternion(t) {
+            return Ul(this, this, t), this.check()
         }
     };
 var Fo = class extends rs {
     toString() {
-        let e = "[";
-        if (ae.printRowMajor) {
-            e += "row-major:";
+        let t = "[";
+        if (at.printRowMajor) {
+            t += "row-major:";
             for (let r = 0; r < this.RANK; ++r)
-                for (let s = 0; s < this.RANK; ++s) e += ` ${this[s*this.RANK+r]}`
+                for (let s = 0; s < this.RANK; ++s) t += ` ${this[s*this.RANK+r]}`
         } else {
-            e += "column-major:";
-            for (let r = 0; r < this.ELEMENTS; ++r) e += ` ${this[r]}`
+            t += "column-major:";
+            for (let r = 0; r < this.ELEMENTS; ++r) t += ` ${this[r]}`
         }
-        return e += "]", e
+        return t += "]", t
     }
-    getElementIndex(e, r) {
-        return r * this.RANK + e
+    getElementIndex(t, r) {
+        return r * this.RANK + t
     }
-    getElement(e, r) {
-        return this[r * this.RANK + e]
+    getElement(t, r) {
+        return this[r * this.RANK + t]
     }
-    setElement(e, r, s) {
-        return this[r * this.RANK + e] = ge(s), this
+    setElement(t, r, s) {
+        return this[r * this.RANK + t] = _t(s), this
     }
-    getColumn(e, r = new Array(this.RANK).fill(-0)) {
-        let s = e * this.RANK;
+    getColumn(t, r = new Array(this.RANK).fill(-0)) {
+        let s = t * this.RANK;
         for (let i = 0; i < this.RANK; ++i) r[i] = this[s + i];
         return r
     }
-    setColumn(e, r) {
-        let s = e * this.RANK;
+    setColumn(t, r) {
+        let s = t * this.RANK;
         for (let i = 0; i < this.RANK; ++i) this[s + i] = r[i];
         return this
     }
 };
-var ne = {};
-Us(ne, {
-    add: () => Tb,
-    adjoint: () => G0,
-    clone: () => K0,
-    copy: () => Z0,
-    create: () => q0,
-    decompose: () => lb,
+var nt = {};
+Us(nt, {
+    add: () => T0,
+    adjoint: () => e0,
+    clone: () => QT,
+    copy: () => JT,
+    create: () => ZT,
+    decompose: () => h0,
     determinant: () => $l,
-    equals: () => Ab,
-    exactEquals: () => Eb,
-    frob: () => mb,
+    equals: () => x0,
+    exactEquals: () => E0,
+    frob: () => y0,
     fromQuat: () => Gl,
-    fromQuat2: () => ob,
-    fromRotation: () => rb,
-    fromRotationTranslation: () => Nd,
-    fromRotationTranslationScale: () => hb,
-    fromRotationTranslationScaleOrigin: () => fb,
-    fromScaling: () => tb,
-    fromTranslation: () => eb,
-    fromValues: () => Q0,
-    fromXRotation: () => sb,
-    fromYRotation: () => ib,
-    fromZRotation: () => nb,
-    frustum: () => eh,
-    getRotation: () => cb,
-    getScaling: () => Fd,
-    getTranslation: () => ab,
-    identity: () => Od,
+    fromQuat2: () => c0,
+    fromRotation: () => i0,
+    fromRotationTranslation: () => Fd,
+    fromRotationTranslationScale: () => u0,
+    fromRotationTranslationScaleOrigin: () => d0,
+    fromScaling: () => s0,
+    fromTranslation: () => r0,
+    fromValues: () => GT,
+    fromXRotation: () => n0,
+    fromYRotation: () => o0,
+    fromZRotation: () => a0,
+    frustum: () => tf,
+    getRotation: () => f0,
+    getScaling: () => kd,
+    getTranslation: () => l0,
+    identity: () => Nd,
     invert: () => Xl,
-    lookAt: () => sh,
-    mul: () => xb,
+    lookAt: () => sf,
+    mul: () => S0,
     multiply: () => mi,
-    multiplyScalar: () => yb,
-    multiplyScalarAndAdd: () => bb,
-    ortho: () => rh,
-    orthoNO: () => kd,
-    orthoZO: () => pb,
-    perspective: () => th,
-    perspectiveFromFieldOfView: () => db,
+    multiplyScalar: () => w0,
+    multiplyScalarAndAdd: () => A0,
+    ortho: () => rf,
+    orthoNO: () => Bd,
+    orthoZO: () => g0,
+    perspective: () => ef,
+    perspectiveFromFieldOfView: () => _0,
     perspectiveNO: () => Dd,
-    perspectiveZO: () => ub,
+    perspectiveZO: () => p0,
     rotate: () => Kl,
     rotateX: () => Zl,
     rotateY: () => Ql,
     rotateZ: () => Jl,
     scale: () => ql,
-    set: () => J0,
-    str: () => _b,
-    sub: () => Sb,
-    subtract: () => Bd,
-    targetTo: () => gb,
+    set: () => t0,
+    str: () => b0,
+    sub: () => R0,
+    subtract: () => Ud,
+    targetTo: () => m0,
     translate: () => Yl,
-    transpose: () => jl
+    transpose: () => Hl
 });
 
-function q0() {
-    let t = new G(16);
-    return G != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t
-}
-
-function K0(t) {
+function ZT() {
     let e = new G(16);
-    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
+    return G != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
 }
 
-function Z0(t, e) {
+function QT(e) {
+    let t = new G(16);
     return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
 }
 
-function Q0(t, e, r, s, i, n, o, a, c, l, h, d, p, m, y, x) {
-    let b = new G(16);
-    return b[0] = t, b[1] = e, b[2] = r, b[3] = s, b[4] = i, b[5] = n, b[6] = o, b[7] = a, b[8] = c, b[9] = l, b[10] = h, b[11] = d, b[12] = p, b[13] = m, b[14] = y, b[15] = x, b
+function JT(e, t) {
+    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
+}
+
+function GT(e, t, r, s, i, n, o, a, c, l, f, d, p, m, y, E) {
+    let T = new G(16);
+    return T[0] = e, T[1] = t, T[2] = r, T[3] = s, T[4] = i, T[5] = n, T[6] = o, T[7] = a, T[8] = c, T[9] = l, T[10] = f, T[11] = d, T[12] = p, T[13] = m, T[14] = y, T[15] = E, T
 }
 
-function J0(t, e, r, s, i, n, o, a, c, l, h, d, p, m, y, x, b) {
-    return t[0] = e, t[1] = r, t[2] = s, t[3] = i, t[4] = n, t[5] = o, t[6] = a, t[7] = c, t[8] = l, t[9] = h, t[10] = d, t[11] = p, t[12] = m, t[13] = y, t[14] = x, t[15] = b, t
+function t0(e, t, r, s, i, n, o, a, c, l, f, d, p, m, y, E, T) {
+    return e[0] = t, e[1] = r, e[2] = s, e[3] = i, e[4] = n, e[5] = o, e[6] = a, e[7] = c, e[8] = l, e[9] = f, e[10] = d, e[11] = p, e[12] = m, e[13] = y, e[14] = E, e[15] = T, e
 }
 
-function Od(t) {
-    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+function Nd(e) {
+    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function jl(t, e) {
-    if (t === e) {
-        let r = e[1],
-            s = e[2],
-            i = e[3],
-            n = e[6],
-            o = e[7],
-            a = e[11];
-        t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = r, t[6] = e[9], t[7] = e[13], t[8] = s, t[9] = n, t[11] = e[14], t[12] = i, t[13] = o, t[14] = a
-    } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
-    return t
+function Hl(e, t) {
+    if (e === t) {
+        let r = t[1],
+            s = t[2],
+            i = t[3],
+            n = t[6],
+            o = t[7],
+            a = t[11];
+        e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = n, e[11] = t[14], e[12] = i, e[13] = o, e[14] = a
+    } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
+    return e
 }
 
-function Xl(t, e) {
-    let r = e[0],
-        s = e[1],
-        i = e[2],
-        n = e[3],
-        o = e[4],
-        a = e[5],
-        c = e[6],
-        l = e[7],
-        h = e[8],
-        d = e[9],
-        p = e[10],
-        m = e[11],
-        y = e[12],
-        x = e[13],
-        b = e[14],
-        w = e[15],
+function Xl(e, t) {
+    let r = t[0],
+        s = t[1],
+        i = t[2],
+        n = t[3],
+        o = t[4],
+        a = t[5],
+        c = t[6],
+        l = t[7],
+        f = t[8],
+        d = t[9],
+        p = t[10],
+        m = t[11],
+        y = t[12],
+        E = t[13],
+        T = t[14],
+        S = t[15],
         R = r * a - s * o,
         v = r * c - i * o,
         C = r * l - n * o,
         O = s * c - i * a,
         N = s * l - n * a,
         U = i * l - n * c,
-        k = h * x - d * y,
-        B = h * b - p * y,
-        F = h * w - m * y,
-        L = d * b - p * x,
-        Y = d * w - m * x,
-        $ = p * w - m * b,
-        j = R * $ - v * Y + C * L + O * F - N * B + U * k;
-    return j ? (j = 1 / j, t[0] = (a * $ - c * Y + l * L) * j, t[1] = (i * Y - s * $ - n * L) * j, t[2] = (x * U - b * N + w * O) * j, t[3] = (p * N - d * U - m * O) * j, t[4] = (c * F - o * $ - l * B) * j, t[5] = (r * $ - i * F + n * B) * j, t[6] = (b * C - y * U - w * v) * j, t[7] = (h * U - p * C + m * v) * j, t[8] = (o * Y - a * F + l * k) * j, t[9] = (s * F - r * Y - n * k) * j, t[10] = (y * N - x * C + w * R) * j, t[11] = (d * C - h * N - m * R) * j, t[12] = (a * B - o * L - c * k) * j, t[13] = (r * L - s * B + i * k) * j, t[14] = (x * v - y * O - b * R) * j, t[15] = (h * O - d * v + p * R) * j, t) : null
+        D = f * E - d * y,
+        B = f * T - p * y,
+        F = f * S - m * y,
+        L = d * T - p * E,
+        Y = d * S - m * E,
+        $ = p * S - m * T,
+        H = R * $ - v * Y + C * L + O * F - N * B + U * D;
+    return H ? (H = 1 / H, e[0] = (a * $ - c * Y + l * L) * H, e[1] = (i * Y - s * $ - n * L) * H, e[2] = (E * U - T * N + S * O) * H, e[3] = (p * N - d * U - m * O) * H, e[4] = (c * F - o * $ - l * B) * H, e[5] = (r * $ - i * F + n * B) * H, e[6] = (T * C - y * U - S * v) * H, e[7] = (f * U - p * C + m * v) * H, e[8] = (o * Y - a * F + l * D) * H, e[9] = (s * F - r * Y - n * D) * H, e[10] = (y * N - E * C + S * R) * H, e[11] = (d * C - f * N - m * R) * H, e[12] = (a * B - o * L - c * D) * H, e[13] = (r * L - s * B + i * D) * H, e[14] = (E * v - y * O - T * R) * H, e[15] = (f * O - d * v + p * R) * H, e) : null
 }
 
-function G0(t, e) {
-    let r = e[0],
-        s = e[1],
-        i = e[2],
-        n = e[3],
-        o = e[4],
-        a = e[5],
-        c = e[6],
-        l = e[7],
-        h = e[8],
-        d = e[9],
-        p = e[10],
-        m = e[11],
-        y = e[12],
-        x = e[13],
-        b = e[14],
-        w = e[15],
+function e0(e, t) {
+    let r = t[0],
+        s = t[1],
+        i = t[2],
+        n = t[3],
+        o = t[4],
+        a = t[5],
+        c = t[6],
+        l = t[7],
+        f = t[8],
+        d = t[9],
+        p = t[10],
+        m = t[11],
+        y = t[12],
+        E = t[13],
+        T = t[14],
+        S = t[15],
         R = r * a - s * o,
         v = r * c - i * o,
         C = r * l - n * o,
         O = s * c - i * a,
         N = s * l - n * a,
         U = i * l - n * c,
-        k = h * x - d * y,
-        B = h * b - p * y,
-        F = h * w - m * y,
-        L = d * b - p * x,
-        Y = d * w - m * x,
-        $ = p * w - m * b;
-    return t[0] = a * $ - c * Y + l * L, t[1] = i * Y - s * $ - n * L, t[2] = x * U - b * N + w * O, t[3] = p * N - d * U - m * O, t[4] = c * F - o * $ - l * B, t[5] = r * $ - i * F + n * B, t[6] = b * C - y * U - w * v, t[7] = h * U - p * C + m * v, t[8] = o * Y - a * F + l * k, t[9] = s * F - r * Y - n * k, t[10] = y * N - x * C + w * R, t[11] = d * C - h * N - m * R, t[12] = a * B - o * L - c * k, t[13] = r * L - s * B + i * k, t[14] = x * v - y * O - b * R, t[15] = h * O - d * v + p * R, t
+        D = f * E - d * y,
+        B = f * T - p * y,
+        F = f * S - m * y,
+        L = d * T - p * E,
+        Y = d * S - m * E,
+        $ = p * S - m * T;
+    return e[0] = a * $ - c * Y + l * L, e[1] = i * Y - s * $ - n * L, e[2] = E * U - T * N + S * O, e[3] = p * N - d * U - m * O, e[4] = c * F - o * $ - l * B, e[5] = r * $ - i * F + n * B, e[6] = T * C - y * U - S * v, e[7] = f * U - p * C + m * v, e[8] = o * Y - a * F + l * D, e[9] = s * F - r * Y - n * D, e[10] = y * N - E * C + S * R, e[11] = d * C - f * N - m * R, e[12] = a * B - o * L - c * D, e[13] = r * L - s * B + i * D, e[14] = E * v - y * O - T * R, e[15] = f * O - d * v + p * R, e
 }
 
-function $l(t) {
-    let e = t[0],
-        r = t[1],
-        s = t[2],
-        i = t[3],
-        n = t[4],
-        o = t[5],
-        a = t[6],
-        c = t[7],
-        l = t[8],
-        h = t[9],
-        d = t[10],
-        p = t[11],
-        m = t[12],
-        y = t[13],
-        x = t[14],
-        b = t[15],
-        w = e * o - r * n,
-        R = e * a - s * n,
+function $l(e) {
+    let t = e[0],
+        r = e[1],
+        s = e[2],
+        i = e[3],
+        n = e[4],
+        o = e[5],
+        a = e[6],
+        c = e[7],
+        l = e[8],
+        f = e[9],
+        d = e[10],
+        p = e[11],
+        m = e[12],
+        y = e[13],
+        E = e[14],
+        T = e[15],
+        S = t * o - r * n,
+        R = t * a - s * n,
         v = r * a - s * o,
-        C = l * y - h * m,
-        O = l * x - d * m,
-        N = h * x - d * y,
-        U = e * N - r * O + s * C,
-        k = n * N - o * O + a * C,
-        B = l * v - h * R + d * w,
-        F = m * v - y * R + x * w;
-    return c * U - i * k + b * B - p * F
-}
-
-function mi(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
-        o = e[3],
-        a = e[4],
-        c = e[5],
-        l = e[6],
-        h = e[7],
-        d = e[8],
-        p = e[9],
-        m = e[10],
-        y = e[11],
-        x = e[12],
-        b = e[13],
-        w = e[14],
-        R = e[15],
+        C = l * y - f * m,
+        O = l * E - d * m,
+        N = f * E - d * y,
+        U = t * N - r * O + s * C,
+        D = n * N - o * O + a * C,
+        B = l * v - f * R + d * S,
+        F = m * v - y * R + E * S;
+    return c * U - i * D + T * B - p * F
+}
+
+function mi(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
+        o = t[3],
+        a = t[4],
+        c = t[5],
+        l = t[6],
+        f = t[7],
+        d = t[8],
+        p = t[9],
+        m = t[10],
+        y = t[11],
+        E = t[12],
+        T = t[13],
+        S = t[14],
+        R = t[15],
         v = r[0],
         C = r[1],
         O = r[2],
         N = r[3];
-    return t[0] = v * s + C * a + O * d + N * x, t[1] = v * i + C * c + O * p + N * b, t[2] = v * n + C * l + O * m + N * w, t[3] = v * o + C * h + O * y + N * R, v = r[4], C = r[5], O = r[6], N = r[7], t[4] = v * s + C * a + O * d + N * x, t[5] = v * i + C * c + O * p + N * b, t[6] = v * n + C * l + O * m + N * w, t[7] = v * o + C * h + O * y + N * R, v = r[8], C = r[9], O = r[10], N = r[11], t[8] = v * s + C * a + O * d + N * x, t[9] = v * i + C * c + O * p + N * b, t[10] = v * n + C * l + O * m + N * w, t[11] = v * o + C * h + O * y + N * R, v = r[12], C = r[13], O = r[14], N = r[15], t[12] = v * s + C * a + O * d + N * x, t[13] = v * i + C * c + O * p + N * b, t[14] = v * n + C * l + O * m + N * w, t[15] = v * o + C * h + O * y + N * R, t
+    return e[0] = v * s + C * a + O * d + N * E, e[1] = v * i + C * c + O * p + N * T, e[2] = v * n + C * l + O * m + N * S, e[3] = v * o + C * f + O * y + N * R, v = r[4], C = r[5], O = r[6], N = r[7], e[4] = v * s + C * a + O * d + N * E, e[5] = v * i + C * c + O * p + N * T, e[6] = v * n + C * l + O * m + N * S, e[7] = v * o + C * f + O * y + N * R, v = r[8], C = r[9], O = r[10], N = r[11], e[8] = v * s + C * a + O * d + N * E, e[9] = v * i + C * c + O * p + N * T, e[10] = v * n + C * l + O * m + N * S, e[11] = v * o + C * f + O * y + N * R, v = r[12], C = r[13], O = r[14], N = r[15], e[12] = v * s + C * a + O * d + N * E, e[13] = v * i + C * c + O * p + N * T, e[14] = v * n + C * l + O * m + N * S, e[15] = v * o + C * f + O * y + N * R, e
 }
 
-function Yl(t, e, r) {
+function Yl(e, t, r) {
     let s = r[0],
         i = r[1],
         n = r[2],
-        o, a, c, l, h, d, p, m, y, x, b, w;
-    return e === t ? (t[12] = e[0] * s + e[4] * i + e[8] * n + e[12], t[13] = e[1] * s + e[5] * i + e[9] * n + e[13], t[14] = e[2] * s + e[6] * i + e[10] * n + e[14], t[15] = e[3] * s + e[7] * i + e[11] * n + e[15]) : (o = e[0], a = e[1], c = e[2], l = e[3], h = e[4], d = e[5], p = e[6], m = e[7], y = e[8], x = e[9], b = e[10], w = e[11], t[0] = o, t[1] = a, t[2] = c, t[3] = l, t[4] = h, t[5] = d, t[6] = p, t[7] = m, t[8] = y, t[9] = x, t[10] = b, t[11] = w, t[12] = o * s + h * i + y * n + e[12], t[13] = a * s + d * i + x * n + e[13], t[14] = c * s + p * i + b * n + e[14], t[15] = l * s + m * i + w * n + e[15]), t
+        o, a, c, l, f, d, p, m, y, E, T, S;
+    return t === e ? (e[12] = t[0] * s + t[4] * i + t[8] * n + t[12], e[13] = t[1] * s + t[5] * i + t[9] * n + t[13], e[14] = t[2] * s + t[6] * i + t[10] * n + t[14], e[15] = t[3] * s + t[7] * i + t[11] * n + t[15]) : (o = t[0], a = t[1], c = t[2], l = t[3], f = t[4], d = t[5], p = t[6], m = t[7], y = t[8], E = t[9], T = t[10], S = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = l, e[4] = f, e[5] = d, e[6] = p, e[7] = m, e[8] = y, e[9] = E, e[10] = T, e[11] = S, e[12] = o * s + f * i + y * n + t[12], e[13] = a * s + d * i + E * n + t[13], e[14] = c * s + p * i + T * n + t[14], e[15] = l * s + m * i + S * n + t[15]), e
 }
 
-function ql(t, e, r) {
+function ql(e, t, r) {
     let s = r[0],
         i = r[1],
         n = r[2];
-    return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
+    return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * n, e[9] = t[9] * n, e[10] = t[10] * n, e[11] = t[11] * n, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
 }
 
-function Kl(t, e, r, s) {
+function Kl(e, t, r, s) {
     let i = s[0],
         n = s[1],
         o = s[2],
         a = Math.sqrt(i * i + n * n + o * o),
-        c, l, h, d, p, m, y, x, b, w, R, v, C, O, N, U, k, B, F, L, Y, $, j, de;
-    return a < 1e-6 ? null : (a = 1 / a, i *= a, n *= a, o *= a, l = Math.sin(r), c = Math.cos(r), h = 1 - c, d = e[0], p = e[1], m = e[2], y = e[3], x = e[4], b = e[5], w = e[6], R = e[7], v = e[8], C = e[9], O = e[10], N = e[11], U = i * i * h + c, k = n * i * h + o * l, B = o * i * h - n * l, F = i * n * h - o * l, L = n * n * h + c, Y = o * n * h + i * l, $ = i * o * h + n * l, j = n * o * h - i * l, de = o * o * h + c, t[0] = d * U + x * k + v * B, t[1] = p * U + b * k + C * B, t[2] = m * U + w * k + O * B, t[3] = y * U + R * k + N * B, t[4] = d * F + x * L + v * Y, t[5] = p * F + b * L + C * Y, t[6] = m * F + w * L + O * Y, t[7] = y * F + R * L + N * Y, t[8] = d * $ + x * j + v * de, t[9] = p * $ + b * j + C * de, t[10] = m * $ + w * j + O * de, t[11] = y * $ + R * j + N * de, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t)
+        c, l, f, d, p, m, y, E, T, S, R, v, C, O, N, U, D, B, F, L, Y, $, H, dt;
+    return a < 1e-6 ? null : (a = 1 / a, i *= a, n *= a, o *= a, l = Math.sin(r), c = Math.cos(r), f = 1 - c, d = t[0], p = t[1], m = t[2], y = t[3], E = t[4], T = t[5], S = t[6], R = t[7], v = t[8], C = t[9], O = t[10], N = t[11], U = i * i * f + c, D = n * i * f + o * l, B = o * i * f - n * l, F = i * n * f - o * l, L = n * n * f + c, Y = o * n * f + i * l, $ = i * o * f + n * l, H = n * o * f - i * l, dt = o * o * f + c, e[0] = d * U + E * D + v * B, e[1] = p * U + T * D + C * B, e[2] = m * U + S * D + O * B, e[3] = y * U + R * D + N * B, e[4] = d * F + E * L + v * Y, e[5] = p * F + T * L + C * Y, e[6] = m * F + S * L + O * Y, e[7] = y * F + R * L + N * Y, e[8] = d * $ + E * H + v * dt, e[9] = p * $ + T * H + C * dt, e[10] = m * $ + S * H + O * dt, e[11] = y * $ + R * H + N * dt, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e)
 }
 
-function Zl(t, e, r) {
+function Zl(e, t, r) {
     let s = Math.sin(r),
         i = Math.cos(r),
-        n = e[4],
-        o = e[5],
-        a = e[6],
-        c = e[7],
-        l = e[8],
-        h = e[9],
-        d = e[10],
-        p = e[11];
-    return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = n * i + l * s, t[5] = o * i + h * s, t[6] = a * i + d * s, t[7] = c * i + p * s, t[8] = l * i - n * s, t[9] = h * i - o * s, t[10] = d * i - a * s, t[11] = p * i - c * s, t
+        n = t[4],
+        o = t[5],
+        a = t[6],
+        c = t[7],
+        l = t[8],
+        f = t[9],
+        d = t[10],
+        p = t[11];
+    return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = n * i + l * s, e[5] = o * i + f * s, e[6] = a * i + d * s, e[7] = c * i + p * s, e[8] = l * i - n * s, e[9] = f * i - o * s, e[10] = d * i - a * s, e[11] = p * i - c * s, e
 }
 
-function Ql(t, e, r) {
+function Ql(e, t, r) {
     let s = Math.sin(r),
         i = Math.cos(r),
-        n = e[0],
-        o = e[1],
-        a = e[2],
-        c = e[3],
-        l = e[8],
-        h = e[9],
-        d = e[10],
-        p = e[11];
-    return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = n * i - l * s, t[1] = o * i - h * s, t[2] = a * i - d * s, t[3] = c * i - p * s, t[8] = n * s + l * i, t[9] = o * s + h * i, t[10] = a * s + d * i, t[11] = c * s + p * i, t
+        n = t[0],
+        o = t[1],
+        a = t[2],
+        c = t[3],
+        l = t[8],
+        f = t[9],
+        d = t[10],
+        p = t[11];
+    return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = n * i - l * s, e[1] = o * i - f * s, e[2] = a * i - d * s, e[3] = c * i - p * s, e[8] = n * s + l * i, e[9] = o * s + f * i, e[10] = a * s + d * i, e[11] = c * s + p * i, e
 }
 
-function Jl(t, e, r) {
+function Jl(e, t, r) {
     let s = Math.sin(r),
         i = Math.cos(r),
-        n = e[0],
-        o = e[1],
-        a = e[2],
-        c = e[3],
-        l = e[4],
-        h = e[5],
-        d = e[6],
-        p = e[7];
-    return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = n * i + l * s, t[1] = o * i + h * s, t[2] = a * i + d * s, t[3] = c * i + p * s, t[4] = l * i - n * s, t[5] = h * i - o * s, t[6] = d * i - a * s, t[7] = p * i - c * s, t
+        n = t[0],
+        o = t[1],
+        a = t[2],
+        c = t[3],
+        l = t[4],
+        f = t[5],
+        d = t[6],
+        p = t[7];
+    return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = n * i + l * s, e[1] = o * i + f * s, e[2] = a * i + d * s, e[3] = c * i + p * s, e[4] = l * i - n * s, e[5] = f * i - o * s, e[6] = d * i - a * s, e[7] = p * i - c * s, e
 }
 
-function eb(t, e) {
-    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t
+function r0(e, t) {
+    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e
 }
 
-function tb(t, e) {
-    return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+function s0(e, t) {
+    return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function rb(t, e, r) {
+function i0(e, t, r) {
     let s = r[0],
         i = r[1],
         n = r[2],
         o = Math.sqrt(s * s + i * i + n * n),
         a, c, l;
-    return o < 1e-6 ? null : (o = 1 / o, s *= o, i *= o, n *= o, c = Math.sin(e), a = Math.cos(e), l = 1 - a, t[0] = s * s * l + a, t[1] = i * s * l + n * c, t[2] = n * s * l - i * c, t[3] = 0, t[4] = s * i * l - n * c, t[5] = i * i * l + a, t[6] = n * i * l + s * c, t[7] = 0, t[8] = s * n * l + i * c, t[9] = i * n * l - s * c, t[10] = n * n * l + a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
+    return o < 1e-6 ? null : (o = 1 / o, s *= o, i *= o, n *= o, c = Math.sin(t), a = Math.cos(t), l = 1 - a, e[0] = s * s * l + a, e[1] = i * s * l + n * c, e[2] = n * s * l - i * c, e[3] = 0, e[4] = s * i * l - n * c, e[5] = i * i * l + a, e[6] = n * i * l + s * c, e[7] = 0, e[8] = s * n * l + i * c, e[9] = i * n * l - s * c, e[10] = n * n * l + a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e)
 }
 
-function sb(t, e) {
-    let r = Math.sin(e),
-        s = Math.cos(e);
-    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+function n0(e, t) {
+    let r = Math.sin(t),
+        s = Math.cos(t);
+    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function ib(t, e) {
-    let r = Math.sin(e),
-        s = Math.cos(e);
-    return t[0] = s, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+function o0(e, t) {
+    let r = Math.sin(t),
+        s = Math.cos(t);
+    return e[0] = s, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function nb(t, e) {
-    let r = Math.sin(e),
-        s = Math.cos(e);
-    return t[0] = s, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = s, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+function a0(e, t) {
+    let r = Math.sin(t),
+        s = Math.cos(t);
+    return e[0] = s, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function Nd(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
-        o = e[3],
+function Fd(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
+        o = t[3],
         a = s + s,
         c = i + i,
         l = n + n,
-        h = s * a,
+        f = s * a,
         d = s * c,
         p = s * l,
         m = i * c,
         y = i * l,
-        x = n * l,
-        b = o * a,
-        w = o * c,
+        E = n * l,
+        T = o * a,
+        S = o * c,
         R = o * l;
-    return t[0] = 1 - (m + x), t[1] = d + R, t[2] = p - w, t[3] = 0, t[4] = d - R, t[5] = 1 - (h + x), t[6] = y + b, t[7] = 0, t[8] = p + w, t[9] = y - b, t[10] = 1 - (h + m), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t
+    return e[0] = 1 - (m + E), e[1] = d + R, e[2] = p - S, e[3] = 0, e[4] = d - R, e[5] = 1 - (f + E), e[6] = y + T, e[7] = 0, e[8] = p + S, e[9] = y - T, e[10] = 1 - (f + m), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e
 }
 
-function ob(t, e) {
+function c0(e, t) {
     let r = new G(3),
-        s = -e[0],
-        i = -e[1],
-        n = -e[2],
-        o = e[3],
-        a = e[4],
-        c = e[5],
-        l = e[6],
-        h = e[7],
+        s = -t[0],
+        i = -t[1],
+        n = -t[2],
+        o = t[3],
+        a = t[4],
+        c = t[5],
+        l = t[6],
+        f = t[7],
         d = s * s + i * i + n * n + o * o;
-    return d > 0 ? (r[0] = (a * o + h * s + c * n - l * i) * 2 / d, r[1] = (c * o + h * i + l * s - a * n) * 2 / d, r[2] = (l * o + h * n + a * i - c * s) * 2 / d) : (r[0] = (a * o + h * s + c * n - l * i) * 2, r[1] = (c * o + h * i + l * s - a * n) * 2, r[2] = (l * o + h * n + a * i - c * s) * 2), Nd(t, e, r), t
+    return d > 0 ? (r[0] = (a * o + f * s + c * n - l * i) * 2 / d, r[1] = (c * o + f * i + l * s - a * n) * 2 / d, r[2] = (l * o + f * n + a * i - c * s) * 2 / d) : (r[0] = (a * o + f * s + c * n - l * i) * 2, r[1] = (c * o + f * i + l * s - a * n) * 2, r[2] = (l * o + f * n + a * i - c * s) * 2), Fd(e, t, r), e
 }
 
-function ab(t, e) {
-    return t[0] = e[12], t[1] = e[13], t[2] = e[14], t
+function l0(e, t) {
+    return e[0] = t[12], e[1] = t[13], e[2] = t[14], e
 }
 
-function Fd(t, e) {
-    let r = e[0],
-        s = e[1],
-        i = e[2],
-        n = e[4],
-        o = e[5],
-        a = e[6],
-        c = e[8],
-        l = e[9],
-        h = e[10];
-    return t[0] = Math.sqrt(r * r + s * s + i * i), t[1] = Math.sqrt(n * n + o * o + a * a), t[2] = Math.sqrt(c * c + l * l + h * h), t
+function kd(e, t) {
+    let r = t[0],
+        s = t[1],
+        i = t[2],
+        n = t[4],
+        o = t[5],
+        a = t[6],
+        c = t[8],
+        l = t[9],
+        f = t[10];
+    return e[0] = Math.sqrt(r * r + s * s + i * i), e[1] = Math.sqrt(n * n + o * o + a * a), e[2] = Math.sqrt(c * c + l * l + f * f), e
 }
 
-function cb(t, e) {
+function f0(e, t) {
     let r = new G(3);
-    Fd(r, e);
+    kd(r, t);
     let s = 1 / r[0],
         i = 1 / r[1],
         n = 1 / r[2],
-        o = e[0] * s,
-        a = e[1] * i,
-        c = e[2] * n,
-        l = e[4] * s,
-        h = e[5] * i,
-        d = e[6] * n,
-        p = e[8] * s,
-        m = e[9] * i,
-        y = e[10] * n,
-        x = o + h + y,
-        b = 0;
-    return x > 0 ? (b = Math.sqrt(x + 1) * 2, t[3] = .25 * b, t[0] = (d - m) / b, t[1] = (p - c) / b, t[2] = (a - l) / b) : o > h && o > y ? (b = Math.sqrt(1 + o - h - y) * 2, t[3] = (d - m) / b, t[0] = .25 * b, t[1] = (a + l) / b, t[2] = (p + c) / b) : h > y ? (b = Math.sqrt(1 + h - o - y) * 2, t[3] = (p - c) / b, t[0] = (a + l) / b, t[1] = .25 * b, t[2] = (d + m) / b) : (b = Math.sqrt(1 + y - o - h) * 2, t[3] = (a - l) / b, t[0] = (p + c) / b, t[1] = (d + m) / b, t[2] = .25 * b), t
+        o = t[0] * s,
+        a = t[1] * i,
+        c = t[2] * n,
+        l = t[4] * s,
+        f = t[5] * i,
+        d = t[6] * n,
+        p = t[8] * s,
+        m = t[9] * i,
+        y = t[10] * n,
+        E = o + f + y,
+        T = 0;
+    return E > 0 ? (T = Math.sqrt(E + 1) * 2, e[3] = .25 * T, e[0] = (d - m) / T, e[1] = (p - c) / T, e[2] = (a - l) / T) : o > f && o > y ? (T = Math.sqrt(1 + o - f - y) * 2, e[3] = (d - m) / T, e[0] = .25 * T, e[1] = (a + l) / T, e[2] = (p + c) / T) : f > y ? (T = Math.sqrt(1 + f - o - y) * 2, e[3] = (p - c) / T, e[0] = (a + l) / T, e[1] = .25 * T, e[2] = (d + m) / T) : (T = Math.sqrt(1 + y - o - f) * 2, e[3] = (a - l) / T, e[0] = (p + c) / T, e[1] = (d + m) / T, e[2] = .25 * T), e
 }
 
-function lb(t, e, r, s) {
-    e[0] = s[12], e[1] = s[13], e[2] = s[14];
+function h0(e, t, r, s) {
+    t[0] = s[12], t[1] = s[13], t[2] = s[14];
     let i = s[0],
         n = s[1],
         o = s[2],
         a = s[4],
         c = s[5],
         l = s[6],
-        h = s[8],
+        f = s[8],
         d = s[9],
         p = s[10];
-    r[0] = Math.sqrt(i * i + n * n + o * o), r[1] = Math.sqrt(a * a + c * c + l * l), r[2] = Math.sqrt(h * h + d * d + p * p);
+    r[0] = Math.sqrt(i * i + n * n + o * o), r[1] = Math.sqrt(a * a + c * c + l * l), r[2] = Math.sqrt(f * f + d * d + p * p);
     let m = 1 / r[0],
         y = 1 / r[1],
-        x = 1 / r[2],
-        b = i * m,
-        w = n * y,
-        R = o * x,
+        E = 1 / r[2],
+        T = i * m,
+        S = n * y,
+        R = o * E,
         v = a * m,
         C = c * y,
-        O = l * x,
-        N = h * m,
+        O = l * E,
+        N = f * m,
         U = d * y,
-        k = p * x,
-        B = b + C + k,
+        D = p * E,
+        B = T + C + D,
         F = 0;
-    return B > 0 ? (F = Math.sqrt(B + 1) * 2, t[3] = .25 * F, t[0] = (O - U) / F, t[1] = (N - R) / F, t[2] = (w - v) / F) : b > C && b > k ? (F = Math.sqrt(1 + b - C - k) * 2, t[3] = (O - U) / F, t[0] = .25 * F, t[1] = (w + v) / F, t[2] = (N + R) / F) : C > k ? (F = Math.sqrt(1 + C - b - k) * 2, t[3] = (N - R) / F, t[0] = (w + v) / F, t[1] = .25 * F, t[2] = (O + U) / F) : (F = Math.sqrt(1 + k - b - C) * 2, t[3] = (w - v) / F, t[0] = (N + R) / F, t[1] = (O + U) / F, t[2] = .25 * F), t
+    return B > 0 ? (F = Math.sqrt(B + 1) * 2, e[3] = .25 * F, e[0] = (O - U) / F, e[1] = (N - R) / F, e[2] = (S - v) / F) : T > C && T > D ? (F = Math.sqrt(1 + T - C - D) * 2, e[3] = (O - U) / F, e[0] = .25 * F, e[1] = (S + v) / F, e[2] = (N + R) / F) : C > D ? (F = Math.sqrt(1 + C - T - D) * 2, e[3] = (N - R) / F, e[0] = (S + v) / F, e[1] = .25 * F, e[2] = (O + U) / F) : (F = Math.sqrt(1 + D - T - C) * 2, e[3] = (S - v) / F, e[0] = (N + R) / F, e[1] = (O + U) / F, e[2] = .25 * F), e
 }
 
-function hb(t, e, r, s) {
-    let i = e[0],
-        n = e[1],
-        o = e[2],
-        a = e[3],
+function u0(e, t, r, s) {
+    let i = t[0],
+        n = t[1],
+        o = t[2],
+        a = t[3],
         c = i + i,
         l = n + n,
-        h = o + o,
+        f = o + o,
         d = i * c,
         p = i * l,
-        m = i * h,
+        m = i * f,
         y = n * l,
-        x = n * h,
-        b = o * h,
-        w = a * c,
+        E = n * f,
+        T = o * f,
+        S = a * c,
         R = a * l,
-        v = a * h,
+        v = a * f,
         C = s[0],
         O = s[1],
         N = s[2];
-    return t[0] = (1 - (y + b)) * C, t[1] = (p + v) * C, t[2] = (m - R) * C, t[3] = 0, t[4] = (p - v) * O, t[5] = (1 - (d + b)) * O, t[6] = (x + w) * O, t[7] = 0, t[8] = (m + R) * N, t[9] = (x - w) * N, t[10] = (1 - (d + y)) * N, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t
+    return e[0] = (1 - (y + T)) * C, e[1] = (p + v) * C, e[2] = (m - R) * C, e[3] = 0, e[4] = (p - v) * O, e[5] = (1 - (d + T)) * O, e[6] = (E + S) * O, e[7] = 0, e[8] = (m + R) * N, e[9] = (E - S) * N, e[10] = (1 - (d + y)) * N, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e
 }
 
-function fb(t, e, r, s, i) {
-    let n = e[0],
-        o = e[1],
-        a = e[2],
-        c = e[3],
+function d0(e, t, r, s, i) {
+    let n = t[0],
+        o = t[1],
+        a = t[2],
+        c = t[3],
         l = n + n,
-        h = o + o,
+        f = o + o,
         d = a + a,
         p = n * l,
-        m = n * h,
+        m = n * f,
         y = n * d,
-        x = o * h,
-        b = o * d,
-        w = a * d,
+        E = o * f,
+        T = o * d,
+        S = a * d,
         R = c * l,
-        v = c * h,
+        v = c * f,
         C = c * d,
         O = s[0],
         N = s[1],
         U = s[2],
-        k = i[0],
+        D = i[0],
         B = i[1],
         F = i[2],
-        L = (1 - (x + w)) * O,
+        L = (1 - (E + S)) * O,
         Y = (m + C) * O,
         $ = (y - v) * O,
-        j = (m - C) * N,
-        de = (1 - (p + w)) * N,
-        Nt = (b + R) * N,
+        H = (m - C) * N,
+        dt = (1 - (p + S)) * N,
+        Ne = (T + R) * N,
         ar = (y + v) * U,
-        Ps = (b - R) * U,
-        _n = (1 - (p + x)) * U;
-    return t[0] = L, t[1] = Y, t[2] = $, t[3] = 0, t[4] = j, t[5] = de, t[6] = Nt, t[7] = 0, t[8] = ar, t[9] = Ps, t[10] = _n, t[11] = 0, t[12] = r[0] + k - (L * k + j * B + ar * F), t[13] = r[1] + B - (Y * k + de * B + Ps * F), t[14] = r[2] + F - ($ * k + Nt * B + _n * F), t[15] = 1, t
+        Ps = (T - R) * U,
+        gn = (1 - (p + E)) * U;
+    return e[0] = L, e[1] = Y, e[2] = $, e[3] = 0, e[4] = H, e[5] = dt, e[6] = Ne, e[7] = 0, e[8] = ar, e[9] = Ps, e[10] = gn, e[11] = 0, e[12] = r[0] + D - (L * D + H * B + ar * F), e[13] = r[1] + B - (Y * D + dt * B + Ps * F), e[14] = r[2] + F - ($ * D + Ne * B + gn * F), e[15] = 1, e
 }
 
-function Gl(t, e) {
-    let r = e[0],
-        s = e[1],
-        i = e[2],
-        n = e[3],
+function Gl(e, t) {
+    let r = t[0],
+        s = t[1],
+        i = t[2],
+        n = t[3],
         o = r + r,
         a = s + s,
         c = i + i,
         l = r * o,
-        h = s * o,
+        f = s * o,
         d = s * a,
         p = i * o,
         m = i * a,
         y = i * c,
-        x = n * o,
-        b = n * a,
-        w = n * c;
-    return t[0] = 1 - d - y, t[1] = h + w, t[2] = p - b, t[3] = 0, t[4] = h - w, t[5] = 1 - l - y, t[6] = m + x, t[7] = 0, t[8] = p + b, t[9] = m - x, t[10] = 1 - l - d, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+        E = n * o,
+        T = n * a,
+        S = n * c;
+    return e[0] = 1 - d - y, e[1] = f + S, e[2] = p - T, e[3] = 0, e[4] = f - S, e[5] = 1 - l - y, e[6] = m + E, e[7] = 0, e[8] = p + T, e[9] = m - E, e[10] = 1 - l - d, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function eh(t, e, r, s, i, n, o) {
-    let a = 1 / (r - e),
+function tf(e, t, r, s, i, n, o) {
+    let a = 1 / (r - t),
         c = 1 / (i - s),
         l = 1 / (n - o);
-    return t[0] = n * 2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n * 2 * c, t[6] = 0, t[7] = 0, t[8] = (r + e) * a, t[9] = (i + s) * c, t[10] = (o + n) * l, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * n * 2 * l, t[15] = 0, t
+    return e[0] = n * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n * 2 * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (i + s) * c, e[10] = (o + n) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * n * 2 * l, e[15] = 0, e
 }
 
-function Dd(t, e, r, s, i) {
-    let n = 1 / Math.tan(e / 2);
-    if (t[0] = n / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, i != null && i !== 1 / 0) {
+function Dd(e, t, r, s, i) {
+    let n = 1 / Math.tan(t / 2);
+    if (e[0] = n / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, i != null && i !== 1 / 0) {
         let o = 1 / (s - i);
-        t[10] = (i + s) * o, t[14] = 2 * i * s * o
-    } else t[10] = -1, t[14] = -2 * s;
-    return t
+        e[10] = (i + s) * o, e[14] = 2 * i * s * o
+    } else e[10] = -1, e[14] = -2 * s;
+    return e
 }
-var th = Dd;
+var ef = Dd;
 
-function ub(t, e, r, s, i) {
-    let n = 1 / Math.tan(e / 2);
-    if (t[0] = n / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, i != null && i !== 1 / 0) {
+function p0(e, t, r, s, i) {
+    let n = 1 / Math.tan(t / 2);
+    if (e[0] = n / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, i != null && i !== 1 / 0) {
         let o = 1 / (s - i);
-        t[10] = i * o, t[14] = i * s * o
-    } else t[10] = -1, t[14] = -s;
-    return t
+        e[10] = i * o, e[14] = i * s * o
+    } else e[10] = -1, e[14] = -s;
+    return e
 }
 
-function db(t, e, r, s) {
-    let i = Math.tan(e.upDegrees * Math.PI / 180),
-        n = Math.tan(e.downDegrees * Math.PI / 180),
-        o = Math.tan(e.leftDegrees * Math.PI / 180),
-        a = Math.tan(e.rightDegrees * Math.PI / 180),
+function _0(e, t, r, s) {
+    let i = Math.tan(t.upDegrees * Math.PI / 180),
+        n = Math.tan(t.downDegrees * Math.PI / 180),
+        o = Math.tan(t.leftDegrees * Math.PI / 180),
+        a = Math.tan(t.rightDegrees * Math.PI / 180),
         c = 2 / (o + a),
         l = 2 / (i + n);
-    return t[0] = c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = l, t[6] = 0, t[7] = 0, t[8] = -((o - a) * c * .5), t[9] = (i - n) * l * .5, t[10] = s / (r - s), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = s * r / (r - s), t[15] = 0, t
+    return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = l, e[6] = 0, e[7] = 0, e[8] = -((o - a) * c * .5), e[9] = (i - n) * l * .5, e[10] = s / (r - s), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * r / (r - s), e[15] = 0, e
 }
 
-function kd(t, e, r, s, i, n, o) {
-    let a = 1 / (e - r),
+function Bd(e, t, r, s, i, n, o) {
+    let a = 1 / (t - r),
         c = 1 / (s - i),
         l = 1 / (n - o);
-    return t[0] = -2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + r) * a, t[13] = (i + s) * c, t[14] = (o + n) * l, t[15] = 1, t
+    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * l, e[11] = 0, e[12] = (t + r) * a, e[13] = (i + s) * c, e[14] = (o + n) * l, e[15] = 1, e
 }
-var rh = kd;
+var rf = Bd;
 
-function pb(t, e, r, s, i, n, o) {
-    let a = 1 / (e - r),
+function g0(e, t, r, s, i, n, o) {
+    let a = 1 / (t - r),
         c = 1 / (s - i),
         l = 1 / (n - o);
-    return t[0] = -2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = l, t[11] = 0, t[12] = (e + r) * a, t[13] = (i + s) * c, t[14] = n * l, t[15] = 1, t
+    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = l, e[11] = 0, e[12] = (t + r) * a, e[13] = (i + s) * c, e[14] = n * l, e[15] = 1, e
 }
 
-function sh(t, e, r, s) {
-    let i, n, o, a, c, l, h, d, p, m, y = e[0],
-        x = e[1],
-        b = e[2],
-        w = s[0],
+function sf(e, t, r, s) {
+    let i, n, o, a, c, l, f, d, p, m, y = t[0],
+        E = t[1],
+        T = t[2],
+        S = s[0],
         R = s[1],
         v = s[2],
         C = r[0],
         O = r[1],
         N = r[2];
-    return Math.abs(y - C) < 1e-6 && Math.abs(x - O) < 1e-6 && Math.abs(b - N) < 1e-6 ? Od(t) : (d = y - C, p = x - O, m = b - N, i = 1 / Math.sqrt(d * d + p * p + m * m), d *= i, p *= i, m *= i, n = R * m - v * p, o = v * d - w * m, a = w * p - R * d, i = Math.sqrt(n * n + o * o + a * a), i ? (i = 1 / i, n *= i, o *= i, a *= i) : (n = 0, o = 0, a = 0), c = p * a - m * o, l = m * n - d * a, h = d * o - p * n, i = Math.sqrt(c * c + l * l + h * h), i ? (i = 1 / i, c *= i, l *= i, h *= i) : (c = 0, l = 0, h = 0), t[0] = n, t[1] = c, t[2] = d, t[3] = 0, t[4] = o, t[5] = l, t[6] = p, t[7] = 0, t[8] = a, t[9] = h, t[10] = m, t[11] = 0, t[12] = -(n * y + o * x + a * b), t[13] = -(c * y + l * x + h * b), t[14] = -(d * y + p * x + m * b), t[15] = 1, t)
+    return Math.abs(y - C) < 1e-6 && Math.abs(E - O) < 1e-6 && Math.abs(T - N) < 1e-6 ? Nd(e) : (d = y - C, p = E - O, m = T - N, i = 1 / Math.sqrt(d * d + p * p + m * m), d *= i, p *= i, m *= i, n = R * m - v * p, o = v * d - S * m, a = S * p - R * d, i = Math.sqrt(n * n + o * o + a * a), i ? (i = 1 / i, n *= i, o *= i, a *= i) : (n = 0, o = 0, a = 0), c = p * a - m * o, l = m * n - d * a, f = d * o - p * n, i = Math.sqrt(c * c + l * l + f * f), i ? (i = 1 / i, c *= i, l *= i, f *= i) : (c = 0, l = 0, f = 0), e[0] = n, e[1] = c, e[2] = d, e[3] = 0, e[4] = o, e[5] = l, e[6] = p, e[7] = 0, e[8] = a, e[9] = f, e[10] = m, e[11] = 0, e[12] = -(n * y + o * E + a * T), e[13] = -(c * y + l * E + f * T), e[14] = -(d * y + p * E + m * T), e[15] = 1, e)
 }
 
-function gb(t, e, r, s) {
-    let i = e[0],
-        n = e[1],
-        o = e[2],
+function m0(e, t, r, s) {
+    let i = t[0],
+        n = t[1],
+        o = t[2],
         a = s[0],
         c = s[1],
         l = s[2],
-        h = i - r[0],
+        f = i - r[0],
         d = n - r[1],
         p = o - r[2],
-        m = h * h + d * d + p * p;
-    m > 0 && (m = 1 / Math.sqrt(m), h *= m, d *= m, p *= m);
+        m = f * f + d * d + p * p;
+    m > 0 && (m = 1 / Math.sqrt(m), f *= m, d *= m, p *= m);
     let y = c * p - l * d,
-        x = l * h - a * p,
-        b = a * d - c * h;
-    return m = y * y + x * x + b * b, m > 0 && (m = 1 / Math.sqrt(m), y *= m, x *= m, b *= m), t[0] = y, t[1] = x, t[2] = b, t[3] = 0, t[4] = d * b - p * x, t[5] = p * y - h * b, t[6] = h * x - d * y, t[7] = 0, t[8] = h, t[9] = d, t[10] = p, t[11] = 0, t[12] = i, t[13] = n, t[14] = o, t[15] = 1, t
+        E = l * f - a * p,
+        T = a * d - c * f;
+    return m = y * y + E * E + T * T, m > 0 && (m = 1 / Math.sqrt(m), y *= m, E *= m, T *= m), e[0] = y, e[1] = E, e[2] = T, e[3] = 0, e[4] = d * T - p * E, e[5] = p * y - f * T, e[6] = f * E - d * y, e[7] = 0, e[8] = f, e[9] = d, e[10] = p, e[11] = 0, e[12] = i, e[13] = n, e[14] = o, e[15] = 1, e
 }
 
-function _b(t) {
-    return `mat4(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}, ${t[4]}, ${t[5]}, ${t[6]}, ${t[7]}, ${t[8]}, ${t[9]}, ${t[10]}, ${t[11]}, ${t[12]}, ${t[13]}, ${t[14]}, ${t[15]})`
+function b0(e) {
+    return `mat4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]}, ${e[4]}, ${e[5]}, ${e[6]}, ${e[7]}, ${e[8]}, ${e[9]}, ${e[10]}, ${e[11]}, ${e[12]}, ${e[13]}, ${e[14]}, ${e[15]})`
 }
 
-function mb(t) {
-    return Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2] + t[3] * t[3] + t[4] * t[4] + t[5] * t[5] + t[6] * t[6] + t[7] * t[7] + t[8] * t[8] + t[9] * t[9] + t[10] * t[10] + t[11] * t[11] + t[12] * t[12] + t[13] * t[13] + t[14] * t[14] + t[15] * t[15])
+function y0(e) {
+    return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8] + e[9] * e[9] + e[10] * e[10] + e[11] * e[11] + e[12] * e[12] + e[13] * e[13] + e[14] * e[14] + e[15] * e[15])
 }
 
-function Tb(t, e, r) {
-    return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t[8] = e[8] + r[8], t[9] = e[9] + r[9], t[10] = e[10] + r[10], t[11] = e[11] + r[11], t[12] = e[12] + r[12], t[13] = e[13] + r[13], t[14] = e[14] + r[14], t[15] = e[15] + r[15], t
+function T0(e, t, r) {
+    return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e
 }
 
-function Bd(t, e, r) {
-    return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t[6] = e[6] - r[6], t[7] = e[7] - r[7], t[8] = e[8] - r[8], t[9] = e[9] - r[9], t[10] = e[10] - r[10], t[11] = e[11] - r[11], t[12] = e[12] - r[12], t[13] = e[13] - r[13], t[14] = e[14] - r[14], t[15] = e[15] - r[15], t
+function Ud(e, t, r) {
+    return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e
 }
 
-function yb(t, e, r) {
-    return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * r, t[9] = e[9] * r, t[10] = e[10] * r, t[11] = e[11] * r, t[12] = e[12] * r, t[13] = e[13] * r, t[14] = e[14] * r, t[15] = e[15] * r, t
+function w0(e, t, r) {
+    return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e
 }
 
-function bb(t, e, r, s) {
-    return t[0] = e[0] + r[0] * s, t[1] = e[1] + r[1] * s, t[2] = e[2] + r[2] * s, t[3] = e[3] + r[3] * s, t[4] = e[4] + r[4] * s, t[5] = e[5] + r[5] * s, t[6] = e[6] + r[6] * s, t[7] = e[7] + r[7] * s, t[8] = e[8] + r[8] * s, t[9] = e[9] + r[9] * s, t[10] = e[10] + r[10] * s, t[11] = e[11] + r[11] * s, t[12] = e[12] + r[12] * s, t[13] = e[13] + r[13] * s, t[14] = e[14] + r[14] * s, t[15] = e[15] + r[15] * s, t
+function A0(e, t, r, s) {
+    return e[0] = t[0] + r[0] * s, e[1] = t[1] + r[1] * s, e[2] = t[2] + r[2] * s, e[3] = t[3] + r[3] * s, e[4] = t[4] + r[4] * s, e[5] = t[5] + r[5] * s, e[6] = t[6] + r[6] * s, e[7] = t[7] + r[7] * s, e[8] = t[8] + r[8] * s, e[9] = t[9] + r[9] * s, e[10] = t[10] + r[10] * s, e[11] = t[11] + r[11] * s, e[12] = t[12] + r[12] * s, e[13] = t[13] + r[13] * s, e[14] = t[14] + r[14] * s, e[15] = t[15] + r[15] * s, e
 }
 
-function Eb(t, e) {
-    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15]
+function E0(e, t) {
+    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
 }
 
-function Ab(t, e) {
-    let r = t[0],
-        s = t[1],
-        i = t[2],
-        n = t[3],
-        o = t[4],
-        a = t[5],
-        c = t[6],
-        l = t[7],
-        h = t[8],
-        d = t[9],
-        p = t[10],
-        m = t[11],
-        y = t[12],
-        x = t[13],
-        b = t[14],
-        w = t[15],
-        R = e[0],
-        v = e[1],
-        C = e[2],
-        O = e[3],
-        N = e[4],
-        U = e[5],
-        k = e[6],
-        B = e[7],
-        F = e[8],
-        L = e[9],
-        Y = e[10],
-        $ = e[11],
-        j = e[12],
-        de = e[13],
-        Nt = e[14],
-        ar = e[15];
-    return Math.abs(r - R) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(R)) && Math.abs(s - v) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(v)) && Math.abs(i - C) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(C)) && Math.abs(n - O) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(O)) && Math.abs(o - N) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(N)) && Math.abs(a - U) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(U)) && Math.abs(c - k) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(k)) && Math.abs(l - B) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(B)) && Math.abs(h - F) <= 1e-6 * Math.max(1, Math.abs(h), Math.abs(F)) && Math.abs(d - L) <= 1e-6 * Math.max(1, Math.abs(d), Math.abs(L)) && Math.abs(p - Y) <= 1e-6 * Math.max(1, Math.abs(p), Math.abs(Y)) && Math.abs(m - $) <= 1e-6 * Math.max(1, Math.abs(m), Math.abs($)) && Math.abs(y - j) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(j)) && Math.abs(x - de) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(de)) && Math.abs(b - Nt) <= 1e-6 * Math.max(1, Math.abs(b), Math.abs(Nt)) && Math.abs(w - ar) <= 1e-6 * Math.max(1, Math.abs(w), Math.abs(ar))
-}
-var xb = mi,
-    Sb = Bd;
-var ht = {};
-Us(ht, {
-    add: () => Pb,
-    ceil: () => Cb,
-    clone: () => wb,
-    copy: () => vb,
-    create: () => Ud,
-    cross: () => Wb,
-    dist: () => Jb,
-    distance: () => zd,
-    div: () => Qb,
-    divide: () => Wd,
-    dot: () => Vb,
-    equals: () => qb,
-    exactEquals: () => Yb,
-    floor: () => Ib,
-    forEach: () => rE,
-    fromValues: () => Rb,
-    inverse: () => Ub,
-    len: () => eE,
-    length: () => jd,
-    lerp: () => zb,
-    max: () => Nb,
-    min: () => Ob,
-    mul: () => Zb,
-    multiply: () => Vd,
-    negate: () => Bb,
-    normalize: () => Lb,
-    random: () => Hb,
-    round: () => Fb,
-    scale: () => Db,
-    scaleAndAdd: () => kb,
-    set: () => Mb,
-    sqrDist: () => Gb,
-    sqrLen: () => tE,
+function x0(e, t) {
+    let r = e[0],
+        s = e[1],
+        i = e[2],
+        n = e[3],
+        o = e[4],
+        a = e[5],
+        c = e[6],
+        l = e[7],
+        f = e[8],
+        d = e[9],
+        p = e[10],
+        m = e[11],
+        y = e[12],
+        E = e[13],
+        T = e[14],
+        S = e[15],
+        R = t[0],
+        v = t[1],
+        C = t[2],
+        O = t[3],
+        N = t[4],
+        U = t[5],
+        D = t[6],
+        B = t[7],
+        F = t[8],
+        L = t[9],
+        Y = t[10],
+        $ = t[11],
+        H = t[12],
+        dt = t[13],
+        Ne = t[14],
+        ar = t[15];
+    return Math.abs(r - R) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(R)) && Math.abs(s - v) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(v)) && Math.abs(i - C) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(C)) && Math.abs(n - O) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(O)) && Math.abs(o - N) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(N)) && Math.abs(a - U) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(U)) && Math.abs(c - D) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(D)) && Math.abs(l - B) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(B)) && Math.abs(f - F) <= 1e-6 * Math.max(1, Math.abs(f), Math.abs(F)) && Math.abs(d - L) <= 1e-6 * Math.max(1, Math.abs(d), Math.abs(L)) && Math.abs(p - Y) <= 1e-6 * Math.max(1, Math.abs(p), Math.abs(Y)) && Math.abs(m - $) <= 1e-6 * Math.max(1, Math.abs(m), Math.abs($)) && Math.abs(y - H) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(H)) && Math.abs(E - dt) <= 1e-6 * Math.max(1, Math.abs(E), Math.abs(dt)) && Math.abs(T - Ne) <= 1e-6 * Math.max(1, Math.abs(T), Math.abs(Ne)) && Math.abs(S - ar) <= 1e-6 * Math.max(1, Math.abs(S), Math.abs(ar))
+}
+var S0 = mi,
+    R0 = Ud;
+var fe = {};
+Us(fe, {
+    add: () => I0,
+    ceil: () => O0,
+    clone: () => v0,
+    copy: () => P0,
+    create: () => Ld,
+    cross: () => j0,
+    dist: () => tw,
+    distance: () => jd,
+    div: () => G0,
+    divide: () => zd,
+    dot: () => z0,
+    equals: () => Z0,
+    exactEquals: () => K0,
+    floor: () => N0,
+    forEach: () => iw,
+    fromValues: () => M0,
+    inverse: () => V0,
+    len: () => rw,
+    length: () => Xd,
+    lerp: () => H0,
+    max: () => k0,
+    min: () => F0,
+    mul: () => J0,
+    multiply: () => Wd,
+    negate: () => L0,
+    normalize: () => W0,
+    random: () => X0,
+    round: () => D0,
+    scale: () => B0,
+    scaleAndAdd: () => U0,
+    set: () => C0,
+    sqrDist: () => ew,
+    sqrLen: () => sw,
     squaredDistance: () => Hd,
-    squaredLength: () => Xd,
-    str: () => $b,
-    sub: () => Kb,
-    subtract: () => Ld,
-    transformMat4: () => ih,
-    transformQuat: () => jb,
-    zero: () => Xb
+    squaredLength: () => $d,
+    str: () => q0,
+    sub: () => Q0,
+    subtract: () => Vd,
+    transformMat4: () => nf,
+    transformQuat: () => $0,
+    zero: () => Y0
 });
 
-function Ud() {
-    let t = new G(4);
-    return G != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t
+function Ld() {
+    let e = new G(4);
+    return G != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e
 }
 
-function wb(t) {
-    let e = new G(4);
-    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
+function v0(e) {
+    let t = new G(4);
+    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
 }
 
-function Rb(t, e, r, s) {
+function M0(e, t, r, s) {
     let i = new G(4);
-    return i[0] = t, i[1] = e, i[2] = r, i[3] = s, i
+    return i[0] = e, i[1] = t, i[2] = r, i[3] = s, i
 }
 
-function vb(t, e) {
-    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
+function P0(e, t) {
+    return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
 }
 
-function Mb(t, e, r, s, i) {
-    return t[0] = e, t[1] = r, t[2] = s, t[3] = i, t
+function C0(e, t, r, s, i) {
+    return e[0] = t, e[1] = r, e[2] = s, e[3] = i, e
 }
 
-function Pb(t, e, r) {
-    return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t
+function I0(e, t, r) {
+    return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e
 }
 
-function Ld(t, e, r) {
-    return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t
+function Vd(e, t, r) {
+    return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e
 }
 
-function Vd(t, e, r) {
-    return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t
+function Wd(e, t, r) {
+    return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e
 }
 
-function Wd(t, e, r) {
-    return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t[3] = e[3] / r[3], t
+function zd(e, t, r) {
+    return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e
 }
 
-function Cb(t, e) {
-    return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t
+function O0(e, t) {
+    return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e
 }
 
-function Ib(t, e) {
-    return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t
+function N0(e, t) {
+    return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e
 }
 
-function Ob(t, e, r) {
-    return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t[3] = Math.min(e[3], r[3]), t
+function F0(e, t, r) {
+    return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e
 }
 
-function Nb(t, e, r) {
-    return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t[3] = Math.max(e[3], r[3]), t
+function k0(e, t, r) {
+    return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e
 }
 
-function Fb(t, e) {
-    return t[0] = Ve(e[0]), t[1] = Ve(e[1]), t[2] = Ve(e[2]), t[3] = Ve(e[3]), t
+function D0(e, t) {
+    return e[0] = Vt(t[0]), e[1] = Vt(t[1]), e[2] = Vt(t[2]), e[3] = Vt(t[3]), e
 }
 
-function Db(t, e, r) {
-    return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t
+function B0(e, t, r) {
+    return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e
 }
 
-function kb(t, e, r, s) {
-    return t[0] = e[0] + r[0] * s, t[1] = e[1] + r[1] * s, t[2] = e[2] + r[2] * s, t[3] = e[3] + r[3] * s, t
+function U0(e, t, r, s) {
+    return e[0] = t[0] + r[0] * s, e[1] = t[1] + r[1] * s, e[2] = t[2] + r[2] * s, e[3] = t[3] + r[3] * s, e
 }
 
-function zd(t, e) {
-    let r = e[0] - t[0],
-        s = e[1] - t[1],
-        i = e[2] - t[2],
-        n = e[3] - t[3];
+function jd(e, t) {
+    let r = t[0] - e[0],
+        s = t[1] - e[1],
+        i = t[2] - e[2],
+        n = t[3] - e[3];
     return Math.sqrt(r * r + s * s + i * i + n * n)
 }
 
-function Hd(t, e) {
-    let r = e[0] - t[0],
-        s = e[1] - t[1],
-        i = e[2] - t[2],
-        n = e[3] - t[3];
+function Hd(e, t) {
+    let r = t[0] - e[0],
+        s = t[1] - e[1],
+        i = t[2] - e[2],
+        n = t[3] - e[3];
     return r * r + s * s + i * i + n * n
 }
 
-function jd(t) {
-    let e = t[0],
-        r = t[1],
-        s = t[2],
-        i = t[3];
-    return Math.sqrt(e * e + r * r + s * s + i * i)
+function Xd(e) {
+    let t = e[0],
+        r = e[1],
+        s = e[2],
+        i = e[3];
+    return Math.sqrt(t * t + r * r + s * s + i * i)
 }
 
-function Xd(t) {
-    let e = t[0],
-        r = t[1],
-        s = t[2],
-        i = t[3];
-    return e * e + r * r + s * s + i * i
+function $d(e) {
+    let t = e[0],
+        r = e[1],
+        s = e[2],
+        i = e[3];
+    return t * t + r * r + s * s + i * i
 }
 
-function Bb(t, e) {
-    return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t
+function L0(e, t) {
+    return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e
 }
 
-function Ub(t, e) {
-    return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t
+function V0(e, t) {
+    return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e
 }
 
-function Lb(t, e) {
-    let r = e[0],
-        s = e[1],
-        i = e[2],
-        n = e[3],
+function W0(e, t) {
+    let r = t[0],
+        s = t[1],
+        i = t[2],
+        n = t[3],
         o = r * r + s * s + i * i + n * n;
-    return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = r * o, t[1] = s * o, t[2] = i * o, t[3] = n * o, t
+    return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = r * o, e[1] = s * o, e[2] = i * o, e[3] = n * o, e
 }
 
-function Vb(t, e) {
-    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
+function z0(e, t) {
+    return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
 }
 
-function Wb(t, e, r, s) {
+function j0(e, t, r, s) {
     let i = r[0] * s[1] - r[1] * s[0],
         n = r[0] * s[2] - r[2] * s[0],
         o = r[0] * s[3] - r[3] * s[0],
         a = r[1] * s[2] - r[2] * s[1],
         c = r[1] * s[3] - r[3] * s[1],
         l = r[2] * s[3] - r[3] * s[2],
-        h = e[0],
-        d = e[1],
-        p = e[2],
-        m = e[3];
-    return t[0] = d * l - p * c + m * a, t[1] = -(h * l) + p * o - m * n, t[2] = h * c - d * o + m * i, t[3] = -(h * a) + d * n - p * i, t
-}
-
-function zb(t, e, r, s) {
-    let i = e[0],
-        n = e[1],
-        o = e[2],
-        a = e[3];
-    return t[0] = i + s * (r[0] - i), t[1] = n + s * (r[1] - n), t[2] = o + s * (r[2] - o), t[3] = a + s * (r[3] - a), t
+        f = t[0],
+        d = t[1],
+        p = t[2],
+        m = t[3];
+    return e[0] = d * l - p * c + m * a, e[1] = -(f * l) + p * o - m * n, e[2] = f * c - d * o + m * i, e[3] = -(f * a) + d * n - p * i, e
+}
+
+function H0(e, t, r, s) {
+    let i = t[0],
+        n = t[1],
+        o = t[2],
+        a = t[3];
+    return e[0] = i + s * (r[0] - i), e[1] = n + s * (r[1] - n), e[2] = o + s * (r[2] - o), e[3] = a + s * (r[3] - a), e
 }
 
-function Hb(t, e) {
-    e = e === void 0 ? 1 : e;
+function X0(e, t) {
+    t = t === void 0 ? 1 : t;
     let r, s, i, n, o, a;
-    do r = ct() * 2 - 1, s = ct() * 2 - 1, o = r * r + s * s; while (o >= 1);
-    do i = ct() * 2 - 1, n = ct() * 2 - 1, a = i * i + n * n; while (a >= 1);
+    do r = ce() * 2 - 1, s = ce() * 2 - 1, o = r * r + s * s; while (o >= 1);
+    do i = ce() * 2 - 1, n = ce() * 2 - 1, a = i * i + n * n; while (a >= 1);
     let c = Math.sqrt((1 - o) / a);
-    return t[0] = e * r, t[1] = e * s, t[2] = e * i * c, t[3] = e * n * c, t
+    return e[0] = t * r, e[1] = t * s, e[2] = t * i * c, e[3] = t * n * c, e
 }
 
-function ih(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
-        o = e[3];
-    return t[0] = r[0] * s + r[4] * i + r[8] * n + r[12] * o, t[1] = r[1] * s + r[5] * i + r[9] * n + r[13] * o, t[2] = r[2] * s + r[6] * i + r[10] * n + r[14] * o, t[3] = r[3] * s + r[7] * i + r[11] * n + r[15] * o, t
+function nf(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
+        o = t[3];
+    return e[0] = r[0] * s + r[4] * i + r[8] * n + r[12] * o, e[1] = r[1] * s + r[5] * i + r[9] * n + r[13] * o, e[2] = r[2] * s + r[6] * i + r[10] * n + r[14] * o, e[3] = r[3] * s + r[7] * i + r[11] * n + r[15] * o, e
 }
 
-function jb(t, e, r) {
-    let s = e[0],
-        i = e[1],
-        n = e[2],
+function $0(e, t, r) {
+    let s = t[0],
+        i = t[1],
+        n = t[2],
         o = r[0],
         a = r[1],
         c = r[2],
         l = r[3],
-        h = l * s + a * n - c * i,
+        f = l * s + a * n - c * i,
         d = l * i + c * s - o * n,
         p = l * n + o * i - a * s,
         m = -o * s - a * i - c * n;
-    return t[0] = h * l + m * -o + d * -c - p * -a, t[1] = d * l + m * -a + p * -o - h * -c, t[2] = p * l + m * -c + h * -a - d * -o, t[3] = e[3], t
+    return e[0] = f * l + m * -o + d * -c - p * -a, e[1] = d * l + m * -a + p * -o - f * -c, e[2] = p * l + m * -c + f * -a - d * -o, e[3] = t[3], e
 }
 
-function Xb(t) {
-    return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t
+function Y0(e) {
+    return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e
 }
 
-function $b(t) {
-    return `vec4(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]})`
+function q0(e) {
+    return `vec4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]})`
 }
 
-function Yb(t, e) {
-    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
+function K0(e, t) {
+    return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
 }
 
-function qb(t, e) {
-    let r = t[0],
-        s = t[1],
-        i = t[2],
-        n = t[3],
-        o = e[0],
-        a = e[1],
-        c = e[2],
-        l = e[3];
+function Z0(e, t) {
+    let r = e[0],
+        s = e[1],
+        i = e[2],
+        n = e[3],
+        o = t[0],
+        a = t[1],
+        c = t[2],
+        l = t[3];
     return Math.abs(r - o) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(s - a) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(a)) && Math.abs(i - c) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(n - l) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(l))
 }
-var Kb = Ld,
-    Zb = Vd,
-    Qb = Wd,
-    Jb = zd,
-    Gb = Hd,
-    eE = jd,
-    tE = Xd,
-    rE = function() {
-        let t = Ud();
-        return function(e, r, s, i, n, o) {
+var Q0 = Vd,
+    J0 = Wd,
+    G0 = zd,
+    tw = jd,
+    ew = Hd,
+    rw = Xd,
+    sw = $d,
+    iw = function() {
+        let e = Ld();
+        return function(t, r, s, i, n, o) {
             let a, c;
-            for (r || (r = 4), s || (s = 0), i ? c = Math.min(i * r + s, e.length) : c = e.length, a = s; a < c; a += r) t[0] = e[a], t[1] = e[a + 1], t[2] = e[a + 2], t[3] = e[a + 3], n(t, t, o), e[a] = t[0], e[a + 1] = t[1], e[a + 2] = t[2], e[a + 3] = t[3];
-            return e
+            for (r || (r = 4), s || (s = 0), i ? c = Math.min(i * r + s, t.length) : c = t.length, a = s; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], n(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];
+            return t
         }
     }();
-var ah;
-(function(t) {
-    t[t.COL0ROW0 = 0] = "COL0ROW0", t[t.COL0ROW1 = 1] = "COL0ROW1", t[t.COL0ROW2 = 2] = "COL0ROW2", t[t.COL0ROW3 = 3] = "COL0ROW3", t[t.COL1ROW0 = 4] = "COL1ROW0", t[t.COL1ROW1 = 5] = "COL1ROW1", t[t.COL1ROW2 = 6] = "COL1ROW2", t[t.COL1ROW3 = 7] = "COL1ROW3", t[t.COL2ROW0 = 8] = "COL2ROW0", t[t.COL2ROW1 = 9] = "COL2ROW1", t[t.COL2ROW2 = 10] = "COL2ROW2", t[t.COL2ROW3 = 11] = "COL2ROW3", t[t.COL3ROW0 = 12] = "COL3ROW0", t[t.COL3ROW1 = 13] = "COL3ROW1", t[t.COL3ROW2 = 14] = "COL3ROW2", t[t.COL3ROW3 = 15] = "COL3ROW3"
-})(ah || (ah = {}));
-var sE = 45 * Math.PI / 180,
-    iE = 1,
-    nh = .1,
-    oh = 500,
-    nE = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
-    fe = class extends Fo {
+var cf;
+(function(e) {
+    e[e.COL0ROW0 = 0] = "COL0ROW0", e[e.COL0ROW1 = 1] = "COL0ROW1", e[e.COL0ROW2 = 2] = "COL0ROW2", e[e.COL0ROW3 = 3] = "COL0ROW3", e[e.COL1ROW0 = 4] = "COL1ROW0", e[e.COL1ROW1 = 5] = "COL1ROW1", e[e.COL1ROW2 = 6] = "COL1ROW2", e[e.COL1ROW3 = 7] = "COL1ROW3", e[e.COL2ROW0 = 8] = "COL2ROW0", e[e.COL2ROW1 = 9] = "COL2ROW1", e[e.COL2ROW2 = 10] = "COL2ROW2", e[e.COL2ROW3 = 11] = "COL2ROW3", e[e.COL3ROW0 = 12] = "COL3ROW0", e[e.COL3ROW1 = 13] = "COL3ROW1", e[e.COL3ROW2 = 14] = "COL3ROW2", e[e.COL3ROW3 = 15] = "COL3ROW3"
+})(cf || (cf = {}));
+var nw = 45 * Math.PI / 180,
+    ow = 1,
+    of = .1,
+    af = 500,
+    aw = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
+    ht = class extends Fo {
         static get IDENTITY() {
-            return aE()
+            return lw()
         }
         static get ZERO() {
-            return oE()
+            return cw()
         }
         get ELEMENTS() {
             return 16
         }
         get RANK() {
             return 4
         }
         get INDICES() {
-            return ah
+            return cf
         }
-        constructor(e) {
-            super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity()
+        constructor(t) {
+            super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity()
         }
-        copy(e) {
-            return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check()
+        copy(t) {
+            return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check()
         }
-        set(e, r, s, i, n, o, a, c, l, h, d, p, m, y, x, b) {
-            return this[0] = e, this[1] = r, this[2] = s, this[3] = i, this[4] = n, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this[9] = h, this[10] = d, this[11] = p, this[12] = m, this[13] = y, this[14] = x, this[15] = b, this.check()
+        set(t, r, s, i, n, o, a, c, l, f, d, p, m, y, E, T) {
+            return this[0] = t, this[1] = r, this[2] = s, this[3] = i, this[4] = n, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this[9] = f, this[10] = d, this[11] = p, this[12] = m, this[13] = y, this[14] = E, this[15] = T, this.check()
         }
-        setRowMajor(e, r, s, i, n, o, a, c, l, h, d, p, m, y, x, b) {
-            return this[0] = e, this[1] = n, this[2] = l, this[3] = m, this[4] = r, this[5] = o, this[6] = h, this[7] = y, this[8] = s, this[9] = a, this[10] = d, this[11] = x, this[12] = i, this[13] = c, this[14] = p, this[15] = b, this.check()
+        setRowMajor(t, r, s, i, n, o, a, c, l, f, d, p, m, y, E, T) {
+            return this[0] = t, this[1] = n, this[2] = l, this[3] = m, this[4] = r, this[5] = o, this[6] = f, this[7] = y, this[8] = s, this[9] = a, this[10] = d, this[11] = E, this[12] = i, this[13] = c, this[14] = p, this[15] = T, this.check()
         }
-        toRowMajor(e) {
-            return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e
+        toRowMajor(t) {
+            return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t
         }
         identity() {
-            return this.copy(nE)
+            return this.copy(aw)
         }
-        fromObject(e) {
+        fromObject(t) {
             return this.check()
         }
-        fromQuaternion(e) {
-            return Gl(this, e), this.check()
+        fromQuaternion(t) {
+            return Gl(this, t), this.check()
         }
-        frustum(e) {
+        frustum(t) {
             let {
                 left: r,
                 right: s,
                 bottom: i,
                 top: n,
-                near: o = nh,
-                far: a = oh
-            } = e;
-            return a === 1 / 0 ? cE(this, r, s, i, n, o) : eh(this, r, s, i, n, o, a), this.check()
+                near: o = of,
+                far: a = af
+            } = t;
+            return a === 1 / 0 ? fw(this, r, s, i, n, o) : tf(this, r, s, i, n, o, a), this.check()
         }
-        lookAt(e) {
+        lookAt(t) {
             let {
                 eye: r,
                 center: s = [0, 0, 0],
                 up: i = [0, 1, 0]
-            } = e;
-            return sh(this, r, s, i), this.check()
+            } = t;
+            return sf(this, r, s, i), this.check()
         }
-        ortho(e) {
+        ortho(t) {
             let {
                 left: r,
                 right: s,
                 bottom: i,
                 top: n,
-                near: o = nh,
-                far: a = oh
-            } = e;
-            return rh(this, r, s, i, n, o, a), this.check()
+                near: o = of,
+                far: a = af
+            } = t;
+            return rf(this, r, s, i, n, o, a), this.check()
         }
-        orthographic(e) {
+        orthographic(t) {
             let {
-                fovy: r = sE,
-                aspect: s = iE,
+                fovy: r = nw,
+                aspect: s = ow,
                 focalDistance: i = 1,
-                near: n = nh,
-                far: o = oh
-            } = e;
-            $d(r);
+                near: n = of,
+                far: o = af
+            } = t;
+            Yd(r);
             let a = r / 2,
                 c = i * Math.tan(a),
                 l = c * s;
             return this.ortho({
                 left: -l,
                 right: l,
                 bottom: -c,
                 top: c,
                 near: n,
                 far: o
             })
         }
-        perspective(e) {
+        perspective(t) {
             let {
                 fovy: r = 45 * Math.PI / 180,
                 aspect: s = 1,
                 near: i = .1,
                 far: n = 500
-            } = e;
-            return $d(r), th(this, r, s, i, n), this.check()
+            } = t;
+            return Yd(r), ef(this, r, s, i, n), this.check()
         }
         determinant() {
             return $l(this)
         }
-        getScale(e = [-0, -0, -0]) {
-            return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e
+        getScale(t = [-0, -0, -0]) {
+            return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t
         }
-        getTranslation(e = [-0, -0, -0]) {
-            return e[0] = this[12], e[1] = this[13], e[2] = this[14], e
+        getTranslation(t = [-0, -0, -0]) {
+            return t[0] = this[12], t[1] = this[13], t[2] = this[14], t
         }
-        getRotation(e, r) {
-            e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], r = r || [-0, -0, -0];
+        getRotation(t, r) {
+            t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], r = r || [-0, -0, -0];
             let s = this.getScale(r),
                 i = 1 / s[0],
                 n = 1 / s[1],
                 o = 1 / s[2];
-            return e[0] = this[0] * i, e[1] = this[1] * n, e[2] = this[2] * o, e[3] = 0, e[4] = this[4] * i, e[5] = this[5] * n, e[6] = this[6] * o, e[7] = 0, e[8] = this[8] * i, e[9] = this[9] * n, e[10] = this[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
+            return t[0] = this[0] * i, t[1] = this[1] * n, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * i, t[5] = this[5] * n, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * i, t[9] = this[9] * n, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
         }
-        getRotationMatrix3(e, r) {
-            e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], r = r || [-0, -0, -0];
+        getRotationMatrix3(t, r) {
+            t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], r = r || [-0, -0, -0];
             let s = this.getScale(r),
                 i = 1 / s[0],
                 n = 1 / s[1],
                 o = 1 / s[2];
-            return e[0] = this[0] * i, e[1] = this[1] * n, e[2] = this[2] * o, e[3] = this[4] * i, e[4] = this[5] * n, e[5] = this[6] * o, e[6] = this[8] * i, e[7] = this[9] * n, e[8] = this[10] * o, e
+            return t[0] = this[0] * i, t[1] = this[1] * n, t[2] = this[2] * o, t[3] = this[4] * i, t[4] = this[5] * n, t[5] = this[6] * o, t[6] = this[8] * i, t[7] = this[9] * n, t[8] = this[10] * o, t
         }
         transpose() {
-            return jl(this, this), this.check()
+            return Hl(this, this), this.check()
         }
         invert() {
             return Xl(this, this), this.check()
         }
-        multiplyLeft(e) {
-            return mi(this, e, this), this.check()
+        multiplyLeft(t) {
+            return mi(this, t, this), this.check()
         }
-        multiplyRight(e) {
-            return mi(this, this, e), this.check()
+        multiplyRight(t) {
+            return mi(this, this, t), this.check()
         }
-        rotateX(e) {
-            return Zl(this, this, e), this.check()
+        rotateX(t) {
+            return Zl(this, this, t), this.check()
         }
-        rotateY(e) {
-            return Ql(this, this, e), this.check()
+        rotateY(t) {
+            return Ql(this, this, t), this.check()
         }
-        rotateZ(e) {
-            return Jl(this, this, e), this.check()
+        rotateZ(t) {
+            return Jl(this, this, t), this.check()
         }
-        rotateXYZ(e) {
-            return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2])
+        rotateXYZ(t) {
+            return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2])
         }
-        rotateAxis(e, r) {
-            return Kl(this, this, e, r), this.check()
+        rotateAxis(t, r) {
+            return Kl(this, this, t, r), this.check()
         }
-        scale(e) {
-            return ql(this, this, Array.isArray(e) ? e : [e, e, e]), this.check()
+        scale(t) {
+            return ql(this, this, Array.isArray(t) ? t : [t, t, t]), this.check()
         }
-        translate(e) {
-            return Yl(this, this, e), this.check()
+        translate(t) {
+            return Yl(this, this, t), this.check()
         }
-        transform(e, r) {
-            return e.length === 4 ? (r = ih(r || [-0, -0, -0, -0], e, this), Po(r, 4), r) : this.transformAsPoint(e, r)
+        transform(t, r) {
+            return t.length === 4 ? (r = nf(r || [-0, -0, -0, -0], t, this), Po(r, 4), r) : this.transformAsPoint(t, r)
         }
-        transformAsPoint(e, r) {
+        transformAsPoint(t, r) {
             let {
                 length: s
-            } = e, i;
+            } = t, i;
             switch (s) {
                 case 2:
-                    i = Fl(r || [-0, -0], e, this);
+                    i = Fl(r || [-0, -0], t, this);
                     break;
                 case 3:
-                    i = _i(r || [-0, -0, -0], e, this);
+                    i = gi(r || [-0, -0, -0], t, this);
                     break;
                 default:
                     throw new Error("Illegal vector")
             }
-            return Po(i, e.length), i
+            return Po(i, t.length), i
         }
-        transformAsVector(e, r) {
+        transformAsVector(t, r) {
             let s;
-            switch (e.length) {
+            switch (t.length) {
                 case 2:
-                    s = Ad(r || [-0, -0], e, this);
+                    s = Ed(r || [-0, -0], t, this);
                     break;
                 case 3:
-                    s = Oo(r || [-0, -0, -0], e, this);
+                    s = Oo(r || [-0, -0, -0], t, this);
                     break;
                 default:
                     throw new Error("Illegal vector")
             }
-            return Po(s, e.length), s
+            return Po(s, t.length), s
         }
-        transformPoint(e, r) {
-            return this.transformAsPoint(e, r)
+        transformPoint(t, r) {
+            return this.transformAsPoint(t, r)
         }
-        transformVector(e, r) {
-            return this.transformAsPoint(e, r)
+        transformVector(t, r) {
+            return this.transformAsPoint(t, r)
         }
-        transformDirection(e, r) {
-            return this.transformAsVector(e, r)
+        transformDirection(t, r) {
+            return this.transformAsVector(t, r)
         }
-        makeRotationX(e) {
-            return this.identity().rotateX(e)
+        makeRotationX(t) {
+            return this.identity().rotateX(t)
         }
-        makeTranslation(e, r, s) {
-            return this.identity().translate([e, r, s])
+        makeTranslation(t, r, s) {
+            return this.identity().translate([t, r, s])
         }
     },
-    Do, ko;
+    ko, Do;
 
-function oE() {
-    return Do || (Do = new fe([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Do)), Do
+function cw() {
+    return ko || (ko = new ht([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(ko)), ko
 }
 
-function aE() {
-    return ko || (ko = new fe, Object.freeze(ko)), ko
+function lw() {
+    return Do || (Do = new ht, Object.freeze(Do)), Do
 }
 
-function $d(t) {
-    if (t > Math.PI * 2) throw Error("expected radians")
+function Yd(e) {
+    if (e > Math.PI * 2) throw Error("expected radians")
 }
 
-function cE(t, e, r, s, i, n) {
-    let o = 2 * n / (r - e),
+function fw(e, t, r, s, i, n) {
+    let o = 2 * n / (r - t),
         a = 2 * n / (i - s),
-        c = (r + e) / (r - e),
+        c = (r + t) / (r - t),
         l = (i + s) / (i - s),
-        h = -1,
+        f = -1,
         d = -1,
         p = -2 * n;
-    return t[0] = o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = c, t[9] = l, t[10] = h, t[11] = d, t[12] = 0, t[13] = 0, t[14] = p, t[15] = 0, t
+    return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = l, e[10] = f, e[11] = d, e[12] = 0, e[13] = 0, e[14] = p, e[15] = 0, e
 }
-var Yd = "#define SMOOTH_EDGE_RADIUS 0.5",
-    lE = `
-${Yd}
+var qd = "#define SMOOTH_EDGE_RADIUS 0.5",
+    hw = `
+${qd}
 
 struct VertexGeometry {
   vec4 position;
   vec3 worldPosition;
   vec3 worldPositionAlt;
   vec3 normal;
   vec2 uv;
@@ -10039,71 +10039,71 @@
   vec3(0.0),
   vec3(0.0),
   vec3(0.0),
   vec2(0.0),
   vec3(0.0)
 );
 `,
-    hE = `
-${Yd}
+    uw = `
+${qd}
 
 struct FragmentGeometry {
   vec2 uv;
 } geometry;
 
 float smoothedge(float edge, float x) {
   return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
 }
 `,
-    qd = {
+    Kd = {
         name: "geometry",
-        vs: lE,
-        fs: hE
+        vs: hw,
+        fs: uw
     };
 var X = {
     DEFAULT: -1,
     LNGLAT: 1,
     METER_OFFSETS: 2,
     LNGLAT_OFFSETS: 3,
     CARTESIAN: 0
 };
 Object.defineProperty(X, "IDENTITY", {
     get: () => (W.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
 });
-var we = {
+var St = {
         WEB_MERCATOR: 1,
         GLOBE: 2,
         WEB_MERCATOR_AUTO_OFFSET: 4,
         IDENTITY: 0
     },
-    Xt = {
+    Xe = {
         common: 0,
         meters: 1,
         pixels: 2
     },
-    Ti = {
+    bi = {
         click: {
             handler: "onClick"
         },
         panstart: {
             handler: "onDragStart"
         },
         panmove: {
             handler: "onDrag"
         },
         panend: {
             handler: "onDragEnd"
         }
     };
-var fE = Object.keys(X).map(t => `const int COORDINATE_SYSTEM_${t} = ${X[t]};`).join(""),
-    uE = Object.keys(we).map(t => `const int PROJECTION_MODE_${t} = ${we[t]};`).join(""),
-    dE = Object.keys(Xt).map(t => `const int UNIT_${t.toUpperCase()} = ${Xt[t]};`).join(""),
-    Kd = `${fE}
-${uE}
-${dE}
+var dw = Object.keys(X).map(e => `const int COORDINATE_SYSTEM_${e} = ${X[e]};`).join(""),
+    pw = Object.keys(St).map(e => `const int PROJECTION_MODE_${e} = ${St[e]};`).join(""),
+    _w = Object.keys(Xe).map(e => `const int UNIT_${e.toUpperCase()} = ${Xe[e]};`).join(""),
+    Zd = `${dw}
+${pw}
+${_w}
 uniform int project_uCoordinateSystem;
 uniform int project_uProjectionMode;
 uniform float project_uScale;
 uniform bool project_uWrapLongitude;
 uniform vec3 project_uCommonUnitsPerMeter;
 uniform vec3 project_uCommonUnitsPerWorldUnit;
 uniform vec3 project_uCommonUnitsPerWorldUnit2;
@@ -10284,175 +10284,175 @@
 return pixels / project_uScale;
 }
 vec2 project_pixel_size(vec2 pixels) {
 return pixels / project_uScale;
 }
 `;
 
-function pE(t, e) {
-    if (t === e) return !0;
-    if (Array.isArray(t)) {
-        let r = t.length;
-        if (!e || e.length !== r) return !1;
+function gw(e, t) {
+    if (e === t) return !0;
+    if (Array.isArray(e)) {
+        let r = e.length;
+        if (!t || t.length !== r) return !1;
         for (let s = 0; s < r; s++)
-            if (t[s] !== e[s]) return !1;
+            if (e[s] !== t[s]) return !1;
         return !0
     }
     return !1
 }
 
-function ft(t) {
-    let e = {},
+function he(e) {
+    let t = {},
         r;
     return s => {
         for (let i in s)
-            if (!pE(s[i], e[i])) {
-                r = t(s), e = s;
+            if (!gw(s[i], t[i])) {
+                r = e(s), t = s;
                 break
             } return r
     }
 }
-var Zd = [0, 0, 0, 0],
-    gE = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
-    Qd = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
-    _E = [0, 0, 0],
-    Jd = [0, 0, 0],
-    mE = ft(yE);
+var Qd = [0, 0, 0, 0],
+    mw = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
+    Jd = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
+    bw = [0, 0, 0],
+    Gd = [0, 0, 0],
+    yw = he(ww);
 
-function ch(t, e, r = Jd) {
+function lf(e, t, r = Gd) {
     r.length < 3 && (r = [r[0], r[1], 0]);
     let s = r,
         i, n = !0;
-    switch (e === X.LNGLAT_OFFSETS || e === X.METER_OFFSETS ? i = r : i = t.isGeospatial ? [Math.fround(t.longitude), Math.fround(t.latitude), 0] : null, t.projectionMode) {
-        case we.WEB_MERCATOR:
-            (e === X.LNGLAT || e === X.CARTESIAN) && (i = [0, 0, 0], n = !1);
+    switch (t === X.LNGLAT_OFFSETS || t === X.METER_OFFSETS ? i = r : i = e.isGeospatial ? [Math.fround(e.longitude), Math.fround(e.latitude), 0] : null, e.projectionMode) {
+        case St.WEB_MERCATOR:
+            (t === X.LNGLAT || t === X.CARTESIAN) && (i = [0, 0, 0], n = !1);
             break;
-        case we.WEB_MERCATOR_AUTO_OFFSET:
-            e === X.LNGLAT ? s = i : e === X.CARTESIAN && (s = [Math.fround(t.center[0]), Math.fround(t.center[1]), 0], i = t.unprojectPosition(s), s[0] -= r[0], s[1] -= r[1], s[2] -= r[2]);
+        case St.WEB_MERCATOR_AUTO_OFFSET:
+            t === X.LNGLAT ? s = i : t === X.CARTESIAN && (s = [Math.fround(e.center[0]), Math.fround(e.center[1]), 0], i = e.unprojectPosition(s), s[0] -= r[0], s[1] -= r[1], s[2] -= r[2]);
             break;
-        case we.IDENTITY:
-            s = t.position.map(Math.fround), s[2] = s[2] || 0;
+        case St.IDENTITY:
+            s = e.position.map(Math.fround), s[2] = s[2] || 0;
             break;
-        case we.GLOBE:
+        case St.GLOBE:
             n = !1, i = null;
             break;
         default:
             n = !1
     }
     return {
         geospatialOrigin: i,
         shaderCoordinateOrigin: s,
         offsetMode: n
     }
 }
 
-function TE(t, e, r) {
+function Tw(e, t, r) {
     let {
         viewMatrixUncentered: s,
         projectionMatrix: i
-    } = t, {
+    } = e, {
         viewMatrix: n,
         viewProjectionMatrix: o
-    } = t, a = Zd, c = Zd, l = t.cameraPosition, {
-        geospatialOrigin: h,
+    } = e, a = Qd, c = Qd, l = e.cameraPosition, {
+        geospatialOrigin: f,
         shaderCoordinateOrigin: d,
         offsetMode: p
-    } = ch(t, e, r);
-    return p && (c = t.projectPosition(h || d), l = [l[0] - c[0], l[1] - c[1], l[2] - c[2]], c[3] = 1, a = ht.transformMat4([], c, o), n = s || n, o = ne.multiply([], i, n), o = ne.multiply([], o, gE)), {
+    } = lf(e, t, r);
+    return p && (c = e.projectPosition(f || d), l = [l[0] - c[0], l[1] - c[1], l[2] - c[2]], c[3] = 1, a = fe.transformMat4([], c, o), n = s || n, o = nt.multiply([], i, n), o = nt.multiply([], o, mw)), {
         viewMatrix: n,
         viewProjectionMatrix: o,
         projectionCenter: a,
         originCommon: c,
         cameraPosCommon: l,
         shaderCoordinateOrigin: d,
-        geospatialOrigin: h
+        geospatialOrigin: f
     }
 }
 
-function Gd({
-    viewport: t,
-    devicePixelRatio: e = 1,
+function tp({
+    viewport: e,
+    devicePixelRatio: t = 1,
     modelMatrix: r = null,
     coordinateSystem: s = X.DEFAULT,
-    coordinateOrigin: i = Jd,
+    coordinateOrigin: i = Gd,
     autoWrapLongitude: n = !1
 }) {
-    s === X.DEFAULT && (s = t.isGeospatial ? X.LNGLAT : X.CARTESIAN);
-    let o = mE({
-        viewport: t,
-        devicePixelRatio: e,
+    s === X.DEFAULT && (s = e.isGeospatial ? X.LNGLAT : X.CARTESIAN);
+    let o = yw({
+        viewport: e,
+        devicePixelRatio: t,
         coordinateSystem: s,
         coordinateOrigin: i
     });
-    return o.project_uWrapLongitude = n, o.project_uModelMatrix = r || Qd, o
+    return o.project_uWrapLongitude = n, o.project_uModelMatrix = r || Jd, o
 }
 
-function yE({
-    viewport: t,
-    devicePixelRatio: e,
+function ww({
+    viewport: e,
+    devicePixelRatio: t,
     coordinateSystem: r,
     coordinateOrigin: s
 }) {
     let {
         projectionCenter: i,
         viewProjectionMatrix: n,
         originCommon: o,
         cameraPosCommon: a,
         shaderCoordinateOrigin: c,
         geospatialOrigin: l
-    } = TE(t, r, s), h = t.getDistanceScales(), d = [t.width * e, t.height * e], p = ht.transformMat4([], [0, 0, -t.focalDistance, 1], t.projectionMatrix)[3] || 1, m = {
+    } = Tw(e, r, s), f = e.getDistanceScales(), d = [e.width * t, e.height * t], p = fe.transformMat4([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, m = {
         project_uCoordinateSystem: r,
-        project_uProjectionMode: t.projectionMode,
+        project_uProjectionMode: e.projectionMode,
         project_uCoordinateOrigin: c,
         project_uCommonOrigin: o.slice(0, 3),
         project_uCenter: i,
-        project_uPseudoMeters: !!t._pseudoMeters,
+        project_uPseudoMeters: !!e._pseudoMeters,
         project_uViewportSize: d,
-        project_uDevicePixelRatio: e,
+        project_uDevicePixelRatio: t,
         project_uFocalDistance: p,
-        project_uCommonUnitsPerMeter: h.unitsPerMeter,
-        project_uCommonUnitsPerWorldUnit: h.unitsPerMeter,
-        project_uCommonUnitsPerWorldUnit2: _E,
-        project_uScale: t.scale,
+        project_uCommonUnitsPerMeter: f.unitsPerMeter,
+        project_uCommonUnitsPerWorldUnit: f.unitsPerMeter,
+        project_uCommonUnitsPerWorldUnit2: bw,
+        project_uScale: e.scale,
         project_uWrapLongitude: !1,
         project_uViewProjectionMatrix: n,
-        project_uModelMatrix: Qd,
+        project_uModelMatrix: Jd,
         project_uCameraPosition: a
     };
     if (l) {
-        let y = t.getDistanceScales(l);
+        let y = e.getDistanceScales(l);
         switch (r) {
             case X.METER_OFFSETS:
                 m.project_uCommonUnitsPerWorldUnit = y.unitsPerMeter, m.project_uCommonUnitsPerWorldUnit2 = y.unitsPerMeter2;
                 break;
             case X.LNGLAT:
             case X.LNGLAT_OFFSETS:
-                t._pseudoMeters || (m.project_uCommonUnitsPerMeter = y.unitsPerMeter), m.project_uCommonUnitsPerWorldUnit = y.unitsPerDegree, m.project_uCommonUnitsPerWorldUnit2 = y.unitsPerDegree2;
+                e._pseudoMeters || (m.project_uCommonUnitsPerMeter = y.unitsPerMeter), m.project_uCommonUnitsPerWorldUnit = y.unitsPerDegree, m.project_uCommonUnitsPerWorldUnit2 = y.unitsPerDegree2;
                 break;
             case X.CARTESIAN:
                 m.project_uCommonUnitsPerWorldUnit = [1, 1, y.unitsPerMeter[2]], m.project_uCommonUnitsPerWorldUnit2 = [0, 0, y.unitsPerMeter2[2]];
                 break;
             default:
                 break
         }
     }
     return m
 }
-var bE = {};
+var Aw = {};
 
-function EE(t = bE) {
-    return "viewport" in t ? Gd(t) : {}
+function Ew(e = Aw) {
+    return "viewport" in e ? tp(e) : {}
 }
-var $t = {
+var $e = {
     name: "project",
-    dependencies: [Il, qd],
-    vs: Kd,
-    getUniforms: EE
+    dependencies: [Il, Kd],
+    vs: Zd,
+    getUniforms: Ew
 };
-var AE = `
+var xw = `
 vec4 project_position_to_clipspace(
   vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
 ) {
   vec3 projectedPosition = project_position(position, position64Low);
   mat3 rotation;
   if (project_needs_rotation(projectedPosition, rotation)) {
     // offset is specified as ENU
@@ -10468,291 +10468,291 @@
 ) {
   vec4 commonPosition;
   return project_position_to_clipspace(position, position64Low, offset, commonPosition);
 }
 `,
     yi = {
         name: "project32",
-        dependencies: [$t],
-        vs: AE
+        dependencies: [$e],
+        vs: xw
     };
 
-function lh() {
+function ff() {
     return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
 }
 
-function Yt(t, e) {
-    let r = ht.transformMat4([], e, t);
-    return ht.scale(r, r, 1 / r[3]), r
+function Ye(e, t) {
+    let r = fe.transformMat4([], t, e);
+    return fe.scale(r, r, 1 / r[3]), r
 }
 
-function hh(t, e) {
-    let r = t % e;
-    return r < 0 ? e + r : r
+function hf(e, t) {
+    let r = e % t;
+    return r < 0 ? t + r : r
 }
 
-function bi(t, e, r) {
-    return t < e ? e : t > r ? r : t
+function Ti(e, t, r) {
+    return e < t ? t : e > r ? r : e
 }
 
-function xE(t) {
-    return Math.log(t) * Math.LOG2E
+function Sw(e) {
+    return Math.log(e) * Math.LOG2E
 }
-var is = Math.log2 || xE;
+var is = Math.log2 || Sw;
 
-function Xe(t, e) {
-    if (!t) throw new Error(e || "@math.gl/web-mercator: assertion failed.")
+function Xt(e, t) {
+    if (!e) throw new Error(t || "@math.gl/web-mercator: assertion failed.")
 }
-var $e = Math.PI,
-    ep = $e / 4,
-    We = $e / 180,
-    fh = 180 / $e,
+var $t = Math.PI,
+    ep = $t / 4,
+    Wt = $t / 180,
+    uf = 180 / $t,
     ns = 512,
     Bo = 4003e4,
     os = 85.051129,
-    tp = 1.5;
+    rp = 1.5;
 
-function uh(t) {
-    return is(t)
+function df(e) {
+    return is(e)
 }
 
-function Rt(t) {
-    let [e, r] = t;
-    Xe(Number.isFinite(e)), Xe(Number.isFinite(r) && r >= -90 && r <= 90, "invalid latitude");
-    let s = e * We,
-        i = r * We,
-        n = ns * (s + $e) / (2 * $e),
-        o = ns * ($e + Math.log(Math.tan(ep + i * .5))) / (2 * $e);
+function Re(e) {
+    let [t, r] = e;
+    Xt(Number.isFinite(t)), Xt(Number.isFinite(r) && r >= -90 && r <= 90, "invalid latitude");
+    let s = t * Wt,
+        i = r * Wt,
+        n = ns * (s + $t) / (2 * $t),
+        o = ns * ($t + Math.log(Math.tan(ep + i * .5))) / (2 * $t);
     return [n, o]
 }
 
-function Me(t) {
-    let [e, r] = t, s = e / ns * (2 * $e) - $e, i = 2 * (Math.atan(Math.exp(r / ns * (2 * $e) - $e)) - ep);
-    return [s * fh, i * fh]
+function Mt(e) {
+    let [t, r] = e, s = t / ns * (2 * $t) - $t, i = 2 * (Math.atan(Math.exp(r / ns * (2 * $t) - $t)) - ep);
+    return [s * uf, i * uf]
 }
 
-function dh(t) {
+function pf(e) {
     let {
-        latitude: e
-    } = t;
-    Xe(Number.isFinite(e));
-    let r = Math.cos(e * We);
-    return uh(Bo * r) - 9
+        latitude: t
+    } = e;
+    Xt(Number.isFinite(t));
+    let r = Math.cos(t * Wt);
+    return df(Bo * r) - 9
 }
 
-function Ei(t) {
-    let e = Math.cos(t * We);
-    return ns / Bo / e
+function wi(e) {
+    let t = Math.cos(e * Wt);
+    return ns / Bo / t
 }
 
-function as(t) {
+function as(e) {
     let {
-        latitude: e,
+        latitude: t,
         longitude: r,
         highPrecision: s = !1
-    } = t;
-    Xe(Number.isFinite(e) && Number.isFinite(r));
+    } = e;
+    Xt(Number.isFinite(t) && Number.isFinite(r));
     let i = ns,
-        n = Math.cos(e * We),
+        n = Math.cos(t * Wt),
         o = i / 360,
         a = o / n,
         c = i / Bo / n,
         l = {
             unitsPerMeter: [c, c, c],
             metersPerUnit: [1 / c, 1 / c, 1 / c],
             unitsPerDegree: [o, a, c],
             degreesPerUnit: [1 / o, 1 / a, 1 / c]
         };
     if (s) {
-        let h = We * Math.tan(e * We) / n,
-            d = o * h / 2,
-            p = i / Bo * h,
+        let f = Wt * Math.tan(t * Wt) / n,
+            d = o * f / 2,
+            p = i / Bo * f,
             m = p / a * c;
         l.unitsPerDegree2 = [0, d, p], l.unitsPerMeter2 = [m, 0, m]
     }
     return l
 }
 
-function Ai(t, e) {
-    let [r, s, i] = t, [n, o, a] = e, {
+function Ai(e, t) {
+    let [r, s, i] = e, [n, o, a] = t, {
         unitsPerMeter: c,
         unitsPerMeter2: l
     } = as({
         longitude: r,
         latitude: s,
         highPrecision: !0
-    }), h = Rt(t);
-    h[0] += n * (c[0] + l[0] * o), h[1] += o * (c[1] + l[1] * o);
-    let d = Me(h),
+    }), f = Re(e);
+    f[0] += n * (c[0] + l[0] * o), f[1] += o * (c[1] + l[1] * o);
+    let d = Mt(f),
         p = (i || 0) + (a || 0);
     return Number.isFinite(i) || Number.isFinite(a) ? [d[0], d[1], p] : d
 }
 
-function Uo(t) {
+function Uo(e) {
     let {
-        height: e,
+        height: t,
         pitch: r,
         bearing: s,
         altitude: i,
         scale: n,
         center: o
-    } = t, a = lh();
-    ne.translate(a, a, [0, 0, -i]), ne.rotateX(a, a, -r * We), ne.rotateZ(a, a, s * We);
-    let c = n / e;
-    return ne.scale(a, a, [c, c, c]), o && ne.translate(a, a, ss.negate([], o)), a
+    } = e, a = ff();
+    nt.translate(a, a, [0, 0, -i]), nt.rotateX(a, a, -r * Wt), nt.rotateZ(a, a, s * Wt);
+    let c = n / t;
+    return nt.scale(a, a, [c, c, c]), o && nt.translate(a, a, ss.negate([], o)), a
 }
 
-function ph(t) {
+function _f(e) {
     let {
-        width: e,
+        width: t,
         height: r,
         altitude: s,
         pitch: i = 0,
         offset: n,
         center: o,
         scale: a,
         nearZMultiplier: c = 1,
         farZMultiplier: l = 1
-    } = t, {
-        fovy: h = Mr(tp)
-    } = t;
-    s !== void 0 && (h = Mr(s));
-    let d = h * We,
-        p = i * We,
-        m = xi(h),
+    } = e, {
+        fovy: f = Mr(rp)
+    } = e;
+    s !== void 0 && (f = Mr(s));
+    let d = f * Wt,
+        p = i * Wt,
+        m = Ei(f),
         y = m;
     o && (y += o[2] * a / Math.cos(p) / r);
-    let x = d * (.5 + (n ? n[1] : 0) / r),
-        b = Math.sin(x) * y / Math.sin(bi(Math.PI / 2 - p - x, .01, Math.PI - .01)),
-        w = Math.sin(p) * b + y,
+    let E = d * (.5 + (n ? n[1] : 0) / r),
+        T = Math.sin(E) * y / Math.sin(Ti(Math.PI / 2 - p - E, .01, Math.PI - .01)),
+        S = Math.sin(p) * T + y,
         R = y * 10,
-        v = Math.min(w * l, R);
+        v = Math.min(S * l, R);
     return {
         fov: d,
-        aspect: e / r,
+        aspect: t / r,
         focalDistance: m,
         near: c,
         far: v
     }
 }
 
-function Mr(t) {
-    return 2 * Math.atan(.5 / t) * fh
+function Mr(e) {
+    return 2 * Math.atan(.5 / e) * uf
 }
 
-function xi(t) {
-    return .5 / Math.tan(.5 * t * We)
+function Ei(e) {
+    return .5 / Math.tan(.5 * e * Wt)
 }
 
-function cs(t, e) {
-    let [r, s, i = 0] = t;
-    return Xe(Number.isFinite(r) && Number.isFinite(s) && Number.isFinite(i)), Yt(e, [r, s, i, 1])
+function cs(e, t) {
+    let [r, s, i = 0] = e;
+    return Xt(Number.isFinite(r) && Number.isFinite(s) && Number.isFinite(i)), Ye(t, [r, s, i, 1])
 }
 
-function qt(t, e, r = 0) {
-    let [s, i, n] = t;
-    if (Xe(Number.isFinite(s) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(n)) return Yt(e, [s, i, n, 1]);
-    let o = Yt(e, [s, i, 0, 1]),
-        a = Yt(e, [s, i, 1, 1]),
+function qe(e, t, r = 0) {
+    let [s, i, n] = e;
+    if (Xt(Number.isFinite(s) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(n)) return Ye(t, [s, i, n, 1]);
+    let o = Ye(t, [s, i, 0, 1]),
+        a = Ye(t, [s, i, 1, 1]),
         c = o[2],
         l = a[2],
-        h = c === l ? 0 : ((r || 0) - c) / (l - c);
-    return lt.lerp([], o, a, h)
+        f = c === l ? 0 : ((r || 0) - c) / (l - c);
+    return le.lerp([], o, a, f)
 }
 
-function Lo(t) {
+function Lo(e) {
     let {
-        width: e,
+        width: t,
         height: r,
         bounds: s,
         minExtent: i = 0,
         maxZoom: n = 24,
         offset: o = [0, 0]
-    } = t, [
+    } = e, [
         [a, c],
-        [l, h]
-    ] = s, d = SE(t.padding), p = Rt([a, bi(h, -os, os)]), m = Rt([l, bi(c, -os, os)]), y = [Math.max(Math.abs(m[0] - p[0]), i), Math.max(Math.abs(m[1] - p[1]), i)], x = [e - d.left - d.right - Math.abs(o[0]) * 2, r - d.top - d.bottom - Math.abs(o[1]) * 2];
-    Xe(x[0] > 0 && x[1] > 0);
-    let b = x[0] / y[0],
-        w = x[1] / y[1],
-        R = (d.right - d.left) / 2 / b,
-        v = (d.top - d.bottom) / 2 / w,
+        [l, f]
+    ] = s, d = Rw(e.padding), p = Re([a, Ti(f, -os, os)]), m = Re([l, Ti(c, -os, os)]), y = [Math.max(Math.abs(m[0] - p[0]), i), Math.max(Math.abs(m[1] - p[1]), i)], E = [t - d.left - d.right - Math.abs(o[0]) * 2, r - d.top - d.bottom - Math.abs(o[1]) * 2];
+    Xt(E[0] > 0 && E[1] > 0);
+    let T = E[0] / y[0],
+        S = E[1] / y[1],
+        R = (d.right - d.left) / 2 / T,
+        v = (d.top - d.bottom) / 2 / S,
         C = [(m[0] + p[0]) / 2 + R, (m[1] + p[1]) / 2 + v],
-        O = Me(C),
-        N = Math.min(n, is(Math.abs(Math.min(b, w))));
-    return Xe(Number.isFinite(N)), {
+        O = Mt(C),
+        N = Math.min(n, is(Math.abs(Math.min(T, S))));
+    return Xt(Number.isFinite(N)), {
         longitude: O[0],
         latitude: O[1],
         zoom: N
     }
 }
 
-function SE(t = 0) {
-    return typeof t == "number" ? {
-        top: t,
-        bottom: t,
-        left: t,
-        right: t
-    } : (Xe(Number.isFinite(t.top) && Number.isFinite(t.bottom) && Number.isFinite(t.left) && Number.isFinite(t.right)), t)
+function Rw(e = 0) {
+    return typeof e == "number" ? {
+        top: e,
+        bottom: e,
+        left: e,
+        right: e
+    } : (Xt(Number.isFinite(e.top) && Number.isFinite(e.bottom) && Number.isFinite(e.left) && Number.isFinite(e.right)), e)
 }
-var rp = Math.PI / 180;
+var sp = Math.PI / 180;
 
-function Vo(t, e = 0) {
+function Vo(e, t = 0) {
     let {
         width: r,
         height: s,
         unproject: i
-    } = t, n = {
-        targetZ: e
-    }, o = i([0, s], n), a = i([r, s], n), c, l, h = t.fovy ? .5 * t.fovy * rp : Math.atan(.5 / t.altitude), d = (90 - t.pitch) * rp;
-    return h > d - .01 ? (c = sp(t, 0, e), l = sp(t, r, e)) : (c = i([0, 0], n), l = i([r, 0], n)), [o, a, l, c]
+    } = e, n = {
+        targetZ: t
+    }, o = i([0, s], n), a = i([r, s], n), c, l, f = e.fovy ? .5 * e.fovy * sp : Math.atan(.5 / e.altitude), d = (90 - e.pitch) * sp;
+    return f > d - .01 ? (c = ip(e, 0, t), l = ip(e, r, t)) : (c = i([0, 0], n), l = i([r, 0], n)), [o, a, l, c]
 }
 
-function sp(t, e, r) {
+function ip(e, t, r) {
     let {
         pixelUnprojectionMatrix: s
-    } = t, i = Yt(s, [e, 0, 1, 1]), n = Yt(s, [e, t.height, 1, 1]), a = (r * t.distanceScales.unitsPerMeter[2] - i[2]) / (n[2] - i[2]), c = lt.lerp([], i, n, a), l = Me(c);
+    } = e, i = Ye(s, [t, 0, 1, 1]), n = Ye(s, [t, e.height, 1, 1]), a = (r * e.distanceScales.unitsPerMeter[2] - i[2]) / (n[2] - i[2]), c = le.lerp([], i, n, a), l = Mt(c);
     return l.push(r), l
 }
-var np = 512;
+var op = 512;
 
-function gh(t) {
+function gf(e) {
     let {
-        width: e,
+        width: t,
         height: r,
         pitch: s = 0
-    } = t, {
+    } = e, {
         longitude: i,
         latitude: n,
         zoom: o,
         bearing: a = 0
-    } = t;
-    (i < -180 || i > 180) && (i = hh(i + 180, 360) - 180), (a < -180 || a > 180) && (a = hh(a + 180, 360) - 180);
-    let c = is(r / np);
+    } = e;
+    (i < -180 || i > 180) && (i = hf(i + 180, 360) - 180), (a < -180 || a > 180) && (a = hf(a + 180, 360) - 180);
+    let c = is(r / op);
     if (o <= c) o = c, n = 0;
     else {
         let l = r / 2 / Math.pow(2, o),
-            h = Me([0, l])[1];
-        if (n < h) n = h;
+            f = Mt([0, l])[1];
+        if (n < f) n = f;
         else {
-            let d = Me([0, np - l])[1];
+            let d = Mt([0, op - l])[1];
             n > d && (n = d)
         }
     }
     return {
-        width: e,
+        width: t,
         height: r,
         longitude: i,
         latitude: n,
         zoom: o,
         pitch: s,
         bearing: a
     }
 }
-var vE = `
+var Pw = `
 const int max_lights = 2;
 uniform mat4 shadow_uViewProjectionMatrices[max_lights];
 uniform vec4 shadow_uProjectCenters[max_lights];
 uniform bool shadow_uDrawShadowMap;
 uniform bool shadow_uUseShadowMap;
 uniform int shadow_uLightId;
 uniform float shadow_uLightCount;
@@ -10770,15 +10770,15 @@
         shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
       }
     }
   }
   return gl_Position;
 }
 `,
-    ME = `
+    Cw = `
 const int max_lights = 2;
 uniform bool shadow_uDrawShadowMap;
 uniform bool shadow_uUseShadowMap;
 uniform sampler2D shadow_uShadowMap0;
 uniform sampler2D shadow_uShadowMap1;
 uniform vec4 shadow_uColor;
 uniform float shadow_uLightCount;
@@ -10815,115 +10815,115 @@
       mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
       blendedAlpha
     );
   }
   return color;
 }
 `,
-    PE = ft(FE),
-    CE = ft(DE),
-    IE = [0, 0, 0, 1],
-    OE = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
+    Iw = he(Dw),
+    Ow = he(Bw),
+    Nw = [0, 0, 0, 1],
+    Fw = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
 
-function NE(t, e) {
-    let [r, s, i] = t, n = qt([r, s, i], e);
+function kw(e, t) {
+    let [r, s, i] = e, n = qe([r, s, i], t);
     return Number.isFinite(i) ? n : [n[0], n[1], 0]
 }
 
-function FE({
-    viewport: t,
-    center: e
+function Dw({
+    viewport: e,
+    center: t
 }) {
-    return new fe(t.viewProjectionMatrix).invert().transform(e)
+    return new ht(e.viewProjectionMatrix).invert().transform(t)
 }
 
-function DE({
-    viewport: t,
-    shadowMatrices: e
+function Bw({
+    viewport: e,
+    shadowMatrices: t
 }) {
     let r = [],
-        s = t.pixelUnprojectionMatrix,
-        i = t.isGeospatial ? void 0 : 1,
+        s = e.pixelUnprojectionMatrix,
+        i = e.isGeospatial ? void 0 : 1,
         n = [
             [0, 0, i],
-            [t.width, 0, i],
-            [0, t.height, i],
-            [t.width, t.height, i],
+            [e.width, 0, i],
+            [0, e.height, i],
+            [e.width, e.height, i],
             [0, 0, -1],
-            [t.width, 0, -1],
-            [0, t.height, -1],
-            [t.width, t.height, -1]
-        ].map(o => NE(o, s));
-    for (let o of e) {
-        let a = o.clone().translate(new _e(t.center).negate()),
-            c = n.map(h => a.transform(h)),
-            l = new fe().ortho({
-                left: Math.min(...c.map(h => h[0])),
-                right: Math.max(...c.map(h => h[0])),
-                bottom: Math.min(...c.map(h => h[1])),
-                top: Math.max(...c.map(h => h[1])),
-                near: Math.min(...c.map(h => -h[2])),
-                far: Math.max(...c.map(h => -h[2]))
+            [e.width, 0, -1],
+            [0, e.height, -1],
+            [e.width, e.height, -1]
+        ].map(o => kw(o, s));
+    for (let o of t) {
+        let a = o.clone().translate(new gt(e.center).negate()),
+            c = n.map(f => a.transform(f)),
+            l = new ht().ortho({
+                left: Math.min(...c.map(f => f[0])),
+                right: Math.max(...c.map(f => f[0])),
+                bottom: Math.min(...c.map(f => f[1])),
+                top: Math.max(...c.map(f => f[1])),
+                near: Math.min(...c.map(f => -f[2])),
+                far: Math.max(...c.map(f => -f[2]))
             });
         r.push(l.multiplyRight(o))
     }
     return r
 }
 
-function kE(t, e) {
+function Uw(e, t) {
     let {
         shadowEnabled: r = !0
-    } = t;
-    if (!r || !t.shadowMatrices || !t.shadowMatrices.length) return {
+    } = e;
+    if (!r || !e.shadowMatrices || !e.shadowMatrices.length) return {
         shadow_uDrawShadowMap: !1,
         shadow_uUseShadowMap: !1,
-        shadow_uShadowMap0: t.dummyShadowMap,
-        shadow_uShadowMap1: t.dummyShadowMap
+        shadow_uShadowMap0: e.dummyShadowMap,
+        shadow_uShadowMap1: e.dummyShadowMap
     };
     let s = {
-            shadow_uDrawShadowMap: !!t.drawToShadowMap,
-            shadow_uUseShadowMap: t.shadowMaps ? t.shadowMaps.length > 0 : !1,
-            shadow_uColor: t.shadowColor || IE,
-            shadow_uLightId: t.shadowLightId || 0,
-            shadow_uLightCount: t.shadowMatrices.length
-        },
-        i = PE({
-            viewport: t.viewport,
-            center: e.project_uCenter
+            shadow_uDrawShadowMap: !!e.drawToShadowMap,
+            shadow_uUseShadowMap: e.shadowMaps ? e.shadowMaps.length > 0 : !1,
+            shadow_uColor: e.shadowColor || Nw,
+            shadow_uLightId: e.shadowLightId || 0,
+            shadow_uLightCount: e.shadowMatrices.length
+        },
+        i = Iw({
+            viewport: e.viewport,
+            center: t.project_uCenter
         }),
         n = [],
-        o = CE({
-            shadowMatrices: t.shadowMatrices,
-            viewport: t.viewport
+        o = Ow({
+            shadowMatrices: e.shadowMatrices,
+            viewport: e.viewport
         }).slice();
-    for (let a = 0; a < t.shadowMatrices.length; a++) {
+    for (let a = 0; a < e.shadowMatrices.length; a++) {
         let c = o[a],
-            l = c.clone().translate(new _e(t.viewport.center).negate());
-        e.project_uCoordinateSystem === X.LNGLAT && e.project_uProjectionMode === we.WEB_MERCATOR ? (o[a] = l, n[a] = i) : (o[a] = c.clone().multiplyRight(OE), n[a] = l.transform(i))
+            l = c.clone().translate(new gt(e.viewport.center).negate());
+        t.project_uCoordinateSystem === X.LNGLAT && t.project_uProjectionMode === St.WEB_MERCATOR ? (o[a] = l, n[a] = i) : (o[a] = c.clone().multiplyRight(Fw), n[a] = l.transform(i))
     }
     for (let a = 0; a < o.length; a++) s[`shadow_uViewProjectionMatrices[${a}]`] = o[a], s[`shadow_uProjectCenters[${a}]`] = n[a];
-    for (let a = 0; a < 2; a++) s[`shadow_uShadowMap${a}`] = t.shadowMaps && t.shadowMaps[a] || t.dummyShadowMap;
+    for (let a = 0; a < 2; a++) s[`shadow_uShadowMap${a}`] = e.shadowMaps && e.shadowMaps[a] || e.dummyShadowMap;
     return s
 }
-var Si = {
+var xi = {
     name: "shadow",
-    dependencies: [$t],
-    vs: vE,
-    fs: ME,
+    dependencies: [$e],
+    vs: Pw,
+    fs: Cw,
     inject: {
         "vs:DECKGL_FILTER_GL_POSITION": `
     position = shadow_setVertexPosition(geometry.position);
     `,
         "fs:DECKGL_FILTER_COLOR": `
     color = shadow_filterShadowColor(color);
     `
     },
-    getUniforms: (t = {}, e = {}) => "viewport" in t && (t.drawToShadowMap || t.shadowMaps && t.shadowMaps.length > 0) ? kE(t, e) : {}
+    getUniforms: (e = {}, t = {}) => "viewport" in e && (e.drawToShadowMap || e.shadowMaps && e.shadowMaps.length > 0) ? Uw(e, t) : {}
 };
-var wi = {
+var Si = {
     ...Mo,
     defaultUniforms: {
         ...Mo.defaultUniforms,
         useFloatColors: !1
     },
     inject: {
         "vs:DECKGL_FILTER_GL_POSITION": `
@@ -10941,1023 +10941,1023 @@
 
   // use picking color if rendering to picking FBO.
   color = picking_filterPickingColor(color);
     `
         }
     }
 };
-var BE = [$t],
-    UE = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
+var Lw = [$e],
+    Vw = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
 
-function _h() {
-    let t = yr.getDefaultShaderAssembler();
-    for (let e of BE) t.addDefaultModule(e);
-    for (let e of UE) t.addShaderHook(e);
-    return t
+function mf() {
+    let e = yr.getDefaultShaderAssembler();
+    for (let t of Lw) e.addDefaultModule(t);
+    for (let t of Vw) e.addShaderHook(t);
+    return e
 }
-var LE = [255, 255, 255],
-    VE = 1,
-    WE = 0,
+var Ww = [255, 255, 255],
+    zw = 1,
+    jw = 0,
     Ri = class {
-        constructor(e = {}) {
+        constructor(t = {}) {
             this.type = "ambient";
             let {
-                color: r = LE
-            } = e, {
-                intensity: s = VE
-            } = e;
-            this.id = e.id || `ambient-${WE++}`, this.color = r, this.intensity = s
+                color: r = Ww
+            } = t, {
+                intensity: s = zw
+            } = t;
+            this.id = t.id || `ambient-${jw++}`, this.color = r, this.intensity = s
         }
     };
-var zE = [255, 255, 255],
-    HE = 1,
-    jE = [0, 0, -1],
-    XE = 0,
+var Hw = [255, 255, 255],
+    Xw = 1,
+    $w = [0, 0, -1],
+    Yw = 0,
     ls = class {
-        constructor(e = {}) {
+        constructor(t = {}) {
             this.type = "directional";
             let {
-                color: r = zE
-            } = e, {
-                intensity: s = HE
-            } = e, {
-                direction: i = jE
-            } = e, {
+                color: r = Hw
+            } = t, {
+                intensity: s = Xw
+            } = t, {
+                direction: i = $w
+            } = t, {
                 _shadow: n = !1
-            } = e;
-            this.id = e.id || `directional-${XE++}`, this.color = r, this.intensity = s, this.type = "directional", this.direction = new _e(i).normalize().toArray(), this.shadow = n
+            } = t;
+            this.id = t.id || `directional-${Yw++}`, this.color = r, this.intensity = s, this.type = "directional", this.direction = new gt(i).normalize().toArray(), this.shadow = n
         }
-        getProjectedLight(e) {
+        getProjectedLight(t) {
             return this
         }
     };
 var vi = class {
-    constructor(e, r = {
+    constructor(t, r = {
         id: "pass"
     }) {
         let {
             id: s
         } = r;
-        this.id = s, this.device = e, this.props = {
+        this.id = s, this.device = t, this.props = {
             ...r
         }
     }
-    setProps(e) {
-        Object.assign(this.props, e)
+    setProps(t) {
+        Object.assign(this.props, t)
     }
-    render(e) {}
+    render(t) {}
     cleanup() {}
 };
-var vt = class extends vi {
+var ve = class extends vi {
     constructor() {
         super(...arguments), this._lastRenderIndex = -1
     }
-    render(e) {
-        let [r, s] = this.device.canvasContext.getDrawingBufferSize(), i = e.clearCanvas ?? !0, n = e.clearColor ?? (i ? [0, 0, 0, 0] : !1), o = i ? 1 : !1, a = e.colorMask ?? 15, c = {
+    render(t) {
+        let [r, s] = this.device.canvasContext.getDrawingBufferSize(), i = t.clearCanvas ?? !0, n = t.clearColor ?? (i ? [0, 0, 0, 0] : !1), o = i ? 1 : !1, a = t.colorMask ?? 15, c = {
             viewport: [0, 0, r, s]
         };
-        e.colorMask && (c.colorMask = a), e.scissorRect && (c.scissorRect = e.scissorRect);
+        t.colorMask && (c.colorMask = a), t.scissorRect && (c.scissorRect = t.scissorRect);
         let l = this.device.beginRenderPass({
-            framebuffer: e.target,
+            framebuffer: t.target,
             parameters: c,
             clearColor: n,
             clearDepth: o
         });
         try {
-            return this._drawLayers(l, e)
+            return this._drawLayers(l, t)
         } finally {
             l.end()
         }
     }
-    _drawLayers(e, r) {
+    _drawLayers(t, r) {
         let {
             target: s,
             moduleParameters: i,
             viewports: n,
             views: o,
             onViewportActive: a,
             clearStack: c = !0
         } = r;
         r.pass = r.pass || "unknown", c && (this._lastRenderIndex = -1);
         let l = [];
-        for (let h of n) {
-            let d = o && o[h.id];
-            a?.(h);
-            let p = this._getDrawLayerParams(h, r),
-                m = h.subViewports || [h];
+        for (let f of n) {
+            let d = o && o[f.id];
+            a?.(f);
+            let p = this._getDrawLayerParams(f, r),
+                m = f.subViewports || [f];
             for (let y of m) {
-                let x = this._drawLayersInViewport(e, {
+                let E = this._drawLayersInViewport(t, {
                     target: s,
                     moduleParameters: i,
                     viewport: y,
                     view: d,
                     pass: r.pass,
                     layers: r.layers
                 }, p);
-                l.push(x)
+                l.push(E)
             }
         }
         return l
     }
-    _getDrawLayerParams(e, {
+    _getDrawLayerParams(t, {
         layers: r,
         pass: s,
         isPicking: i = !1,
         layerFilter: n,
         cullRect: o,
         effects: a,
         moduleParameters: c
     }, l = !1) {
-        let h = [],
-            d = op(this._lastRenderIndex + 1),
+        let f = [],
+            d = ap(this._lastRenderIndex + 1),
             p = {
                 layer: r[0],
-                viewport: e,
+                viewport: t,
                 isPicking: i,
                 renderPass: s,
                 cullRect: o
             },
             m = {};
         for (let y = 0; y < r.length; y++) {
-            let x = r[y],
-                b = this._shouldDrawLayer(x, p, n, m),
-                w = {
-                    shouldDrawLayer: b
+            let E = r[y],
+                T = this._shouldDrawLayer(E, p, n, m),
+                S = {
+                    shouldDrawLayer: T
                 };
-            b && !l && (w.layerRenderIndex = d(x, b), w.moduleParameters = this._getModuleParameters(x, a, s, c), w.layerParameters = {
-                ...x.context.deck?.props.parameters,
-                ...this.getLayerParameters(x, y, e)
-            }), h[y] = w
+            T && !l && (S.layerRenderIndex = d(E, T), S.moduleParameters = this._getModuleParameters(E, a, s, c), S.layerParameters = {
+                ...E.context.deck?.props.parameters,
+                ...this.getLayerParameters(E, y, t)
+            }), f[y] = S
         }
-        return h
+        return f
     }
-    _drawLayersInViewport(e, {
+    _drawLayersInViewport(t, {
         layers: r,
         moduleParameters: s,
         pass: i,
         target: n,
         viewport: o,
         view: a
     }, c) {
-        let l = $E(this.device, {
+        let l = qw(this.device, {
             moduleParameters: s,
             target: n,
             viewport: o
         });
         if (a && a.props.clear) {
             let d = a.props.clear === !0 ? {
                 color: !0,
                 depth: !0
             } : a.props.clear;
             this.device.withParametersWebGL({
                 scissorTest: !0,
                 scissor: l
             }, () => this.device.clearWebGL(d))
         }
-        let h = {
+        let f = {
             totalCount: r.length,
             visibleCount: 0,
             compositeCount: 0,
             pickableCount: 0
         };
-        e.setParameters({
+        t.setParameters({
             viewport: l
         });
         for (let d = 0; d < r.length; d++) {
             let p = r[d],
                 {
                     shouldDrawLayer: m,
                     layerRenderIndex: y,
-                    moduleParameters: x,
-                    layerParameters: b
+                    moduleParameters: E,
+                    layerParameters: T
                 } = c[d];
-            if (m && p.props.pickable && h.pickableCount++, p.isComposite) h.compositeCount++;
+            if (m && p.props.pickable && f.pickableCount++, p.isComposite) f.compositeCount++;
             else if (m) {
-                h.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, y), x.viewport = o, p.context.renderPass = e;
+                f.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, y), E.viewport = o, p.context.renderPass = t;
                 try {
                     p._drawLayer({
-                        renderPass: e,
-                        moduleParameters: x,
+                        renderPass: t,
+                        moduleParameters: E,
                         uniforms: {
                             layerIndex: y
                         },
-                        parameters: b
+                        parameters: T
                     })
-                } catch (w) {
-                    p.raiseError(w, `drawing ${p} to ${i}`)
+                } catch (S) {
+                    p.raiseError(S, `drawing ${p} to ${i}`)
                 }
             }
         }
-        return h
+        return f
     }
-    shouldDrawLayer(e) {
+    shouldDrawLayer(t) {
         return !0
     }
-    getModuleParameters(e, r) {
+    getModuleParameters(t, r) {
         return null
     }
-    getLayerParameters(e, r, s) {
-        return e.props.parameters
+    getLayerParameters(t, r, s) {
+        return t.props.parameters
     }
-    _shouldDrawLayer(e, r, s, i) {
-        if (!(e.props.visible && this.shouldDrawLayer(e))) return !1;
-        r.layer = e;
-        let o = e.parent;
+    _shouldDrawLayer(t, r, s, i) {
+        if (!(t.props.visible && this.shouldDrawLayer(t))) return !1;
+        r.layer = t;
+        let o = t.parent;
         for (; o;) {
             if (!o.props.visible || !o.filterSubLayer(r)) return !1;
             r.layer = o, o = o.parent
         }
         if (s) {
             let a = r.layer.id;
             if (a in i || (i[a] = s(r)), !i[a]) return !1
         }
-        return e.activateViewport(r.viewport), !0
+        return t.activateViewport(r.viewport), !0
     }
-    _getModuleParameters(e, r, s, i) {
+    _getModuleParameters(t, r, s, i) {
         let n = this.device.canvasContext.cssToDeviceRatio(),
-            o = Object.assign(Object.create(e.internalState?.propsInTransition || e.props), {
-                autoWrapLongitude: e.wrapLongitude,
-                viewport: e.context.viewport,
-                mousePosition: e.context.mousePosition,
+            o = Object.assign(Object.create(t.internalState?.propsInTransition || t.props), {
+                autoWrapLongitude: t.wrapLongitude,
+                viewport: t.context.viewport,
+                mousePosition: t.context.mousePosition,
                 picking: {
                     isActive: 0
                 },
                 devicePixelRatio: n
             });
         if (r)
-            for (let a of r) Object.assign(o, a.getModuleParameters?.(e));
-        return Object.assign(o, this.getModuleParameters(e, r), i)
+            for (let a of r) Object.assign(o, a.getModuleParameters?.(t));
+        return Object.assign(o, this.getModuleParameters(t, r), i)
     }
 };
 
-function op(t = 0, e = {}) {
+function ap(e = 0, t = {}) {
     let r = {},
         s = (i, n) => {
             let o = i.props._offset,
                 a = i.id,
                 c = i.parent && i.parent.id,
                 l;
-            if (c && !(c in e) && s(i.parent, !1), c in r) {
-                let h = r[c] = r[c] || op(e[c], e);
-                l = h(i, n), r[a] = h
-            } else Number.isFinite(o) ? (l = o + (e[c] || 0), r[a] = null) : l = t;
-            return n && l >= t && (t = l + 1), e[a] = l, l
+            if (c && !(c in t) && s(i.parent, !1), c in r) {
+                let f = r[c] = r[c] || ap(t[c], t);
+                l = f(i, n), r[a] = f
+            } else Number.isFinite(o) ? (l = o + (t[c] || 0), r[a] = null) : l = e;
+            return n && l >= e && (e = l + 1), t[a] = l, l
         };
     return s
 }
 
-function $E(t, {
-    moduleParameters: e,
+function qw(e, {
+    moduleParameters: t,
     target: r,
     viewport: s
 }) {
-    let i = e && e.devicePixelRatio || t.canvasContext.cssToDeviceRatio(),
-        [, n] = t.canvasContext.getDrawingBufferSize(),
+    let i = t && t.devicePixelRatio || e.canvasContext.cssToDeviceRatio(),
+        [, n] = e.canvasContext.getDrawingBufferSize(),
         o = r ? r.height : n,
         a = s;
     return [a.x * i, o - (a.y + a.height) * i, a.width * i, a.height * i]
 }
-var Mi = class extends vt {
-    constructor(e, r) {
-        super(e, r), this.shadowMap = e.createTexture({
+var Mi = class extends ve {
+    constructor(t, r) {
+        super(t, r), this.shadowMap = t.createTexture({
             width: 1,
             height: 1,
             sampler: {
                 minFilter: "linear",
                 magFilter: "linear",
                 addressModeU: "clamp-to-edge",
                 addressModeV: "clamp-to-edge"
             }
-        }), this.depthBuffer = e.createTexture({
+        }), this.depthBuffer = t.createTexture({
             format: "depth16unorm",
             width: 1,
             height: 1,
             mipmaps: !1,
             dataFormat: 6402,
             type: 5125
-        }), this.fbo = e.createFramebuffer({
+        }), this.fbo = t.createFramebuffer({
             id: "shadowmap",
             width: 1,
             height: 1,
             colorAttachments: [this.shadowMap],
             depthStencilAttachment: this.depthBuffer
         })
     }
-    render(e) {
+    render(t) {
         let r = this.fbo,
             s = this.device.canvasContext.cssToDeviceRatio(),
-            i = e.viewports[0],
+            i = t.viewports[0],
             n = i.width * s,
             o = i.height * s,
             a = [1, 1, 1, 1];
         (n !== r.width || o !== r.height) && r.resize({
             width: n,
             height: o
         }), super.render({
-            ...e,
+            ...t,
             clearColor: a,
             target: r,
             pass: "shadow"
         })
     }
-    getLayerParameters(e, r, s) {
+    getLayerParameters(t, r, s) {
         return {
-            ...e.props.parameters,
+            ...t.props.parameters,
             blend: !1,
             depthRange: [0, 1],
             depthTest: !0
         }
     }
-    shouldDrawLayer(e) {
-        return e.props.shadowEnabled !== !1
+    shouldDrawLayer(t) {
+        return t.props.shadowEnabled !== !1
     }
     getModuleParameters() {
         return {
             drawToShadowMap: !0
         }
     }
     delete() {
         this.fbo && (this.fbo.destroy(), this.fbo = null), this.shadowMap && (this.shadowMap.destroy(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.destroy(), this.depthBuffer = null)
     }
 };
-var YE = {
+var Kw = {
         color: [255, 255, 255],
         intensity: 1
     },
-    ap = [{
+    cp = [{
         color: [255, 255, 255],
         intensity: 1,
         direction: [-1, 3, -1]
     }, {
         color: [255, 255, 255],
         intensity: .9,
         direction: [1, -8, -2.5]
     }],
-    qE = [0, 0, 0, 200 / 255],
+    Zw = [0, 0, 0, 200 / 255],
     Pr = class {
-        constructor(e = {}) {
-            this.id = "lighting-effect", this.shadowColor = qE, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(e)
+        constructor(t = {}) {
+            this.id = "lighting-effect", this.shadowColor = Zw, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(t)
         }
-        setup(e) {
-            this.context = e;
+        setup(t) {
+            this.context = t;
             let {
                 device: r,
                 deck: s
-            } = e;
-            this.shadow && !this.dummyShadowMap && (this._createShadowPasses(r), s._addDefaultShaderModule(Si), this.dummyShadowMap = r.createTexture({
+            } = t;
+            this.shadow && !this.dummyShadowMap && (this._createShadowPasses(r), s._addDefaultShaderModule(xi), this.dummyShadowMap = r.createTexture({
                 width: 1,
                 height: 1
             }))
         }
-        setProps(e) {
+        setProps(t) {
             this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
-            for (let r in e) {
-                let s = e[r];
+            for (let r in t) {
+                let s = t[r];
                 switch (s.type) {
                     case "ambient":
                         this.ambientLight = s;
                         break;
                     case "directional":
                         this.directionalLights.push(s);
                         break;
                     case "point":
                         this.pointLights.push(s);
                         break;
                     default:
                 }
             }
-            this._applyDefaultLights(), this.shadow = this.directionalLights.some(r => r.shadow), this.context && this.setup(this.context), this.props = e
+            this._applyDefaultLights(), this.shadow = this.directionalLights.some(r => r.shadow), this.context && this.setup(this.context), this.props = t
         }
         preRender({
-            layers: e,
+            layers: t,
             layerFilter: r,
             viewports: s,
             onViewportActive: i,
             views: n
         }) {
             if (this.shadow) {
                 this.shadowMatrices = this._calculateMatrices();
                 for (let o = 0; o < this.shadowPasses.length; o++) this.shadowPasses[o].render({
-                    layers: e,
+                    layers: t,
                     layerFilter: r,
                     viewports: s,
                     onViewportActive: i,
                     views: n,
                     moduleParameters: {
                         shadowLightId: o,
                         dummyShadowMap: this.dummyShadowMap,
                         shadowMatrices: this.shadowMatrices
                     }
                 })
             }
         }
-        getModuleParameters(e) {
+        getModuleParameters(t) {
             let r = this.shadow ? {
                 shadowMaps: this.shadowMaps,
                 dummyShadowMap: this.dummyShadowMap,
                 shadowColor: this.shadowColor,
                 shadowMatrices: this.shadowMatrices
             } : {};
             return r.lightSources = {
                 ambientLight: this.ambientLight,
                 directionalLights: this.directionalLights.map(s => s.getProjectedLight({
-                    layer: e
+                    layer: t
                 })),
                 pointLights: this.pointLights.map(s => s.getProjectedLight({
-                    layer: e
+                    layer: t
                 }))
             }, r
         }
-        cleanup(e) {
+        cleanup(t) {
             for (let r of this.shadowPasses) r.delete();
-            this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(Si))
+            this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, t.deck._removeDefaultShaderModule(xi))
         }
         _calculateMatrices() {
-            let e = [];
+            let t = [];
             for (let r of this.directionalLights) {
-                let s = new fe().lookAt({
-                    eye: new _e(r.direction).negate()
+                let s = new ht().lookAt({
+                    eye: new gt(r.direction).negate()
                 });
-                e.push(s)
+                t.push(s)
             }
-            return e
+            return t
         }
-        _createShadowPasses(e) {
+        _createShadowPasses(t) {
             for (let r = 0; r < this.directionalLights.length; r++) {
-                let s = new Mi(e);
+                let s = new Mi(t);
                 this.shadowPasses[r] = s, this.shadowMaps[r] = s.shadowMap
             }
         }
         _applyDefaultLights() {
             let {
-                ambientLight: e,
+                ambientLight: t,
                 pointLights: r,
                 directionalLights: s
             } = this;
-            !e && r.length === 0 && s.length === 0 && (this.ambientLight = new Ri(YE), this.directionalLights.push(new ls(ap[0]), new ls(ap[1])))
+            !t && r.length === 0 && s.length === 0 && (this.ambientLight = new Ri(Kw), this.directionalLights.push(new ls(cp[0]), new ls(cp[1])))
         }
     };
-var mh = class {
-        constructor(e = {}) {
+var bf = class {
+        constructor(t = {}) {
             this._pool = [], this.opts = {
                 overAlloc: 2,
                 poolSize: 100
-            }, this.setOptions(e)
+            }, this.setOptions(t)
         }
-        setOptions(e) {
-            Object.assign(this.opts, e)
+        setOptions(t) {
+            Object.assign(this.opts, t)
         }
-        allocate(e, r, {
+        allocate(t, r, {
             size: s = 1,
             type: i,
             padding: n = 0,
             copy: o = !1,
             initialize: a = !1,
             maxCount: c
         }) {
-            let l = i || e && e.constructor || Float32Array,
-                h = r * s + n;
-            if (ArrayBuffer.isView(e)) {
-                if (h <= e.length) return e;
-                if (h * e.BYTES_PER_ELEMENT <= e.buffer.byteLength) return new l(e.buffer, 0, h)
+            let l = i || t && t.constructor || Float32Array,
+                f = r * s + n;
+            if (ArrayBuffer.isView(t)) {
+                if (f <= t.length) return t;
+                if (f * t.BYTES_PER_ELEMENT <= t.buffer.byteLength) return new l(t.buffer, 0, f)
             }
             let d = 1 / 0;
             c && (d = c * s + n);
-            let p = this._allocate(l, h, a, d);
-            return e && o ? p.set(e) : a || p.fill(0, 0, 4), this._release(e), p
+            let p = this._allocate(l, f, a, d);
+            return t && o ? p.set(t) : a || p.fill(0, 0, 4), this._release(t), p
         }
-        release(e) {
-            this._release(e)
+        release(t) {
+            this._release(t)
         }
-        _allocate(e, r, s, i) {
+        _allocate(t, r, s, i) {
             let n = Math.max(Math.ceil(r * this.opts.overAlloc), 1);
             n > i && (n = i);
             let o = this._pool,
-                a = e.BYTES_PER_ELEMENT * n,
+                a = t.BYTES_PER_ELEMENT * n,
                 c = o.findIndex(l => l.byteLength >= a);
             if (c >= 0) {
-                let l = new e(o.splice(c, 1)[0], 0, n);
+                let l = new t(o.splice(c, 1)[0], 0, n);
                 return s && l.fill(0), l
             }
-            return new e(n)
+            return new t(n)
         }
-        _release(e) {
-            if (!ArrayBuffer.isView(e)) return;
+        _release(t) {
+            if (!ArrayBuffer.isView(t)) return;
             let r = this._pool,
                 {
                     buffer: s
-                } = e,
+                } = t,
                 {
                     byteLength: i
                 } = s,
                 n = r.findIndex(o => o.byteLength >= i);
             n < 0 ? r.push(s) : (n > 0 || r.length < this.opts.poolSize) && r.splice(n, 0, s), r.length > this.opts.poolSize && r.shift()
         }
     },
-    Mt = new mh;
+    Me = new bf;
 
-function fs() {
+function hs() {
     return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
 }
 
-function lp(t) {
-    return [t[12], t[13], t[14]]
+function fp(e) {
+    return [e[12], e[13], e[14]]
 }
 
-function hp(t) {
+function hp(e) {
     return {
-        left: hs(t[3] + t[0], t[7] + t[4], t[11] + t[8], t[15] + t[12]),
-        right: hs(t[3] - t[0], t[7] - t[4], t[11] - t[8], t[15] - t[12]),
-        bottom: hs(t[3] + t[1], t[7] + t[5], t[11] + t[9], t[15] + t[13]),
-        top: hs(t[3] - t[1], t[7] - t[5], t[11] - t[9], t[15] - t[13]),
-        near: hs(t[3] + t[2], t[7] + t[6], t[11] + t[10], t[15] + t[14]),
-        far: hs(t[3] - t[2], t[7] - t[6], t[11] - t[10], t[15] - t[14])
+        left: fs(e[3] + e[0], e[7] + e[4], e[11] + e[8], e[15] + e[12]),
+        right: fs(e[3] - e[0], e[7] - e[4], e[11] - e[8], e[15] - e[12]),
+        bottom: fs(e[3] + e[1], e[7] + e[5], e[11] + e[9], e[15] + e[13]),
+        top: fs(e[3] - e[1], e[7] - e[5], e[11] - e[9], e[15] - e[13]),
+        near: fs(e[3] + e[2], e[7] + e[6], e[11] + e[10], e[15] + e[14]),
+        far: fs(e[3] - e[2], e[7] - e[6], e[11] - e[10], e[15] - e[14])
     }
 }
-var cp = new _e;
-
-function hs(t, e, r, s) {
-    cp.set(t, e, r);
-    let i = cp.len();
+var lp = new gt;
+
+function fs(e, t, r, s) {
+    lp.set(e, t, r);
+    let i = lp.len();
     return {
         distance: s / i,
-        normal: new _e(-t / i, -e / i, -r / i)
+        normal: new gt(-e / i, -t / i, -r / i)
     }
 }
 
-function fp(t) {
-    return t - Math.fround(t)
+function up(e) {
+    return e - Math.fround(e)
 }
 var Pi;
 
-function Wo(t, e) {
+function Wo(e, t) {
     let {
         size: r = 1,
         startIndex: s = 0
-    } = e, i = e.endIndex !== void 0 ? e.endIndex : t.length, n = (i - s) / r;
-    Pi = Mt.allocate(Pi, n, {
+    } = t, i = t.endIndex !== void 0 ? t.endIndex : e.length, n = (i - s) / r;
+    Pi = Me.allocate(Pi, n, {
         type: Float32Array,
         size: r * 2
     });
     let o = s,
         a = 0;
     for (; o < i;) {
         for (let c = 0; c < r; c++) {
-            let l = t[o++];
-            Pi[a + c] = l, Pi[a + c + r] = fp(l)
+            let l = e[o++];
+            Pi[a + c] = l, Pi[a + c + r] = up(l)
         }
         a += r * 2
     }
     return Pi.subarray(0, n * r * 2)
 }
 
-function up(t) {
-    let e = null,
+function dp(e) {
+    let t = null,
         r = !1;
-    for (let s of t) s && (e ? (r || (e = [
-        [e[0][0], e[0][1]],
-        [e[1][0], e[1][1]]
-    ], r = !0), e[0][0] = Math.min(e[0][0], s[0][0]), e[0][1] = Math.min(e[0][1], s[0][1]), e[1][0] = Math.max(e[1][0], s[1][0]), e[1][1] = Math.max(e[1][1], s[1][1])) : e = s);
-    return e
+    for (let s of e) s && (t ? (r || (t = [
+        [t[0][0], t[0][1]],
+        [t[1][0], t[1][1]]
+    ], r = !0), t[0][0] = Math.min(t[0][0], s[0][0]), t[0][1] = Math.min(t[0][1], s[0][1]), t[1][0] = Math.max(t[1][0], s[1][0]), t[1][1] = Math.max(t[1][1], s[1][1])) : t = s);
+    return t
 }
-var KE = Math.PI / 180,
-    ZE = fs(),
-    dp = [0, 0, 0],
-    QE = {
+var Qw = Math.PI / 180,
+    Jw = hs(),
+    pp = [0, 0, 0],
+    Gw = {
         unitsPerMeter: [1, 1, 1],
         metersPerUnit: [1, 1, 1]
     };
 
-function JE({
-    width: t,
-    height: e,
+function tA({
+    width: e,
+    height: t,
     orthographic: r,
     fovyRadians: s,
     focalDistance: i,
     padding: n,
     near: o,
     far: a
 }) {
-    let c = t / e,
-        l = r ? new fe().orthographic({
+    let c = e / t,
+        l = r ? new ht().orthographic({
             fovy: s,
             aspect: c,
             focalDistance: i,
             near: o,
             far: a
-        }) : new fe().perspective({
+        }) : new ht().perspective({
             fovy: s,
             aspect: c,
             near: o,
             far: a
         });
     if (n) {
         let {
-            left: h = 0,
+            left: f = 0,
             right: d = 0,
             top: p = 0,
             bottom: m = 0
-        } = n, y = Le((h + t - d) / 2, 0, t) - t / 2, x = Le((p + e - m) / 2, 0, e) - e / 2;
-        l[8] -= y * 2 / t, l[9] += x * 2 / e
+        } = n, y = Lt((f + e - d) / 2, 0, e) - e / 2, E = Lt((p + t - m) / 2, 0, t) - t / 2;
+        l[8] -= y * 2 / e, l[9] += E * 2 / t
     }
     return l
 }
 var zo = class zo {
-    constructor(e = {}) {
-        this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || QE, this.focalDistance = e.focalDistance || 1, this.position = e.position || dp, this.modelMatrix = e.modelMatrix || null;
+    constructor(t = {}) {
+        this._frustumPlanes = {}, this.id = t.id || this.constructor.displayName || "viewport", this.x = t.x || 0, this.y = t.y || 0, this.width = t.width || 1, this.height = t.height || 1, this.zoom = t.zoom || 0, this.padding = t.padding, this.distanceScales = t.distanceScales || Gw, this.focalDistance = t.focalDistance || 1, this.position = t.position || pp, this.modelMatrix = t.modelMatrix || null;
         let {
             longitude: r,
             latitude: s
-        } = e;
-        this.isGeospatial = Number.isFinite(s) && Number.isFinite(r), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this)
+        } = t;
+        this.isGeospatial = Number.isFinite(s) && Number.isFinite(r), this._initProps(t), this._initMatrices(t), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this)
     }
     get subViewports() {
         return null
     }
     get metersPerPixel() {
         return this.distanceScales.metersPerUnit[2] / this.scale
     }
     get projectionMode() {
-        return this.isGeospatial ? this.zoom < 12 ? we.WEB_MERCATOR : we.WEB_MERCATOR_AUTO_OFFSET : we.IDENTITY
+        return this.isGeospatial ? this.zoom < 12 ? St.WEB_MERCATOR : St.WEB_MERCATOR_AUTO_OFFSET : St.IDENTITY
     }
-    equals(e) {
-        return e instanceof zo ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && wt(e.projectionMatrix, this.projectionMatrix) && wt(e.viewMatrix, this.viewMatrix) : !1
+    equals(t) {
+        return t instanceof zo ? this === t ? !0 : t.width === this.width && t.height === this.height && t.scale === this.scale && Se(t.projectionMatrix, this.projectionMatrix) && Se(t.viewMatrix, this.viewMatrix) : !1
     }
-    project(e, {
+    project(t, {
         topLeft: r = !0
     } = {}) {
-        let s = this.projectPosition(e),
+        let s = this.projectPosition(t),
             i = cs(s, this.pixelProjectionMatrix),
             [n, o] = i,
             a = r ? o : this.height - o;
-        return e.length === 2 ? [n, a] : [n, a, i[2]]
+        return t.length === 2 ? [n, a] : [n, a, i[2]]
     }
-    unproject(e, {
+    unproject(t, {
         topLeft: r = !0,
         targetZ: s
     } = {}) {
-        let [i, n, o] = e, a = r ? n : this.height - n, c = s && s * this.distanceScales.unitsPerMeter[2], l = qt([i, a, o], this.pixelUnprojectionMatrix, c), [h, d, p] = this.unprojectPosition(l);
-        return Number.isFinite(o) ? [h, d, p] : Number.isFinite(s) ? [h, d, s] : [h, d]
+        let [i, n, o] = t, a = r ? n : this.height - n, c = s && s * this.distanceScales.unitsPerMeter[2], l = qe([i, a, o], this.pixelUnprojectionMatrix, c), [f, d, p] = this.unprojectPosition(l);
+        return Number.isFinite(o) ? [f, d, p] : Number.isFinite(s) ? [f, d, s] : [f, d]
     }
-    projectPosition(e) {
-        let [r, s] = this.projectFlat(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
+    projectPosition(t) {
+        let [r, s] = this.projectFlat(t), i = (t[2] || 0) * this.distanceScales.unitsPerMeter[2];
         return [r, s, i]
     }
-    unprojectPosition(e) {
-        let [r, s] = this.unprojectFlat(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
+    unprojectPosition(t) {
+        let [r, s] = this.unprojectFlat(t), i = (t[2] || 0) * this.distanceScales.metersPerUnit[2];
         return [r, s, i]
     }
-    projectFlat(e) {
+    projectFlat(t) {
         if (this.isGeospatial) {
-            let r = Rt(e);
-            return r[1] = Le(r[1], -318, 830), r
+            let r = Re(t);
+            return r[1] = Lt(r[1], -318, 830), r
         }
-        return e
+        return t
     }
-    unprojectFlat(e) {
-        return this.isGeospatial ? Me(e) : e
+    unprojectFlat(t) {
+        return this.isGeospatial ? Mt(t) : t
     }
-    getBounds(e = {}) {
+    getBounds(t = {}) {
         let r = {
-                targetZ: e.z || 0
+                targetZ: t.z || 0
             },
             s = this.unproject([0, 0], r),
             i = this.unproject([this.width, 0], r),
             n = this.unproject([0, this.height], r),
             o = this.unproject([this.width, this.height], r);
         return [Math.min(s[0], i[0], n[0], o[0]), Math.min(s[1], i[1], n[1], o[1]), Math.max(s[0], i[0], n[0], o[0]), Math.max(s[1], i[1], n[1], o[1])]
     }
-    getDistanceScales(e) {
-        return e ? as({
-            longitude: e[0],
-            latitude: e[1],
+    getDistanceScales(t) {
+        return t ? as({
+            longitude: t[0],
+            latitude: t[1],
             highPrecision: !0
         }) : this.distanceScales
     }
     containsPixel({
-        x: e,
+        x: t,
         y: r,
         width: s = 1,
         height: i = 1
     }) {
-        return e < this.x + this.width && this.x < e + s && r < this.y + this.height && this.y < r + i
+        return t < this.x + this.width && this.x < t + s && r < this.y + this.height && this.y < r + i
     }
     getFrustumPlanes() {
         return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, hp(this.viewProjectionMatrix)), this._frustumPlanes)
     }
-    panByPosition(e, r) {
+    panByPosition(t, r) {
         return null
     }
-    _initProps(e) {
-        let r = e.longitude,
-            s = e.latitude;
-        this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = dh({
+    _initProps(t) {
+        let r = t.longitude,
+            s = t.latitude;
+        this.isGeospatial && (Number.isFinite(t.zoom) || (this.zoom = pf({
             latitude: s
-        }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || as({
+        }) + Math.log2(this.focalDistance)), this.distanceScales = t.distanceScales || as({
             latitude: s,
             longitude: r
         }));
         let i = Math.pow(2, this.zoom);
         this.scale = i;
         let {
             position: n,
             modelMatrix: o
-        } = e, a = dp;
-        if (n && (a = o ? new fe(o).transformAsVector(n, []) : n), this.isGeospatial) {
+        } = t, a = pp;
+        if (n && (a = o ? new ht(o).transformAsVector(n, []) : n), this.isGeospatial) {
             let c = this.projectPosition([r, s, 0]);
-            this.center = new _e(a).scale(this.distanceScales.unitsPerMeter).add(c)
+            this.center = new gt(a).scale(this.distanceScales.unitsPerMeter).add(c)
         } else this.center = this.projectPosition(a)
     }
-    _initMatrices(e) {
+    _initMatrices(t) {
         let {
-            viewMatrix: r = ZE,
+            viewMatrix: r = Jw,
             projectionMatrix: s = null,
             orthographic: i = !1,
             fovyRadians: n,
             fovy: o = 75,
             near: a = .1,
             far: c = 1e3,
             padding: l = null,
-            focalDistance: h = 1
-        } = e;
-        this.viewMatrixUncentered = r, this.viewMatrix = new fe().multiplyRight(r).translate(new _e(this.center).negate()), this.projectionMatrix = s || JE({
+            focalDistance: f = 1
+        } = t;
+        this.viewMatrixUncentered = r, this.viewMatrix = new ht().multiplyRight(r).translate(new gt(this.center).negate()), this.projectionMatrix = s || tA({
             width: this.width,
             height: this.height,
             orthographic: i,
-            fovyRadians: n || o * KE,
-            focalDistance: h,
+            fovyRadians: n || o * Qw,
+            focalDistance: f,
             padding: l,
             near: a,
             far: c
         });
-        let d = fs();
-        ne.multiply(d, d, this.projectionMatrix), ne.multiply(d, d, this.viewMatrix), this.viewProjectionMatrix = d, this.viewMatrixInverse = ne.invert([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = lp(this.viewMatrixInverse);
-        let p = fs(),
-            m = fs();
-        ne.scale(p, p, [this.width / 2, -this.height / 2, 1]), ne.translate(p, p, [1, -1, 0]), ne.multiply(m, p, this.viewProjectionMatrix), this.pixelProjectionMatrix = m, this.pixelUnprojectionMatrix = ne.invert(fs(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || W.warn("Pixel project matrix not invertible")()
+        let d = hs();
+        nt.multiply(d, d, this.projectionMatrix), nt.multiply(d, d, this.viewMatrix), this.viewProjectionMatrix = d, this.viewMatrixInverse = nt.invert([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = fp(this.viewMatrixInverse);
+        let p = hs(),
+            m = hs();
+        nt.scale(p, p, [this.width / 2, -this.height / 2, 1]), nt.translate(p, p, [1, -1, 0]), nt.multiply(m, p, this.viewProjectionMatrix), this.pixelProjectionMatrix = m, this.pixelUnprojectionMatrix = nt.invert(hs(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || W.warn("Pixel project matrix not invertible")()
     }
 };
 zo.displayName = "Viewport";
-var Kt = zo;
-var Ci = class Ci extends Kt {
-    constructor(e = {}) {
+var Ke = zo;
+var Ci = class Ci extends Ke {
+    constructor(t = {}) {
         let {
             latitude: r = 0,
             longitude: s = 0,
             zoom: i = 0,
             pitch: n = 0,
             bearing: o = 0,
             nearZMultiplier: a = .1,
             farZMultiplier: c = 1.01,
             nearZ: l,
-            farZ: h,
+            farZ: f,
             orthographic: d = !1,
             projectionMatrix: p,
             repeat: m = !1,
             worldOffset: y = 0,
-            position: x,
-            padding: b,
-            legacyMeterSizes: w = !1
-        } = e, {
+            position: E,
+            padding: T,
+            legacyMeterSizes: S = !1
+        } = t, {
             width: R,
             height: v,
             altitude: C = 1.5
-        } = e, O = Math.pow(2, i);
+        } = t, O = Math.pow(2, i);
         R = R || 1, v = v || 1;
         let N, U = null;
         if (p) C = p[5] / 2, N = Mr(C);
         else {
-            e.fovy ? (N = e.fovy, C = xi(N)) : N = Mr(C);
+            t.fovy ? (N = t.fovy, C = Ei(N)) : N = Mr(C);
             let B;
-            if (b) {
+            if (T) {
                 let {
                     top: F = 0,
                     bottom: L = 0
-                } = b;
-                B = [0, Le((F + v - L) / 2, 0, v) - v / 2]
+                } = T;
+                B = [0, Lt((F + v - L) / 2, 0, v) - v / 2]
             }
-            U = ph({
+            U = _f({
                 width: R,
                 height: v,
                 scale: O,
-                center: x && [0, 0, x[2] * Ei(r)],
+                center: E && [0, 0, E[2] * wi(r)],
                 offset: B,
                 pitch: n,
                 fovy: N,
                 nearZMultiplier: a,
                 farZMultiplier: c
-            }), Number.isFinite(l) && (U.near = l), Number.isFinite(h) && (U.far = h)
+            }), Number.isFinite(l) && (U.near = l), Number.isFinite(f) && (U.far = f)
         }
-        let k = Uo({
+        let D = Uo({
             height: v,
             pitch: n,
             bearing: o,
             scale: O,
             altitude: C
         });
-        y && (k = new fe().translate([512 * y, 0, 0]).multiplyLeft(k)), super({
-            ...e,
+        y && (D = new ht().translate([512 * y, 0, 0]).multiplyLeft(D)), super({
+            ...t,
             width: R,
             height: v,
-            viewMatrix: k,
+            viewMatrix: D,
             longitude: s,
             latitude: r,
             zoom: i,
             ...U,
             fovy: N,
             focalDistance: C
-        }), this.latitude = r, this.longitude = s, this.zoom = i, this.pitch = n, this.bearing = o, this.altitude = C, this.fovy = N, this.orthographic = d, this._subViewports = m ? [] : null, this._pseudoMeters = w, Object.freeze(this)
+        }), this.latitude = r, this.longitude = s, this.zoom = i, this.pitch = n, this.bearing = o, this.altitude = C, this.fovy = N, this.orthographic = d, this._subViewports = m ? [] : null, this._pseudoMeters = S, Object.freeze(this)
     }
     get subViewports() {
         if (this._subViewports && !this._subViewports.length) {
-            let e = this.getBounds(),
-                r = Math.floor((e[0] + 180) / 360),
-                s = Math.ceil((e[2] - 180) / 360);
+            let t = this.getBounds(),
+                r = Math.floor((t[0] + 180) / 360),
+                s = Math.ceil((t[2] - 180) / 360);
             for (let i = r; i <= s; i++) {
                 let n = i ? new Ci({
                     ...this,
                     worldOffset: i
                 }) : this;
                 this._subViewports.push(n)
             }
         }
         return this._subViewports
     }
-    projectPosition(e) {
-        if (this._pseudoMeters) return super.projectPosition(e);
-        let [r, s] = this.projectFlat(e), i = (e[2] || 0) * Ei(e[1]);
+    projectPosition(t) {
+        if (this._pseudoMeters) return super.projectPosition(t);
+        let [r, s] = this.projectFlat(t), i = (t[2] || 0) * wi(t[1]);
         return [r, s, i]
     }
-    unprojectPosition(e) {
-        if (this._pseudoMeters) return super.unprojectPosition(e);
-        let [r, s] = this.unprojectFlat(e), i = (e[2] || 0) / Ei(s);
+    unprojectPosition(t) {
+        if (this._pseudoMeters) return super.unprojectPosition(t);
+        let [r, s] = this.unprojectFlat(t), i = (t[2] || 0) / wi(s);
         return [r, s, i]
     }
-    addMetersToLngLat(e, r) {
-        return Ai(e, r)
+    addMetersToLngLat(t, r) {
+        return Ai(t, r)
     }
-    panByPosition(e, r) {
-        let s = qt(r, this.pixelUnprojectionMatrix),
-            i = this.projectFlat(e),
-            n = lt.add([], i, lt.negate([], s)),
-            o = lt.add([], this.center, n),
+    panByPosition(t, r) {
+        let s = qe(r, this.pixelUnprojectionMatrix),
+            i = this.projectFlat(t),
+            n = le.add([], i, le.negate([], s)),
+            o = le.add([], this.center, n),
             [a, c] = this.unprojectFlat(o);
         return {
             longitude: a,
             latitude: c
         }
     }
-    getBounds(e = {}) {
-        let r = Vo(this, e.z || 0);
+    getBounds(t = {}) {
+        let r = Vo(this, t.z || 0);
         return [Math.min(r[0][0], r[1][0], r[2][0], r[3][0]), Math.min(r[0][1], r[1][1], r[2][1], r[3][1]), Math.max(r[0][0], r[1][0], r[2][0], r[3][0]), Math.max(r[0][1], r[1][1], r[2][1], r[3][1])]
     }
-    fitBounds(e, r = {}) {
+    fitBounds(t, r = {}) {
         let {
             width: s,
             height: i
         } = this, {
             longitude: n,
             latitude: o,
             zoom: a
         } = Lo({
             width: s,
             height: i,
-            bounds: e,
+            bounds: t,
             ...r
         });
         return new Ci({
             width: s,
             height: i,
             longitude: n,
             latitude: o,
             zoom: a
         })
     }
 };
 Ci.displayName = "WebMercatorViewport";
-var Zt = Ci;
-var pp = [0, 0, 0];
+var Ze = Ci;
+var _p = [0, 0, 0];
 
-function Th(t, e, r = !1) {
-    let s = e.projectPosition(t);
-    if (r && e instanceof Zt) {
-        let [i, n, o = 0] = t, a = e.getDistanceScales([i, n]);
+function yf(e, t, r = !1) {
+    let s = t.projectPosition(e);
+    if (r && t instanceof Ze) {
+        let [i, n, o = 0] = e, a = t.getDistanceScales([i, n]);
         s[2] = o * a.unitsPerMeter[2]
     }
     return s
 }
 
-function GE(t) {
+function eA(e) {
     let {
-        viewport: e,
+        viewport: t,
         modelMatrix: r,
         coordinateOrigin: s
-    } = t, {
+    } = e, {
         coordinateSystem: i,
         fromCoordinateSystem: n,
         fromCoordinateOrigin: o
-    } = t;
-    return i === X.DEFAULT && (i = e.isGeospatial ? X.LNGLAT : X.CARTESIAN), n === void 0 && (n = i), o === void 0 && (o = s), {
-        viewport: e,
+    } = e;
+    return i === X.DEFAULT && (i = t.isGeospatial ? X.LNGLAT : X.CARTESIAN), n === void 0 && (n = i), o === void 0 && (o = s), {
+        viewport: t,
         coordinateSystem: i,
         coordinateOrigin: s,
         modelMatrix: r,
         fromCoordinateSystem: n,
         fromCoordinateOrigin: o
     }
 }
 
-function yh(t, {
-    viewport: e,
+function Tf(e, {
+    viewport: t,
     modelMatrix: r,
     coordinateSystem: s,
     coordinateOrigin: i,
     offsetMode: n
 }) {
-    let [o, a, c = 0] = t;
-    switch (r && ([o, a, c] = ht.transformMat4([], [o, a, c, 1], r)), s) {
+    let [o, a, c = 0] = e;
+    switch (r && ([o, a, c] = fe.transformMat4([], [o, a, c, 1], r)), s) {
         case X.LNGLAT:
-            return Th([o, a, c], e, n);
+            return yf([o, a, c], t, n);
         case X.LNGLAT_OFFSETS:
-            return Th([o + i[0], a + i[1], c + (i[2] || 0)], e, n);
+            return yf([o + i[0], a + i[1], c + (i[2] || 0)], t, n);
         case X.METER_OFFSETS:
-            return Th(Ai(i, [o, a, c]), e, n);
+            return yf(Ai(i, [o, a, c]), t, n);
         case X.CARTESIAN:
         default:
-            return e.isGeospatial ? [o + i[0], a + i[1], c + i[2]] : e.projectPosition([o, a, c])
+            return t.isGeospatial ? [o + i[0], a + i[1], c + i[2]] : t.projectPosition([o, a, c])
     }
 }
 
-function gp(t, e) {
+function gp(e, t) {
     let {
         viewport: r,
         coordinateSystem: s,
         coordinateOrigin: i,
         modelMatrix: n,
         fromCoordinateSystem: o,
         fromCoordinateOrigin: a
-    } = GE(e), {
+    } = eA(t), {
         autoOffset: c = !0
-    } = e, {
-        geospatialOrigin: l = pp,
-        shaderCoordinateOrigin: h = pp,
+    } = t, {
+        geospatialOrigin: l = _p,
+        shaderCoordinateOrigin: f = _p,
         offsetMode: d = !1
-    } = c ? ch(r, s, i) : {}, p = yh(t, {
+    } = c ? lf(r, s, i) : {}, p = Tf(e, {
         viewport: r,
         modelMatrix: n,
         coordinateSystem: o,
         coordinateOrigin: a,
         offsetMode: d
     });
     if (d) {
-        let m = r.projectPosition(l || h);
+        let m = r.projectPosition(l || f);
         ss.sub(p, p, m)
     }
     return p
 }
-var eA = 1,
-    tA = 1,
+var rA = 1,
+    sA = 1,
     Cr = class {
         constructor() {
-            f(this, "time", 0);
-            f(this, "channels", new Map);
-            f(this, "animations", new Map);
-            f(this, "playing", !1);
-            f(this, "lastEngineTime", -1)
+            h(this, "time", 0);
+            h(this, "channels", new Map);
+            h(this, "animations", new Map);
+            h(this, "playing", !1);
+            h(this, "lastEngineTime", -1)
         }
-        addChannel(e) {
+        addChannel(t) {
             let {
                 delay: r = 0,
                 duration: s = Number.POSITIVE_INFINITY,
                 rate: i = 1,
                 repeat: n = 1
-            } = e, o = eA++, a = {
+            } = t, o = rA++, a = {
                 time: 0,
                 delay: r,
                 duration: s,
                 rate: i,
                 repeat: n
             };
             return this._setChannelTime(a, this.time), this.channels.set(o, a), o
         }
-        removeChannel(e) {
-            this.channels.delete(e);
-            for (let [r, s] of this.animations) s.channel === e && this.detachAnimation(r)
+        removeChannel(t) {
+            this.channels.delete(t);
+            for (let [r, s] of this.animations) s.channel === t && this.detachAnimation(r)
         }
-        isFinished(e) {
-            let r = this.channels.get(e);
+        isFinished(t) {
+            let r = this.channels.get(t);
             return r === void 0 ? !1 : this.time >= r.delay + r.duration * r.repeat
         }
-        getTime(e) {
-            if (e === void 0) return this.time;
-            let r = this.channels.get(e);
+        getTime(t) {
+            if (t === void 0) return this.time;
+            let r = this.channels.get(t);
             return r === void 0 ? -1 : r.time
         }
-        setTime(e) {
-            this.time = Math.max(0, e);
+        setTime(t) {
+            this.time = Math.max(0, t);
             let r = this.channels.values();
             for (let i of r) this._setChannelTime(i, this.time);
             let s = this.animations.values();
             for (let i of s) {
                 let {
                     animation: n,
                     channel: o
@@ -11970,142 +11970,142 @@
         }
         pause() {
             this.playing = !1, this.lastEngineTime = -1
         }
         reset() {
             this.setTime(0)
         }
-        attachAnimation(e, r) {
-            let s = tA++;
+        attachAnimation(t, r) {
+            let s = sA++;
             return this.animations.set(s, {
-                animation: e,
+                animation: t,
                 channel: r
-            }), e.setTime(this.getTime(r)), s
+            }), t.setTime(this.getTime(r)), s
         }
-        detachAnimation(e) {
-            this.animations.delete(e)
+        detachAnimation(t) {
+            this.animations.delete(t)
         }
-        update(e) {
-            this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e)
+        update(t) {
+            this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = t), this.setTime(this.time + (t - this.lastEngineTime)), this.lastEngineTime = t)
         }
-        _setChannelTime(e, r) {
-            let s = r - e.delay,
-                i = e.duration * e.repeat;
-            s >= i ? e.time = e.duration * e.rate : (e.time = Math.max(0, s) % e.duration, e.time *= e.rate)
+        _setChannelTime(t, r) {
+            let s = r - t.delay,
+                i = t.duration * t.repeat;
+            s >= i ? t.time = t.duration * t.rate : (t.time = Math.max(0, s) % t.duration, t.time *= t.rate)
         }
     };
-var rA = 0,
-    sA = {
+var iA = 0,
+    nA = {
         device: null,
         onAddHTML: () => "",
         onInitialize: async () => null,
         onRender: () => {},
         onFinalize: () => {},
-        onError: t => console.error(t),
-        stats: ke.stats.get(`animation-loop-${rA++}`),
+        onError: e => console.error(e),
+        stats: Dt.stats.get(`animation-loop-${iA++}`),
         useDevicePixels: !0,
         autoResizeViewport: !1,
         autoResizeDrawingBuffer: !1
     },
     Ii = class {
-        constructor(e) {
-            f(this, "device", null);
-            f(this, "canvas", null);
-            f(this, "props");
-            f(this, "animationProps", null);
-            f(this, "timeline", null);
-            f(this, "stats");
-            f(this, "cpuTime");
-            f(this, "gpuTime");
-            f(this, "frameRate");
-            f(this, "display");
-            f(this, "needsRedraw", "initialized");
-            f(this, "_initialized", !1);
-            f(this, "_running", !1);
-            f(this, "_animationFrameId", null);
-            f(this, "_nextFramePromise", null);
-            f(this, "_resolveNextFrame", null);
-            f(this, "_cpuStartTime", 0);
+        constructor(t) {
+            h(this, "device", null);
+            h(this, "canvas", null);
+            h(this, "props");
+            h(this, "animationProps", null);
+            h(this, "timeline", null);
+            h(this, "stats");
+            h(this, "cpuTime");
+            h(this, "gpuTime");
+            h(this, "frameRate");
+            h(this, "display");
+            h(this, "needsRedraw", "initialized");
+            h(this, "_initialized", !1);
+            h(this, "_running", !1);
+            h(this, "_animationFrameId", null);
+            h(this, "_nextFramePromise", null);
+            h(this, "_resolveNextFrame", null);
+            h(this, "_cpuStartTime", 0);
             if (this.props = {
-                    ...sA,
-                    ...e
-                }, e = this.props, !e.device) throw new Error("No device provided");
+                    ...nA,
+                    ...t
+                }, t = this.props, !t.device) throw new Error("No device provided");
             let {
                 useDevicePixels: r = !0
             } = this.props;
-            this.stats = e.stats || new Ne({
+            this.stats = t.stats || new Nt({
                 id: "animation-loop-stats"
             }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
-                autoResizeViewport: e.autoResizeViewport,
-                autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
+                autoResizeViewport: t.autoResizeViewport,
+                autoResizeDrawingBuffer: t.autoResizeDrawingBuffer,
                 useDevicePixels: r
             }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this)
         }
         destroy() {
             this.stop(), this._setDisplay(null)
         }
         delete() {
             this.destroy()
         }
-        setNeedsRedraw(e) {
-            return this.needsRedraw = this.needsRedraw || e, this
+        setNeedsRedraw(t) {
+            return this.needsRedraw = this.needsRedraw || t, this
         }
-        setProps(e) {
-            return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this
+        setProps(t) {
+            return "autoResizeViewport" in t && (this.props.autoResizeViewport = t.autoResizeViewport || !1), "autoResizeDrawingBuffer" in t && (this.props.autoResizeDrawingBuffer = t.autoResizeDrawingBuffer || !1), "useDevicePixels" in t && (this.props.useDevicePixels = t.useDevicePixels || !1), this
         }
         async start() {
             if (this._running) return this;
             this._running = !0;
             try {
-                let e;
-                return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null
-            } catch (e) {
-                let r = e instanceof Error ? e : new Error("Unknown error");
+                let t;
+                return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (t !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null
+            } catch (t) {
+                let r = t instanceof Error ? t : new Error("Unknown error");
                 throw this.props.onError(r), r
             }
         }
         stop() {
             return this._running && (this.animationProps && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this
         }
         redraw() {
             return this.device?.isLost ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this)
         }
-        attachTimeline(e) {
-            return this.timeline = e, this.timeline
+        attachTimeline(t) {
+            return this.timeline = t, this.timeline
         }
         detachTimeline() {
             this.timeline = null
         }
         waitForRender() {
-            return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise(e => {
-                this._resolveNextFrame = e
+            return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise(t => {
+                this._resolveNextFrame = t
             })), this._nextFramePromise
         }
         async toDataURL() {
             if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement) return this.canvas.toDataURL();
             throw new Error("OffscreenCanvas")
         }
         _initialize() {
             this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport()
         }
-        _setDisplay(e) {
-            this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e
+        _setDisplay(t) {
+            this.display && (this.display.destroy(), this.display.animationLoop = null), t && (t.animationLoop = this), this.display = t
         }
         _requestAnimationFrame() {
             this._running && (this._animationFrameId = qc(this._animationFrame.bind(this)))
         }
         _cancelAnimationFrame() {
             this._animationFrameId !== null && (Kc(this._animationFrameId), this._animationFrameId = null)
         }
         _animationFrame() {
             this._running && (this.redraw(), this._requestAnimationFrame())
         }
-        _renderFrame(e) {
+        _renderFrame(t) {
             if (this.display) {
-                this.display._renderFrame(e);
+                this.display._renderFrame(t);
                 return
             }
             this.props.onRender(this._getAnimationProps()), this.device.submit()
         }
         _clearNeedsRedraw() {
             this.needsRedraw = !1
         }
@@ -12135,43 +12135,43 @@
         _getAnimationProps() {
             if (!this.animationProps) throw new Error("animationProps");
             return this.animationProps
         }
         _updateAnimationProps() {
             if (!this.animationProps) return;
             let {
-                width: e,
+                width: t,
                 height: r,
                 aspect: s
             } = this._getSizeAndAspect();
-            (e !== this.animationProps.width || r !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), s !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = r, this.animationProps.aspect = s, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime
+            (t !== this.animationProps.width || r !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), s !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = t, this.animationProps.height = r, this.animationProps.aspect = s, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime
         }
         async _initDevice() {
             if (this.device = await this.props.device, !this.device) throw new Error("No device provided");
             this.canvas = this.device.canvasContext?.canvas || null
         }
         _createInfoDiv() {
             if (this.canvas && this.props.onAddHTML) {
-                let e = document.createElement("div");
-                document.body.appendChild(e), e.style.position = "relative";
+                let t = document.createElement("div");
+                document.body.appendChild(t), t.style.position = "relative";
                 let r = document.createElement("div");
-                r.style.position = "absolute", r.style.left = "10px", r.style.bottom = "10px", r.style.width = "300px", r.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(r);
+                r.style.position = "absolute", r.style.left = "10px", r.style.bottom = "10px", r.style.width = "300px", r.style.background = "white", this.canvas instanceof HTMLCanvasElement && t.appendChild(this.canvas), t.appendChild(r);
                 let s = this.props.onAddHTML(r);
                 s && (r.innerHTML = s)
             }
         }
         _getSizeAndAspect() {
             if (!this.device) return {
                 width: 1,
                 height: 1,
                 aspect: 1
             };
-            let [e, r] = this.device?.canvasContext?.getPixelSize() || [1, 1], s = 1, i = this.device?.canvasContext?.canvas;
-            return i && i.clientHeight ? s = i.clientWidth / i.clientHeight : e > 0 && r > 0 && (s = e / r), {
-                width: e,
+            let [t, r] = this.device?.canvasContext?.getPixelSize() || [1, 1], s = 1, i = this.device?.canvasContext?.canvas;
+            return i && i.clientHeight ? s = i.clientWidth / i.clientHeight : t > 0 && r > 0 && (s = t / r), {
+                width: t,
                 height: r,
                 aspect: s
             }
         }
         _resizeViewport() {
             this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight)
         }
@@ -12185,79 +12185,79 @@
         }
         _endFrameTimers() {
             this.cpuTime.timeEnd()
         }
         _startEventHandling() {
             this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)))
         }
-        _onMousemove(e) {
-            e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY])
+        _onMousemove(t) {
+            t instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [t.offsetX, t.offsetY])
         }
-        _onMouseleave(e) {
+        _onMouseleave(t) {
             this._getAnimationProps()._mousePosition = null
         }
     };
-var Ho = class {
-    constructor(e) {
-        f(this, "id");
-        f(this, "userData", {});
-        f(this, "topology");
-        f(this, "bufferLayout", []);
-        f(this, "vertexCount");
-        f(this, "indices");
-        f(this, "attributes");
-        this.id = e.id || Ee("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && z(this.indices.usage === K.INDEX)
+var jo = class {
+    constructor(t) {
+        h(this, "id");
+        h(this, "userData", {});
+        h(this, "topology");
+        h(this, "bufferLayout", []);
+        h(this, "vertexCount");
+        h(this, "indices");
+        h(this, "attributes");
+        this.id = t.id || wt("geometry"), this.topology = t.topology, this.indices = t.indices || null, this.attributes = t.attributes, this.vertexCount = t.vertexCount, this.bufferLayout = t.bufferLayout || [], this.indices && z(this.indices.usage === K.INDEX)
     }
     destroy() {
         this.indices?.destroy();
-        for (let e of Object.values(this.attributes)) e.destroy()
+        for (let t of Object.values(this.attributes)) t.destroy()
     }
     getVertexCount() {
         return this.vertexCount
     }
     getAttributes() {
         return this.attributes
     }
     getIndexes() {
         return this.indices
     }
-    _calculateVertexCount(e) {
-        return e.byteLength / 12
+    _calculateVertexCount(t) {
+        return t.byteLength / 12
     }
 };
 
-function _p(t, e) {
-    if (e instanceof Ho) return e;
-    let r = iA(t, e),
+function mp(e, t) {
+    if (t instanceof jo) return t;
+    let r = oA(e, t),
         {
             attributes: s,
             bufferLayout: i
-        } = nA(t, e);
-    return new Ho({
-        topology: e.topology || "triangle-list",
+        } = aA(e, t);
+    return new jo({
+        topology: t.topology || "triangle-list",
         bufferLayout: i,
-        vertexCount: e.vertexCount,
+        vertexCount: t.vertexCount,
         indices: r,
         attributes: s
     })
 }
 
-function iA(t, e) {
-    if (!e.indices) return;
-    let r = e.indices.value;
-    return t.createBuffer({
+function oA(e, t) {
+    if (!t.indices) return;
+    let r = t.indices.value;
+    return e.createBuffer({
         usage: K.INDEX,
         data: r
     })
 }
 
-function nA(t, e) {
+function aA(e, t) {
     let r = [],
         s = {};
-    for (let [n, o] of Object.entries(e.attributes)) {
+    for (let [n, o] of Object.entries(t.attributes)) {
         let a = n;
         switch (n) {
             case "POSITION":
                 a = "positions";
                 break;
             case "NORMAL":
                 a = "normals";
@@ -12265,53 +12265,53 @@
             case "TEXCOORD_0":
                 a = "texCoords";
                 break;
             case "COLOR_0":
                 a = "colors";
                 break
         }
-        s[a] = t.createBuffer({
+        s[a] = e.createBuffer({
             data: o.value,
             id: `${n}-buffer`
         });
         let {
             value: c,
             size: l,
-            normalized: h
+            normalized: f
         } = o;
         r.push({
             name: a,
-            format: Xc(c, l, h)
+            format: Xc(c, l, f)
         })
     }
-    let i = e._calculateVertexCount(e.attributes, e.indices);
+    let i = t._calculateVertexCount(t.attributes, t.indices);
     return {
         attributes: s,
         bufferLayout: r,
         vertexCount: i
     }
 }
-var jo = class {
-    constructor(e) {
-        f(this, "modules");
-        f(this, "moduleUniforms");
-        f(this, "moduleBindings");
-        f(this, "moduleUniformsChanged");
-        let r = mr(Object.values(e));
-        P.log(1, "Creating ShaderInputs with modules", r.map(s => s.name))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
-        for (let [s, i] of Object.entries(e)) {
+var Ho = class {
+    constructor(t) {
+        h(this, "modules");
+        h(this, "moduleUniforms");
+        h(this, "moduleBindings");
+        h(this, "moduleUniformsChanged");
+        let r = mr(Object.values(t));
+        P.log(1, "Creating ShaderInputs with modules", r.map(s => s.name))(), this.modules = t, this.moduleUniforms = {}, this.moduleBindings = {};
+        for (let [s, i] of Object.entries(t)) {
             let n = s;
             this.moduleUniforms[n] = i.defaultUniforms || {}, this.moduleBindings[n] = {}
         }
     }
     destroy() {}
-    setProps(e) {
-        for (let r of Object.keys(e)) {
+    setProps(t) {
+        for (let r of Object.keys(t)) {
             let s = r,
-                i = e[s],
+                i = t[s],
                 n = this.modules[s];
             if (!n) {
                 P.warn(`Module ${r} not found`)();
                 continue
             }
             let o = this.moduleUniforms[s],
                 a = n.getUniforms?.(i, this.moduleUniforms[s]) || i;
@@ -12324,230 +12324,230 @@
     getModules() {
         return Object.values(this.modules)
     }
     getUniformValues() {
         return this.moduleUniforms
     }
     getBindings() {
-        let e = {};
-        for (let r of Object.values(this.moduleBindings)) Object.assign(e, r);
-        return e
+        let t = {};
+        for (let r of Object.values(this.moduleBindings)) Object.assign(t, r);
+        return t
     }
     getDebugTable() {
-        let e = {};
+        let t = {};
         for (let [r, s] of Object.entries(this.moduleUniforms))
-            for (let [i, n] of Object.entries(s)) e[`${r}.${i}`] = {
+            for (let [i, n] of Object.entries(s)) t[`${r}.${i}`] = {
                 type: this.modules[r].uniformTypes?.[i],
                 value: String(n)
             };
-        return e
+        return t
     }
 };
 var $o = class $o {
-    constructor(e) {
-        f(this, "device");
-        f(this, "_hashCounter", 0);
-        f(this, "_hashes", {});
-        f(this, "_renderPipelineCache", {});
-        f(this, "_computePipelineCache", {});
-        this.device = e
+    constructor(t) {
+        h(this, "device");
+        h(this, "_hashCounter", 0);
+        h(this, "_hashes", {});
+        h(this, "_renderPipelineCache", {});
+        h(this, "_computePipelineCache", {});
+        this.device = t
     }
-    static getDefaultPipelineFactory(e) {
-        return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new $o(e), e._lumaData.defaultPipelineFactory
+    static getDefaultPipelineFactory(t) {
+        return t._lumaData.defaultPipelineFactory = t._lumaData.defaultPipelineFactory || new $o(t), t._lumaData.defaultPipelineFactory
     }
-    createRenderPipeline(e) {
+    createRenderPipeline(t) {
         let r = {
-                ...at.defaultProps,
-                ...e
+                ...ae.defaultProps,
+                ...t
             },
             s = this._hashRenderPipeline(r);
         if (!this._renderPipelineCache[s]) {
             let i = this.device.createRenderPipeline({
                 ...r,
                 id: r.id ? `${r.id}-cached` : void 0
             });
             i.hash = s, this._renderPipelineCache[s] = {
                 pipeline: i,
                 useCount: 0
             }
         }
         return this._renderPipelineCache[s].useCount++, this._renderPipelineCache[s].pipeline
     }
-    createComputePipeline(e) {
+    createComputePipeline(t) {
         let r = {
                 ...Qr.defaultProps,
-                ...e
+                ...t
             },
             s = this._hashComputePipeline(r);
         if (!this._computePipelineCache[s]) {
             let i = this.device.createComputePipeline({
                 ...r,
                 id: r.id ? `${r.id}-cached` : void 0
             });
             i.hash = s, this._computePipelineCache[s] = {
                 pipeline: i,
                 useCount: 0
             }
         }
         return this._computePipelineCache[s].useCount++, this._computePipelineCache[s].pipeline
     }
-    release(e) {
-        let r = e.hash,
-            s = e instanceof Qr ? this._computePipelineCache : this._renderPipelineCache;
+    release(t) {
+        let r = t.hash,
+            s = t instanceof Qr ? this._computePipelineCache : this._renderPipelineCache;
         s[r].useCount--, s[r].useCount === 0 && (s[r].pipeline.destroy(), delete s[r])
     }
-    _hashComputePipeline(e) {
-        return `${this._getHash(e.shader.source)}`
+    _hashComputePipeline(t) {
+        return `${this._getHash(t.shader.source)}`
     }
-    _hashRenderPipeline(e) {
-        let r = this._getHash(e.vs.source),
-            s = e.fs ? this._getHash(e.fs.source) : 0,
+    _hashRenderPipeline(t) {
+        let r = this._getHash(t.vs.source),
+            s = t.fs ? this._getHash(t.fs.source) : 0,
             i = "-",
-            n = this._getHash(JSON.stringify(e.bufferLayout));
+            n = this._getHash(JSON.stringify(t.bufferLayout));
         switch (this.device.type) {
             case "webgl":
                 return `${r}/${s}V${i}BL${n}`;
             default:
-                let o = this._getHash(JSON.stringify(e.parameters));
-                return `${r}/${s}V${i}T${e.topology}P${o}BL${n}`
+                let o = this._getHash(JSON.stringify(t.parameters));
+                return `${r}/${s}V${i}T${t.topology}P${o}BL${n}`
         }
     }
-    _getHash(e) {
-        return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e]
+    _getHash(t) {
+        return this._hashes[t] === void 0 && (this._hashes[t] = this._hashCounter++), this._hashes[t]
     }
 };
-f($o, "defaultProps", {
-    ...at.defaultProps
+h($o, "defaultProps", {
+    ...ae.defaultProps
 });
 var Xo = $o;
 var qo = class qo {
-    constructor(e) {
-        f(this, "device");
-        f(this, "_cache", {});
-        this.device = e
+    constructor(t) {
+        h(this, "device");
+        h(this, "_cache", {});
+        this.device = t
     }
-    static getDefaultShaderFactory(e) {
+    static getDefaultShaderFactory(t) {
         var r;
-        return (r = e._lumaData).defaultShaderFactory || (r.defaultShaderFactory = new qo(e)), e._lumaData.defaultShaderFactory
+        return (r = t._lumaData).defaultShaderFactory || (r.defaultShaderFactory = new qo(t)), t._lumaData.defaultShaderFactory
     }
-    createShader(e) {
-        let r = this._hashShader(e),
+    createShader(t) {
+        let r = this._hashShader(t),
             s = this._cache[r];
         if (!s) {
             let i = this.device.createShader({
-                ...e,
-                id: e.id ? `${e.id}-cached` : void 0
+                ...t,
+                id: t.id ? `${t.id}-cached` : void 0
             });
             this._cache[r] = s = {
                 shader: i,
                 useCount: 0
             }
         }
         return s.useCount++, s.shader
     }
-    release(e) {
-        let r = this._hashShader(e),
+    release(t) {
+        let r = this._hashShader(t),
             s = this._cache[r];
         s && (s.useCount--, s.useCount === 0 && (delete this._cache[r], s.shader.destroy()))
     }
-    _hashShader(e) {
-        return `${e.stage}:${e.source}`
+    _hashShader(t) {
+        return `${t.stage}:${t.source}`
     }
 };
-f(qo, "defaultProps", {
-    ...Er.defaultProps
+h(qo, "defaultProps", {
+    ...wr.defaultProps
 });
 var Yo = qo;
 
-function mp(t, e) {
+function bp(e, t) {
     let r = {},
         s = "Values";
-    if (t.attributes.length === 0 && !t.varyings?.length) return {
+    if (e.attributes.length === 0 && !e.varyings?.length) return {
         "No attributes or varyings": {
             [s]: "N/A"
         }
     };
-    for (let i of t.attributes)
+    for (let i of e.attributes)
         if (i) {
             let n = `${i.location} ${i.name}: ${i.type}`;
             r[`in ${n}`] = {
                 [s]: i.stepMode || "vertex"
             }
-        } for (let i of t.varyings || []) {
+        } for (let i of e.varyings || []) {
         let n = `${i.location} ${i.name}`;
         r[`out ${n}`] = {
             [s]: JSON.stringify(i.accessor)
         }
     }
     return r
 }
-var ce = null,
-    bh = null;
+var ct = null,
+    wf = null;
 
-function Tp(t, {
-    id: e,
+function yp(e, {
+    id: t,
     minimap: r,
     opaque: s,
     top: i = "0",
     left: n = "0",
     rgbaScale: o = 1
 }) {
-    ce || (ce = document.createElement("canvas"), ce.id = e, ce.title = e, ce.style.zIndex = "100", ce.style.position = "absolute", ce.style.top = i, ce.style.left = n, ce.style.border = "blue 1px solid", ce.style.transform = "scaleY(-1)", document.body.appendChild(ce), bh = ce.getContext("2d")), (ce.width !== t.width || ce.height !== t.height) && (ce.width = t.width / 2, ce.height = t.height / 2, ce.style.width = "400px", ce.style.height = "400px");
-    let a = t.device.readPixelsToArrayWebGL(t),
-        c = bh.createImageData(t.width, t.height),
+    ct || (ct = document.createElement("canvas"), ct.id = t, ct.title = t, ct.style.zIndex = "100", ct.style.position = "absolute", ct.style.top = i, ct.style.left = n, ct.style.border = "blue 1px solid", ct.style.transform = "scaleY(-1)", document.body.appendChild(ct), wf = ct.getContext("2d")), (ct.width !== e.width || ct.height !== e.height) && (ct.width = e.width / 2, ct.height = e.height / 2, ct.style.width = "400px", ct.style.height = "400px");
+    let a = e.device.readPixelsToArrayWebGL(e),
+        c = wf.createImageData(e.width, e.height),
         l = 0;
-    for (let h = 0; h < a.length; h += 4) c.data[l + h + 0] = a[h + 0] * o, c.data[l + h + 1] = a[h + 1] * o, c.data[l + h + 2] = a[h + 2] * o, c.data[l + h + 3] = s ? 255 : a[h + 3] * o;
-    bh.putImageData(c, 0, 0)
+    for (let f = 0; f < a.length; f += 4) c.data[l + f + 0] = a[f + 0] * o, c.data[l + f + 1] = a[f + 1] * o, c.data[l + f + 2] = a[f + 2] * o, c.data[l + f + 3] = s ? 255 : a[f + 3] * o;
+    wf.putImageData(c, 0, 0)
 }
 var us = 2,
-    oA = 1e4,
+    cA = 1e4,
     Ko = class Ko {
-        constructor(e, r) {
-            f(this, "device");
-            f(this, "id");
-            f(this, "source");
-            f(this, "vs");
-            f(this, "fs");
-            f(this, "pipelineFactory");
-            f(this, "shaderFactory");
-            f(this, "userData", {});
-            f(this, "parameters");
-            f(this, "topology");
-            f(this, "bufferLayout");
-            f(this, "vertexCount");
-            f(this, "instanceCount", 0);
-            f(this, "indexBuffer", null);
-            f(this, "bufferAttributes", {});
-            f(this, "constantAttributes", {});
-            f(this, "bindings", {});
-            f(this, "uniforms", {});
-            f(this, "vertexArray");
-            f(this, "transformFeedback", null);
-            f(this, "pipeline");
-            f(this, "shaderInputs");
-            f(this, "_uniformStore");
-            f(this, "_attributeInfos", {});
-            f(this, "_gpuGeometry", null);
-            f(this, "_getModuleUniforms");
-            f(this, "props");
-            f(this, "_pipelineNeedsUpdate", "newly created");
-            f(this, "_needsRedraw", "initializing");
-            f(this, "_destroyed", !1);
-            f(this, "_lastDrawTimestamp", -1);
-            f(this, "_lastLogTime", 0);
-            f(this, "_logOpen", !1);
-            f(this, "_drawCount", 0);
+        constructor(t, r) {
+            h(this, "device");
+            h(this, "id");
+            h(this, "source");
+            h(this, "vs");
+            h(this, "fs");
+            h(this, "pipelineFactory");
+            h(this, "shaderFactory");
+            h(this, "userData", {});
+            h(this, "parameters");
+            h(this, "topology");
+            h(this, "bufferLayout");
+            h(this, "vertexCount");
+            h(this, "instanceCount", 0);
+            h(this, "indexBuffer", null);
+            h(this, "bufferAttributes", {});
+            h(this, "constantAttributes", {});
+            h(this, "bindings", {});
+            h(this, "uniforms", {});
+            h(this, "vertexArray");
+            h(this, "transformFeedback", null);
+            h(this, "pipeline");
+            h(this, "shaderInputs");
+            h(this, "_uniformStore");
+            h(this, "_attributeInfos", {});
+            h(this, "_gpuGeometry", null);
+            h(this, "_getModuleUniforms");
+            h(this, "props");
+            h(this, "_pipelineNeedsUpdate", "newly created");
+            h(this, "_needsRedraw", "initializing");
+            h(this, "_destroyed", !1);
+            h(this, "_lastDrawTimestamp", -1);
+            h(this, "_lastLogTime", 0);
+            h(this, "_logOpen", !1);
+            h(this, "_drawCount", 0);
             var a;
             this.props = {
                 ...Ko.defaultProps,
                 ...r
-            }, r = this.props, this.id = r.id || Ee("model"), this.device = e, Object.assign(this.userData, r.userData);
+            }, r = this.props, this.id = r.id || wt("model"), this.device = t, Object.assign(this.userData, r.userData);
             let s = Object.fromEntries(this.props.modules?.map(c => [c.name, c]) || []);
-            this.setShaderInputs(r.shaderInputs || new jo(s));
-            let i = aA(e),
+            this.setShaderInputs(r.shaderInputs || new Ho(s));
+            let i = lA(t),
                 n = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
             if (this.device.type === "webgpu" && this.props.source) {
                 (a = this.props).shaderLayout || (a.shaderLayout = Cl(this.props.source));
                 let {
                     source: c,
                     getUniforms: l
                 } = this.props.shaderAssembler.assembleShader({
@@ -12556,165 +12556,165 @@
                     modules: n
                 });
                 this.source = c, this._getModuleUniforms = l
             } else {
                 let {
                     vs: c,
                     fs: l,
-                    getUniforms: h
+                    getUniforms: f
                 } = this.props.shaderAssembler.assembleShaderPair({
                     platformInfo: i,
                     ...this.props,
                     modules: n
                 });
-                this.vs = c, this.fs = l, this._getModuleUniforms = h
+                this.vs = c, this.fs = l, this._getModuleUniforms = f
             }
-            this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, r.geometry && this.setGeometry(r.geometry), this.pipelineFactory = r.pipelineFactory || Xo.getDefaultPipelineFactory(this.device), this.shaderFactory = r.shaderFactory || Yo.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
+            this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, r.geometry && this.setGeometry(r.geometry), this.pipelineFactory = r.pipelineFactory || Xo.getDefaultPipelineFactory(this.device), this.shaderFactory = r.shaderFactory || Yo.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = t.createVertexArray({
                 renderPipeline: this.pipeline
             }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), r.vertexCount && this.setVertexCount(r.vertexCount), r.instanceCount && this.setInstanceCount(r.instanceCount), r.indexBuffer && this.setIndexBuffer(r.indexBuffer), r.attributes && this.setAttributes(r.attributes), r.constantAttributes && this.setConstantAttributes(r.constantAttributes), r.bindings && this.setBindings(r.bindings), r.uniforms && this.setUniforms(r.uniforms), r.moduleSettings && this.updateModuleSettings(r.moduleSettings), r.transformFeedback && (this.transformFeedback = r.transformFeedback), Object.seal(this)
         }
         destroy() {
             this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0)
         }
         needsRedraw() {
             this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
-            let e = this._needsRedraw;
-            return this._needsRedraw = !1, e
+            let t = this._needsRedraw;
+            return this._needsRedraw = !1, t
         }
-        setNeedsRedraw(e) {
-            this._needsRedraw || (this._needsRedraw = e)
+        setNeedsRedraw(t) {
+            this._needsRedraw || (this._needsRedraw = t)
         }
         predraw() {
             this.updateShaderInputs(), this.pipeline = this._updatePipeline()
         }
-        draw(e) {
+        draw(t) {
             this.predraw();
             let r;
             try {
                 this._logDrawCallStart(), this.pipeline = this._updatePipeline(), this.pipeline.setBindings(this.bindings, {
                     disableWarnings: this.props.disableWarnings
-                }), Vt(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
+                }), Ve(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
                 let {
                     indexBuffer: s
                 } = this.vertexArray, i = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
                 r = this.pipeline.draw({
-                    renderPass: e,
+                    renderPass: t,
                     vertexArray: this.vertexArray,
                     vertexCount: this.vertexCount,
                     instanceCount: this.instanceCount,
                     indexCount: i,
                     transformFeedback: this.transformFeedback || void 0,
                     parameters: this.parameters,
                     topology: this.topology
                 })
             } finally {
                 this._logDrawCallEnd()
             }
-            return this._logFramebuffer(e), r ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", r
+            return this._logFramebuffer(t), r ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", r
         }
-        setGeometry(e) {
+        setGeometry(t) {
             this._gpuGeometry?.destroy();
-            let r = e && _p(this.device, e);
-            r && (this.setTopology(r.topology || "triangle-list"), this.bufferLayout = yp(r.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(r)), this._gpuGeometry = r
+            let r = t && mp(this.device, t);
+            r && (this.setTopology(r.topology || "triangle-list"), this.bufferLayout = Tp(r.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(r)), this._gpuGeometry = r
         }
-        setTopology(e) {
-            e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"))
+        setTopology(t) {
+            t !== this.topology && (this.topology = t, this._setPipelineNeedsUpdate("topology"))
         }
-        setBufferLayout(e) {
-            this.bufferLayout = this._gpuGeometry ? yp(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
+        setBufferLayout(t) {
+            this.bufferLayout = this._gpuGeometry ? Tp(t, this._gpuGeometry.bufferLayout) : t, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
                 renderPipeline: this.pipeline
             }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry)
         }
-        setParameters(e) {
-            di(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"))
+        setParameters(t) {
+            di(t, this.parameters, 2) || (this.parameters = t, this._setPipelineNeedsUpdate("parameters"))
         }
-        setVertexCount(e) {
-            this.vertexCount = e, this.setNeedsRedraw("vertexCount")
+        setVertexCount(t) {
+            this.vertexCount = t, this.setNeedsRedraw("vertexCount")
         }
-        setInstanceCount(e) {
-            this.instanceCount = e, this.setNeedsRedraw("instanceCount")
+        setInstanceCount(t) {
+            this.instanceCount = t, this.setNeedsRedraw("instanceCount")
         }
-        setShaderInputs(e) {
-            this.shaderInputs = e, this._uniformStore = new li(this.shaderInputs.modules);
+        setShaderInputs(t) {
+            this.shaderInputs = t, this._uniformStore = new li(this.shaderInputs.modules);
             for (let r of Object.keys(this.shaderInputs.modules)) {
                 let s = this._uniformStore.getManagedUniformBuffer(this.device, r);
                 this.bindings[`${r}Uniforms`] = s
             }
             this.setNeedsRedraw("shaderInputs")
         }
         updateShaderInputs() {
             this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setNeedsRedraw("shaderInputs")
         }
-        setBindings(e) {
-            Object.assign(this.bindings, e), this.setNeedsRedraw("bindings")
+        setBindings(t) {
+            Object.assign(this.bindings, t), this.setNeedsRedraw("bindings")
         }
-        setTransformFeedback(e) {
-            this.transformFeedback = e, this.setNeedsRedraw("transformFeedback")
+        setTransformFeedback(t) {
+            this.transformFeedback = t, this.setNeedsRedraw("transformFeedback")
         }
-        setIndexBuffer(e) {
-            this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer")
+        setIndexBuffer(t) {
+            this.vertexArray.setIndexBuffer(t), this.setNeedsRedraw("indexBuffer")
         }
-        setAttributes(e, r) {
-            e.indices && P.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
-            for (let [s, i] of Object.entries(e)) {
-                let n = this.bufferLayout.find(c => bp(c).includes(s));
+        setAttributes(t, r) {
+            t.indices && P.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
+            for (let [s, i] of Object.entries(t)) {
+                let n = this.bufferLayout.find(c => wp(c).includes(s));
                 if (!n) {
                     P.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
                     continue
                 }
-                let o = bp(n),
+                let o = wp(n),
                     a = !1;
                 for (let c of o) {
                     let l = this._attributeInfos[c];
                     l && (this.vertexArray.setBuffer(l.location, i), a = !0)
                 }!a && !(r?.disableWarnings ?? this.props.disableWarnings) && P.warn(`Model(${this.id}): Ignoring buffer "${i.id}" for unknown attribute "${s}"`)()
             }
             this.setNeedsRedraw("attributes")
         }
-        setConstantAttributes(e, r) {
-            for (let [s, i] of Object.entries(e)) {
+        setConstantAttributes(t, r) {
+            for (let [s, i] of Object.entries(t)) {
                 let n = this._attributeInfos[s];
                 n ? this.vertexArray.setConstantWebGL(n.location, i) : (r?.disableWarnings ?? this.props.disableWarnings) || P.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${s}"`)()
             }
             this.setNeedsRedraw("constants")
         }
-        setUniforms(e) {
-            Vt(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms")
+        setUniforms(t) {
+            Ve(t) || (this.pipeline.setUniformsWebGL(t), Object.assign(this.uniforms, t)), this.setNeedsRedraw("uniforms")
         }
-        updateModuleSettings(e) {
+        updateModuleSettings(t) {
             let {
                 bindings: r,
                 uniforms: s
-            } = fi(this._getModuleUniforms(e));
+            } = hi(this._getModuleUniforms(t));
             Object.assign(this.bindings, r), Object.assign(this.uniforms, s), this.setNeedsRedraw("moduleSettings")
         }
         _getBindingsUpdateTimestamp() {
-            let e = 0;
-            for (let r of Object.values(this.bindings)) r instanceof br ? e = Math.max(e, r.texture.updateTimestamp) : r instanceof K || r instanceof se ? e = Math.max(e, r.updateTimestamp) : r instanceof Ar || (e = Math.max(e, r.buffer.updateTimestamp));
-            return e
+            let t = 0;
+            for (let r of Object.values(this.bindings)) r instanceof Tr ? t = Math.max(t, r.texture.updateTimestamp) : r instanceof K || r instanceof st ? t = Math.max(t, r.updateTimestamp) : r instanceof Ar || (t = Math.max(t, r.buffer.updateTimestamp));
+            return t
         }
-        _setGeometryAttributes(e) {
+        _setGeometryAttributes(t) {
             let r = {
-                ...e.attributes
+                ...t.attributes
             };
             for (let [s] of Object.entries(r)) !this.pipeline.shaderLayout.attributes.find(i => i.name === s) && s !== "positions" && delete r[s];
-            this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, {
+            this.vertexCount = t.vertexCount, this.setIndexBuffer(t.indices || null), this.setAttributes(t.attributes, {
                 disableWarnings: !0
             }), this.setAttributes(r, {
                 disableWarnings: this.props.disableWarnings
             }), this.setNeedsRedraw("geometry attributes")
         }
-        _setPipelineNeedsUpdate(e) {
-            this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = e), this.setNeedsRedraw(e)
+        _setPipelineNeedsUpdate(t) {
+            this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = t), this.setNeedsRedraw(t)
         }
         _updatePipeline() {
             if (this._pipelineNeedsUpdate) {
-                let e = null,
+                let t = null,
                     r = null;
-                this.pipeline && (P.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, r = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
+                this.pipeline && (P.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), t = this.pipeline.vs, r = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
                 let s = this.shaderFactory.createShader({
                         id: `${this.id}-vertex`,
                         stage: "vertex",
                         source: this.source || this.vs,
                         debug: this.props.debugShaders
                     }),
                     i = null;
@@ -12726,72 +12726,72 @@
                 })), this.pipeline = this.pipelineFactory.createRenderPipeline({
                     ...this.props,
                     bufferLayout: this.bufferLayout,
                     topology: this.topology,
                     parameters: this.parameters,
                     vs: s,
                     fs: i
-                }), this._attributeInfos = eo(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), r && this.shaderFactory.release(r)
+                }), this._attributeInfos = to(this.pipeline.shaderLayout, this.bufferLayout), t && this.shaderFactory.release(t), r && this.shaderFactory.release(r)
             }
             return this.pipeline
         }
         _logDrawCallStart() {
-            let e = P.level > 3 ? 0 : oA;
-            P.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, P.group(us, `>>> DRAWING MODEL ${this.id}`, {
+            let t = P.level > 3 ? 0 : cA;
+            P.level < 2 || Date.now() - this._lastLogTime < t || (this._lastLogTime = Date.now(), this._logOpen = !0, P.group(us, `>>> DRAWING MODEL ${this.id}`, {
                 collapsed: P.level <= 2
             })())
         }
         _logDrawCallEnd() {
             if (this._logOpen) {
-                let e = mp(this.pipeline.shaderLayout, this.id);
-                P.table(us, e)();
+                let t = bp(this.pipeline.shaderLayout, this.id);
+                P.table(us, t)();
                 let r = this.shaderInputs.getDebugTable();
                 for (let [i, n] of Object.entries(this.uniforms)) r[i] = {
                     value: n
                 };
                 P.table(us, r)();
                 let s = this._getAttributeDebugTable();
                 P.table(us, this._attributeInfos)(), P.table(us, s)(), P.groupEnd(us)(), this._logOpen = !1
             }
         }
-        _logFramebuffer(e) {
+        _logFramebuffer(t) {
             let r = P.get("framebuffer");
             if (this._drawCount++, !r || this._drawCount++ > 3 && this._drawCount % 60) return;
-            let s = e.props.framebuffer;
-            s && Tp(s, {
+            let s = t.props.framebuffer;
+            s && yp(s, {
                 id: s.id,
                 minimap: !0
             })
         }
         _getAttributeDebugTable() {
-            let e = {};
-            for (let [r, s] of Object.entries(this._attributeInfos)) e[s.location] = {
+            let t = {};
+            for (let [r, s] of Object.entries(this._attributeInfos)) t[s.location] = {
                 name: r,
                 type: s.shaderType,
                 values: this._getBufferOrConstantValues(this.vertexArray.attributes[s.location], s.bufferDataType)
             };
             if (this.vertexArray.indexBuffer) {
                 let {
                     indexBuffer: r
                 } = this.vertexArray, s = r.indexType === "uint32" ? new Uint32Array(r.debugData) : new Uint16Array(r.debugData);
-                e.indices = {
+                t.indices = {
                     name: "indices",
                     type: r.indexType,
                     values: s.toString()
                 }
             }
-            return e
+            return t
         }
-        _getBufferOrConstantValues(e, r) {
-            let s = hi(r);
-            return (e instanceof K ? new s(e.debugData) : e).toString()
+        _getBufferOrConstantValues(t, r) {
+            let s = fi(r);
+            return (t instanceof K ? new s(t.debugData) : t).toString()
         }
     };
-f(Ko, "defaultProps", {
-    ...at.defaultProps,
+h(Ko, "defaultProps", {
+    ...ae.defaultProps,
     source: null,
     vs: null,
     fs: null,
     id: "unnamed",
     handle: void 0,
     userData: {},
     defines: {},
@@ -12806,97 +12806,97 @@
     pipelineFactory: void 0,
     shaderFactory: void 0,
     transformFeedback: void 0,
     shaderAssembler: yr.getDefaultShaderAssembler(),
     debugShaders: void 0,
     disableWarnings: void 0
 });
-var Qt = Ko;
+var Qe = Ko;
 
-function yp(t, e) {
-    let r = [...t];
-    for (let s of e) {
+function Tp(e, t) {
+    let r = [...e];
+    for (let s of t) {
         let i = r.findIndex(n => n.name === s.name);
         i < 0 ? r.push(s) : r[i] = s
     }
     return r
 }
 
-function aA(t) {
+function lA(e) {
     return {
-        type: t.type,
-        shaderLanguage: t.info.shadingLanguage,
-        shaderLanguageVersion: t.info.shadingLanguageVersion,
-        gpu: t.info.gpu,
-        features: t.features
+        type: e.type,
+        shaderLanguage: e.info.shadingLanguage,
+        shaderLanguageVersion: e.info.shadingLanguageVersion,
+        gpu: e.info.gpu,
+        features: e.features
     }
 }
 
-function bp(t) {
-    return t.attributes ? t.attributes?.map(e => e.attribute) : [t.name]
-}
-var Ir = class t {
-    constructor(e, r = Qt.defaultProps) {
-        f(this, "device");
-        f(this, "model");
-        f(this, "transformFeedback");
-        z(t.isSupported(e), "BufferTransform not yet implemented on WebGPU"), this.device = e, this.model = new Qt(this.device, {
+function wp(e) {
+    return e.attributes ? e.attributes?.map(t => t.attribute) : [e.name]
+}
+var Ir = class e {
+    constructor(t, r = Qe.defaultProps) {
+        h(this, "device");
+        h(this, "model");
+        h(this, "transformFeedback");
+        z(e.isSupported(t), "BufferTransform not yet implemented on WebGPU"), this.device = t, this.model = new Qe(this.device, {
             id: r.id || "buffer-transform-model",
             fs: r.fs || Bc(),
             topology: r.topology || "point-list",
             ...r
         }), this.transformFeedback = this.device.createTransformFeedback({
             layout: this.model.pipeline.shaderLayout,
             buffers: r.feedbackBuffers
         }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this)
     }
-    static isSupported(e) {
-        return e?.info?.type === "webgl"
+    static isSupported(t) {
+        return t?.info?.type === "webgl"
     }
     destroy() {
         this.model && this.model.destroy()
     }
     delete() {
         this.destroy()
     }
-    run(e) {
-        let r = this.device.beginRenderPass(e);
+    run(t) {
+        let r = this.device.beginRenderPass(t);
         this.model.draw(r), r.end()
     }
-    update(...e) {
+    update(...t) {
         console.warn("TextureTransform#update() not implemented")
     }
-    getBuffer(e) {
-        return this.transformFeedback.getBuffer(e)
+    getBuffer(t) {
+        return this.transformFeedback.getBuffer(t)
     }
-    readAsync(e) {
-        let r = this.getBuffer(e);
+    readAsync(t) {
+        let r = this.getBuffer(t);
         if (r instanceof K) return r.readAsync();
         let {
             buffer: s,
             byteOffset: i = 0,
             byteLength: n = s.byteLength
         } = r;
         return s.readAsync(i, n)
     }
 };
 var Oi = class {
-    constructor(e) {
-        f(this, "id");
-        f(this, "topology");
-        f(this, "vertexCount");
-        f(this, "indices");
-        f(this, "attributes");
-        f(this, "userData", {});
+    constructor(t) {
+        h(this, "id");
+        h(this, "topology");
+        h(this, "vertexCount");
+        h(this, "indices");
+        h(this, "attributes");
+        h(this, "userData", {});
         let {
             attributes: r = {},
             indices: s = null,
             vertexCount: i = null
-        } = e;
-        this.id = e.id || Ee("geometry"), this.topology = e.topology, s && (this.indices = ArrayBuffer.isView(s) ? {
+        } = t;
+        this.id = t.id || wt("geometry"), this.topology = t.topology, s && (this.indices = ArrayBuffer.isView(s) ? {
             value: s,
             size: 1
         } : s), this.attributes = {};
         for (let [n, o] of Object.entries(r)) {
             let a = ArrayBuffer.isView(o) ? {
                 value: o
             } : o;
@@ -12909,601 +12909,601 @@
     }
     getAttributes() {
         return this.indices ? {
             indices: this.indices,
             ...this.attributes
         } : this.attributes
     }
-    _print(e) {
-        return `Geometry ${this.id} attribute ${e}`
+    _print(t) {
+        return `Geometry ${this.id} attribute ${t}`
     }
-    _setAttributes(e, r) {
+    _setAttributes(t, r) {
         return this
     }
-    _calculateVertexCount(e, r) {
+    _calculateVertexCount(t, r) {
         if (r) return r.value.length;
         let s = 1 / 0;
-        for (let i of Object.values(e)) {
+        for (let i of Object.values(t)) {
             let {
                 value: n,
                 size: o,
                 constant: a
             } = i;
             !a && n && o >= 1 && (s = Math.min(s, n.length / o))
         }
         return z(Number.isFinite(s)), s
     }
 };
-var cA = {
+var fA = {
         blendColorOperation: "add",
         blendColorSrcFactor: "one",
         blendColorDstFactor: "zero",
         blendAlphaOperation: "add",
         blendAlphaSrcFactor: "constant-alpha",
         blendAlphaDstFactor: "zero"
     },
-    Or = class extends vt {
+    Or = class extends ve {
         constructor() {
             super(...arguments), this._colorEncoderState = null
         }
-        render(e) {
-            return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e)
+        render(t) {
+            return "pickingFBO" in t ? this._drawPickingBuffer(t) : super.render(t)
         }
         _drawPickingBuffer({
-            layers: e,
+            layers: t,
             layerFilter: r,
             views: s,
             viewports: i,
             onViewportActive: n,
             pickingFBO: o,
             deviceRect: {
                 x: a,
                 y: c,
                 width: l,
-                height: h
+                height: f
             },
             cullRect: d,
             effects: p,
             pass: m = "picking",
             pickZ: y,
-            moduleParameters: x
+            moduleParameters: E
         }) {
             this.pickZ = y;
-            let b = this._resetColorEncoder(y),
-                w = [a, c, l, h],
+            let T = this._resetColorEncoder(y),
+                S = [a, c, l, f],
                 R = super.render({
                     target: o,
-                    layers: e,
+                    layers: t,
                     layerFilter: r,
                     views: s,
                     viewports: i,
                     onViewportActive: n,
                     cullRect: d,
                     effects: p?.filter(C => C.useInPicking),
                     pass: m,
                     isPicking: !0,
-                    moduleParameters: x,
+                    moduleParameters: E,
                     clearColor: [0, 0, 0, 0],
                     colorMask: 15,
-                    scissorRect: w
+                    scissorRect: S
                 });
             return this._colorEncoderState = null, {
-                decodePickingColor: b && hA.bind(null, b),
+                decodePickingColor: T && uA.bind(null, T),
                 stats: R
             }
         }
-        shouldDrawLayer(e) {
+        shouldDrawLayer(t) {
             let {
                 pickable: r,
                 operation: s
-            } = e.props;
+            } = t.props;
             return r && s.includes("draw") || s.includes("terrain") || s.includes("mask")
         }
         getModuleParameters() {
             return {
                 picking: {
                     isActive: 1,
                     isAttribute: this.pickZ
                 },
                 lightSources: {}
             }
         }
-        getLayerParameters(e, r, s) {
+        getLayerParameters(t, r, s) {
             let i = {
                     depthMask: !0,
                     depthTest: !0,
                     depthRange: [0, 1],
-                    ...e.props.parameters
+                    ...t.props.parameters
                 },
                 {
                     pickable: n,
                     operation: o
-                } = e.props;
-            return !this._colorEncoderState || o.includes("terrain") ? i.blend = !1 : n && o.includes("draw") && (Object.assign(i, cA), i.blend = !0, i.blendColor = lA(this._colorEncoderState, e, s)), i
+                } = t.props;
+            return !this._colorEncoderState || o.includes("terrain") ? i.blend = !1 : n && o.includes("draw") && (Object.assign(i, fA), i.blend = !0, i.blendColor = hA(this._colorEncoderState, t, s)), i
         }
-        _resetColorEncoder(e) {
-            return this._colorEncoderState = e ? null : {
+        _resetColorEncoder(t) {
+            return this._colorEncoderState = t ? null : {
                 byLayer: new Map,
                 byAlpha: []
             }, this._colorEncoderState
         }
     };
 
-function lA(t, e, r) {
+function hA(e, t, r) {
     let {
         byLayer: s,
         byAlpha: i
-    } = t, n, o = s.get(e);
+    } = e, n, o = s.get(t);
     return o ? (o.viewports.push(r), n = o.a) : (n = s.size + 1, n <= 255 ? (o = {
         a: n,
-        layer: e,
+        layer: t,
         viewports: [r]
-    }, s.set(e, o), i[n] = o) : (W.warn("Too many pickable layers, only picking the first 255")(), n = 0)), [0, 0, 0, n / 255]
+    }, s.set(t, o), i[n] = o) : (W.warn("Too many pickable layers, only picking the first 255")(), n = 0)), [0, 0, 0, n / 255]
 }
 
-function hA(t, e) {
-    let r = t.byAlpha[e[3]];
+function uA(e, t) {
+    let r = e.byAlpha[t[3]];
     return r && {
         pickedLayer: r.layer,
         pickedViewports: r.viewports,
-        pickedObjectIndex: r.layer.decodePickingColor(e)
+        pickedObjectIndex: r.layer.decodePickingColor(t)
     }
 }
-var Jt = {
+var Je = {
         NO_STATE: "Awaiting state",
         MATCHED: "Matched. State transferred from previous layer",
         INITIALIZED: "Initialized",
         AWAITING_GC: "Discarded. Awaiting garbage collection",
         AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
         FINALIZED: "Finalized! Awaiting garbage collection"
     },
     ds = Symbol.for("component"),
-    ut = Symbol.for("propTypes"),
+    ue = Symbol.for("propTypes"),
     Zo = Symbol.for("deprecatedProps"),
-    Pt = Symbol.for("asyncPropDefaults"),
-    dt = Symbol.for("asyncPropOriginal"),
-    Ye = Symbol.for("asyncPropResolved");
+    Pe = Symbol.for("asyncPropDefaults"),
+    de = Symbol.for("asyncPropOriginal"),
+    Yt = Symbol.for("asyncPropResolved");
 
-function Qo(t, e = () => !0) {
-    return Array.isArray(t) ? Ep(t, e, []) : e(t) ? [t] : []
+function Qo(e, t = () => !0) {
+    return Array.isArray(e) ? Ap(e, t, []) : t(e) ? [e] : []
 }
 
-function Ep(t, e, r) {
+function Ap(e, t, r) {
     let s = -1;
-    for (; ++s < t.length;) {
-        let i = t[s];
-        Array.isArray(i) ? Ep(i, e, r) : e(i) && r.push(i)
+    for (; ++s < e.length;) {
+        let i = e[s];
+        Array.isArray(i) ? Ap(i, t, r) : t(i) && r.push(i)
     }
     return r
 }
 
-function Ap({
-    target: t,
-    source: e,
+function Ep({
+    target: e,
+    source: t,
     start: r = 0,
     count: s = 1
 }) {
-    let i = e.length,
+    let i = t.length,
         n = s * i,
         o = 0;
-    for (let a = r; o < i; o++) t[a++] = e[o];
-    for (; o < n;) o < n - o ? (t.copyWithin(r + o, r, r + o), o *= 2) : (t.copyWithin(r + o, r, r + n - o), o = n);
-    return t
+    for (let a = r; o < i; o++) e[a++] = t[o];
+    for (; o < n;) o < n - o ? (e.copyWithin(r + o, r, r + o), o *= 2) : (e.copyWithin(r + o, r, r + n - o), o = n);
+    return e
 }
 var Ni = class {
-    constructor(e, r, s) {
-        this._loadCount = 0, this._subscribers = new Set, this.id = e, this.context = s, this.setData(r)
+    constructor(t, r, s) {
+        this._loadCount = 0, this._subscribers = new Set, this.id = t, this.context = s, this.setData(r)
     }
-    subscribe(e) {
-        this._subscribers.add(e)
+    subscribe(t) {
+        this._subscribers.add(t)
     }
-    unsubscribe(e) {
-        this._subscribers.delete(e)
+    unsubscribe(t) {
+        this._subscribers.delete(t)
     }
     inUse() {
         return this._subscribers.size > 0
     }
     delete() {}
     getData() {
         return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData())
     }
-    setData(e, r) {
-        if (e === this._data && !r) return;
-        this._data = e;
+    setData(t, r) {
+        if (t === this._data && !r) return;
+        this._data = t;
         let s = ++this._loadCount,
-            i = e;
-        typeof e == "string" && (i = qr(e)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then(n => {
+            i = t;
+        typeof t == "string" && (i = qr(t)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then(n => {
             this._loadCount === s && (this.isLoaded = !0, this._error = void 0, this._content = n)
         }).catch(n => {
             this._loadCount === s && (this.isLoaded = !0, this._error = n || !0)
-        })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
+        })) : (this.isLoaded = !0, this._error = void 0, this._content = t);
         for (let n of this._subscribers) n.onChange(this.getData())
     }
 };
 var Fi = class {
-    constructor(e) {
-        this.protocol = e.protocol || "resource://", this._context = {
-            device: e.device,
-            gl: e.device?.gl,
+    constructor(t) {
+        this.protocol = t.protocol || "resource://", this._context = {
+            device: t.device,
+            gl: t.device?.gl,
             resourceManager: this
         }, this._resources = {}, this._consumers = {}, this._pruneRequest = null
     }
-    contains(e) {
-        return e.startsWith(this.protocol) ? !0 : e in this._resources
+    contains(t) {
+        return t.startsWith(this.protocol) ? !0 : t in this._resources
     }
     add({
-        resourceId: e,
+        resourceId: t,
         data: r,
         forceUpdate: s = !1,
         persistent: i = !0
     }) {
-        let n = this._resources[e];
-        n ? n.setData(r, s) : (n = new Ni(e, r, this._context), this._resources[e] = n), n.persistent = i
+        let n = this._resources[t];
+        n ? n.setData(r, s) : (n = new Ni(t, r, this._context), this._resources[t] = n), n.persistent = i
     }
-    remove(e) {
-        let r = this._resources[e];
-        r && (r.delete(), delete this._resources[e])
+    remove(t) {
+        let r = this._resources[t];
+        r && (r.delete(), delete this._resources[t])
     }
     unsubscribe({
-        consumerId: e
+        consumerId: t
     }) {
-        let r = this._consumers[e];
+        let r = this._consumers[t];
         if (r) {
             for (let s in r) {
                 let i = r[s],
                     n = this._resources[i.resourceId];
                 n && n.unsubscribe(i)
             }
-            delete this._consumers[e], this.prune()
+            delete this._consumers[t], this.prune()
         }
     }
     subscribe({
-        resourceId: e,
+        resourceId: t,
         onChange: r,
         consumerId: s,
         requestId: i = "default"
     }) {
         let {
             _resources: n,
             protocol: o
         } = this;
-        e.startsWith(o) && (e = e.replace(o, ""), n[e] || this.add({
-            resourceId: e,
+        t.startsWith(o) && (t = t.replace(o, ""), n[t] || this.add({
+            resourceId: t,
             data: null,
             persistent: !1
         }));
-        let a = n[e];
+        let a = n[t];
         if (this._track(s, i, a, r), a) return a.getData()
     }
     prune() {
         this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0))
     }
     finalize() {
-        for (let e in this._resources) this._resources[e].delete()
+        for (let t in this._resources) this._resources[t].delete()
     }
-    _track(e, r, s, i) {
+    _track(t, r, s, i) {
         let n = this._consumers,
-            o = n[e] = n[e] || {},
+            o = n[t] = n[t] || {},
             a = o[r],
             c = a && a.resourceId && this._resources[a.resourceId];
         c && (c.unsubscribe(a), this.prune()), s && (a ? (a.onChange = i, a.resourceId = s.id) : a = {
             onChange: i,
             resourceId: s.id
         }, o[r] = a, s.subscribe(a))
     }
     _prune() {
         this._pruneRequest = null;
-        for (let e of Object.keys(this._resources)) {
-            let r = this._resources[e];
-            !r.persistent && !r.inUse() && (r.delete(), delete this._resources[e])
+        for (let t of Object.keys(this._resources)) {
+            let r = this._resources[t];
+            !r.persistent && !r.inUse() && (r.delete(), delete this._resources[t])
         }
     }
 };
-var fA = "layerManager.setLayers",
-    uA = "layerManager.activateViewport",
+var dA = "layerManager.setLayers",
+    pA = "layerManager.activateViewport",
     ps = class {
-        constructor(e, r) {
+        constructor(t, r) {
             this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = a => {
-                re(uA, this, a), a && (this.context.viewport = a)
+                rt(pA, this, a), a && (this.context.viewport = a)
             };
             let {
                 deck: s,
                 stats: i,
                 viewport: n,
                 timeline: o
             } = r || {};
             this.layers = [], this.resourceManager = new Fi({
-                device: e,
+                device: t,
                 protocol: "deck://"
             }), this.context = {
                 mousePosition: null,
                 userData: {},
                 layerManager: this,
-                device: e,
-                gl: e?.gl,
+                device: t,
+                gl: t?.gl,
                 deck: s,
-                shaderAssembler: _h(),
+                shaderAssembler: mf(),
                 defaultShaderModules: [],
                 renderPass: void 0,
-                stats: i || new Ne({
+                stats: i || new Nt({
                     id: "deck.gl"
                 }),
-                viewport: n || new Kt({
+                viewport: n || new Ke({
                     id: "DEFAULT-INITIAL-VIEWPORT"
                 }),
                 timeline: o || new Cr,
                 resourceManager: this.resourceManager,
                 onError: void 0
             }, Object.seal(this)
         }
         finalize() {
             this.resourceManager.finalize();
-            for (let e of this.layers) this._finalizeLayer(e)
+            for (let t of this.layers) this._finalizeLayer(t)
         }
-        needsRedraw(e = {
+        needsRedraw(t = {
             clearRedrawFlags: !1
         }) {
             let r = this._needsRedraw;
-            e.clearRedrawFlags && (this._needsRedraw = !1);
+            t.clearRedrawFlags && (this._needsRedraw = !1);
             for (let s of this.layers) {
-                let i = s.getNeedsRedraw(e);
+                let i = s.getNeedsRedraw(t);
                 r = r || i
             }
             return r
         }
         needsUpdate() {
             return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate
         }
-        setNeedsRedraw(e) {
-            this._needsRedraw = this._needsRedraw || e
+        setNeedsRedraw(t) {
+            this._needsRedraw = this._needsRedraw || t
         }
-        setNeedsUpdate(e) {
-            this._needsUpdate = this._needsUpdate || e
+        setNeedsUpdate(t) {
+            this._needsUpdate = this._needsUpdate || t
         }
         getLayers({
-            layerIds: e
+            layerIds: t
         } = {}) {
-            return e ? this.layers.filter(r => e.find(s => r.id.indexOf(s) === 0)) : this.layers
+            return t ? this.layers.filter(r => t.find(s => r.id.indexOf(s) === 0)) : this.layers
         }
-        setProps(e) {
-            "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError)
+        setProps(t) {
+            "debug" in t && (this._debug = t.debug), "userData" in t && (this.context.userData = t.userData), "layers" in t && (this._nextLayers = t.layers), "onError" in t && (this.context.onError = t.onError)
         }
-        setLayers(e, r) {
-            re(fA, this, r, e), this._lastRenderedLayers = e;
-            let s = Qo(e, Boolean);
+        setLayers(t, r) {
+            rt(dA, this, r, t), this._lastRenderedLayers = t;
+            let s = Qo(t, Boolean);
             for (let i of s) i.context = this.context;
             this._updateLayers(this.layers, s)
         }
         updateLayers() {
-            let e = this.needsUpdate();
-            e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null
+            let t = this.needsUpdate();
+            t && (this.setNeedsRedraw(`updating layers: ${t}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, t)), this._nextLayers = null
         }
-        addDefaultShaderModule(e) {
+        addDefaultShaderModule(t) {
             let {
                 defaultShaderModules: r
             } = this.context;
-            r.find(s => s.name === e.name) || (r.push(e), this._defaultShaderModulesChanged = !0)
+            r.find(s => s.name === t.name) || (r.push(t), this._defaultShaderModulesChanged = !0)
         }
-        removeDefaultShaderModule(e) {
+        removeDefaultShaderModule(t) {
             let {
                 defaultShaderModules: r
-            } = this.context, s = r.findIndex(i => i.name === e.name);
+            } = this.context, s = r.findIndex(i => i.name === t.name);
             s >= 0 && (r.splice(s, 1), this._defaultShaderModulesChanged = !0)
         }
-        _handleError(e, r, s) {
-            s.raiseError(r, `${e} of ${s}`)
+        _handleError(t, r, s) {
+            s.raiseError(r, `${t} of ${s}`)
         }
-        _updateLayers(e, r) {
+        _updateLayers(t, r) {
             let s = {};
-            for (let o of e) s[o.id] ? W.warn(`Multiple old layers with same id ${o.id}`)() : s[o.id] = o;
+            for (let o of t) s[o.id] ? W.warn(`Multiple old layers with same id ${o.id}`)() : s[o.id] = o;
             if (this._defaultShaderModulesChanged) {
-                for (let o of e) o.setNeedsUpdate(), o.setChangeFlags({
+                for (let o of t) o.setNeedsUpdate(), o.setChangeFlags({
                     extensionsChanged: !0
                 });
                 this._defaultShaderModulesChanged = !1
             }
             let i = [];
             this._updateSublayersRecursively(r, s, i), this._finalizeOldLayers(s);
             let n = !1;
             for (let o of i)
                 if (o.hasUniformTransition()) {
                     n = `Uniform transition in ${o}`;
                     break
                 } this._needsUpdate = n, this.layers = i
         }
-        _updateSublayersRecursively(e, r, s) {
-            for (let i of e) {
+        _updateSublayersRecursively(t, r, s) {
+            for (let i of t) {
                 i.context = this.context;
                 let n = r[i.id];
                 n === null && W.warn(`Multiple new layers with same id ${i.id}`)(), r[i.id] = null;
                 let o = null;
                 try {
                     this._debug && n !== i && i.validateProps(), n ? (this._transferLayerState(n, i), this._updateLayer(i)) : this._initializeLayer(i), s.push(i), o = i.isComposite ? i.getSubLayers() : null
                 } catch (a) {
                     this._handleError("matching", a, i)
                 }
                 o && this._updateSublayersRecursively(o, r, s)
             }
         }
-        _finalizeOldLayers(e) {
-            for (let r in e) {
-                let s = e[r];
+        _finalizeOldLayers(t) {
+            for (let r in t) {
+                let s = t[r];
                 s && this._finalizeLayer(s)
             }
         }
-        _initializeLayer(e) {
+        _initializeLayer(t) {
             try {
-                e._initialize(), e.lifecycle = Jt.INITIALIZED
+                t._initialize(), t.lifecycle = Je.INITIALIZED
             } catch (r) {
-                this._handleError("initialization", r, e)
+                this._handleError("initialization", r, t)
             }
         }
-        _transferLayerState(e, r) {
-            r._transferState(e), r.lifecycle = Jt.MATCHED, r !== e && (e.lifecycle = Jt.AWAITING_GC)
+        _transferLayerState(t, r) {
+            r._transferState(t), r.lifecycle = Je.MATCHED, r !== t && (t.lifecycle = Je.AWAITING_GC)
         }
-        _updateLayer(e) {
+        _updateLayer(t) {
             try {
-                e._update()
+                t._update()
             } catch (r) {
-                this._handleError("update", r, e)
+                this._handleError("update", r, t)
             }
         }
-        _finalizeLayer(e) {
-            this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Jt.AWAITING_FINALIZATION;
+        _finalizeLayer(t) {
+            this._needsRedraw = this._needsRedraw || `finalized ${t}`, t.lifecycle = Je.AWAITING_FINALIZATION;
             try {
-                e._finalize(), e.lifecycle = Jt.FINALIZED
+                t._finalize(), t.lifecycle = Je.FINALIZED
             } catch (r) {
-                this._handleError("finalization", r, e)
+                this._handleError("finalization", r, t)
             }
         }
     };
 
-function ue(t, e, r) {
-    if (t === e) return !0;
-    if (!r || !t || !e) return !1;
-    if (Array.isArray(t)) {
-        if (!Array.isArray(e) || t.length !== e.length) return !1;
-        for (let s = 0; s < t.length; s++)
-            if (!ue(t[s], e[s], r - 1)) return !1;
+function ut(e, t, r) {
+    if (e === t) return !0;
+    if (!r || !e || !t) return !1;
+    if (Array.isArray(e)) {
+        if (!Array.isArray(t) || e.length !== t.length) return !1;
+        for (let s = 0; s < e.length; s++)
+            if (!ut(e[s], t[s], r - 1)) return !1;
         return !0
     }
-    if (Array.isArray(e)) return !1;
-    if (typeof t == "object" && typeof e == "object") {
-        let s = Object.keys(t),
-            i = Object.keys(e);
+    if (Array.isArray(t)) return !1;
+    if (typeof e == "object" && typeof t == "object") {
+        let s = Object.keys(e),
+            i = Object.keys(t);
         if (s.length !== i.length) return !1;
         for (let n of s)
-            if (!e.hasOwnProperty(n) || !ue(t[n], e[n], r - 1)) return !1;
+            if (!t.hasOwnProperty(n) || !ut(e[n], t[n], r - 1)) return !1;
         return !0
     }
     return !1
 }
-var Di = class {
-    constructor(e) {
-        this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
-            onViewStateChange: e.onViewStateChange,
-            onInteractionStateChange: e.onInteractionStateChange
-        }, Object.seal(this), this.setProps(e)
+var ki = class {
+    constructor(t) {
+        this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = t.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = t.eventManager, this._eventCallbacks = {
+            onViewStateChange: t.onViewStateChange,
+            onInteractionStateChange: t.onInteractionStateChange
+        }, Object.seal(this), this.setProps(t)
     }
     finalize() {
-        for (let e in this.controllers) {
-            let r = this.controllers[e];
+        for (let t in this.controllers) {
+            let r = this.controllers[t];
             r && r.finalize()
         }
         this.controllers = {}
     }
-    needsRedraw(e = {
+    needsRedraw(t = {
         clearRedrawFlags: !1
     }) {
         let r = this._needsRedraw;
-        return e.clearRedrawFlags && (this._needsRedraw = !1), r
+        return t.clearRedrawFlags && (this._needsRedraw = !1), r
     }
-    setNeedsUpdate(e) {
-        this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e
+    setNeedsUpdate(t) {
+        this._needsUpdate = this._needsUpdate || t, this._needsRedraw = this._needsRedraw || t
     }
     updateViewStates() {
-        for (let e in this.controllers) {
-            let r = this.controllers[e];
+        for (let t in this.controllers) {
+            let r = this.controllers[t];
             r && r.updateTransition()
         }
     }
-    getViewports(e) {
-        return e ? this._viewports.filter(r => r.containsPixel(e)) : this._viewports
+    getViewports(t) {
+        return t ? this._viewports.filter(r => r.containsPixel(t)) : this._viewports
     }
     getViews() {
-        let e = {};
+        let t = {};
         return this.views.forEach(r => {
-            e[r.id] = r
-        }), e
+            t[r.id] = r
+        }), t
     }
-    getView(e) {
-        return this.views.find(r => r.id === e)
+    getView(t) {
+        return this.views.find(r => r.id === t)
     }
-    getViewState(e) {
-        let r = typeof e == "string" ? this.getView(e) : e,
+    getViewState(t) {
+        let r = typeof t == "string" ? this.getView(t) : t,
             s = r && this.viewState[r.getViewStateId()] || this.viewState;
         return r ? r.filterViewState(s) : s
     }
-    getViewport(e) {
-        return this._viewportMap[e]
+    getViewport(t) {
+        return this._viewportMap[t]
     }
-    unproject(e, r) {
+    unproject(t, r) {
         let s = this.getViewports(),
             i = {
-                x: e[0],
-                y: e[1]
+                x: t[0],
+                y: t[1]
             };
         for (let n = s.length - 1; n >= 0; --n) {
             let o = s[n];
             if (o.containsPixel(i)) {
-                let a = e.slice();
+                let a = t.slice();
                 return a[0] -= o.x, a[1] -= o.y, o.unproject(a, r)
             }
         }
         return null
     }
-    setProps(e) {
-        e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update()
+    setProps(t) {
+        t.views && this._setViews(t.views), t.viewState && this._setViewState(t.viewState), ("width" in t || "height" in t) && this._setSize(t.width, t.height), this._isUpdating || this._update()
     }
     _update() {
         this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1
     }
-    _setSize(e, r) {
-        (e !== this.width || r !== this.height) && (this.width = e, this.height = r, this.setNeedsUpdate("Size changed"))
+    _setSize(t, r) {
+        (t !== this.width || r !== this.height) && (this.width = t, this.height = r, this.setNeedsUpdate("Size changed"))
     }
-    _setViews(e) {
-        e = Qo(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e
+    _setViews(t) {
+        t = Qo(t, Boolean), this._diffViews(t, this.views) && this.setNeedsUpdate("views changed"), this.views = t
     }
-    _setViewState(e) {
-        e ? (!ue(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : W.warn("missing `viewState` or `initialViewState`")()
+    _setViewState(t) {
+        t ? (!ut(t, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = t) : W.warn("missing `viewState` or `initialViewState`")()
     }
-    _onViewStateChange(e, r) {
+    _onViewStateChange(t, r) {
         this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange({
             ...r,
-            viewId: e
+            viewId: t
         })
     }
-    _createController(e, r) {
+    _createController(t, r) {
         let s = r.type;
         return new s({
             timeline: this.timeline,
             eventManager: this._eventManager,
             onViewStateChange: this._onViewStateChange.bind(this, r.id),
             onStateChange: this._eventCallbacks.onInteractionStateChange,
-            makeViewport: n => this.getView(e.id)?.makeViewport({
+            makeViewport: n => this.getView(t.id)?.makeViewport({
                 viewState: n,
                 width: this.width,
                 height: this.height
             })
         })
     }
-    _updateController(e, r, s, i) {
-        let n = e.controller;
+    _updateController(t, r, s, i) {
+        let n = t.controller;
         if (n && s) {
             let o = {
                 ...r,
                 ...n,
-                id: e.id,
+                id: t.id,
                 x: s.x,
                 y: s.y,
                 width: s.width,
                 height: s.height
             };
-            return (!i || i.constructor !== n.type) && (i = this._createController(e, o)), i && i.setProps(o), i
+            return (!i || i.constructor !== n.type) && (i = this._createController(t, o)), i && i.setProps(o), i
         }
         return null
     }
     _rebuildViewports() {
         let {
-            views: e
+            views: t
         } = this, r = this.controllers;
         this._viewports = [], this.controllers = {};
         let s = !1;
-        for (let i = e.length; i--;) {
-            let n = e[i],
+        for (let i = t.length; i--;) {
+            let n = t[i],
                 o = this.getViewState(n),
                 a = n.makeViewport({
                     viewState: o,
                     width: this.width,
                     height: this.height
                 }),
                 c = r[n.id],
@@ -13513,546 +13513,546 @@
         for (let i in r) {
             let n = r[i];
             n && !this.controllers[i] && n.finalize()
         }
         this._buildViewportMap()
     }
     _buildViewportMap() {
-        this._viewportMap = {}, this._viewports.forEach(e => {
-            e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e)
+        this._viewportMap = {}, this._viewports.forEach(t => {
+            t.id && (this._viewportMap[t.id] = this._viewportMap[t.id] || t)
         })
     }
-    _diffViews(e, r) {
-        return e.length !== r.length ? !0 : e.some((s, i) => !e[i].equals(r[i]))
+    _diffViews(t, r) {
+        return t.length !== r.length ? !0 : t.some((s, i) => !t[i].equals(r[i]))
     }
 };
-var dA = /([0-9]+\.?[0-9]*)(%|px)/;
+var _A = /([0-9]+\.?[0-9]*)(%|px)/;
 
-function Ct(t) {
-    switch (typeof t) {
+function Ce(e) {
+    switch (typeof e) {
         case "number":
             return {
-                position: t, relative: !1
+                position: e, relative: !1
             };
         case "string":
-            let e = dA.exec(t);
-            if (e && e.length >= 3) {
-                let r = e[2] === "%",
-                    s = parseFloat(e[1]);
+            let t = _A.exec(e);
+            if (t && t.length >= 3) {
+                let r = t[2] === "%",
+                    s = parseFloat(t[1]);
                 return {
                     position: r ? s / 100 : s,
                     relative: r
                 }
             }
         default:
-            throw new Error(`Could not parse position string ${t}`)
+            throw new Error(`Could not parse position string ${e}`)
     }
 }
 
-function It(t, e) {
-    return t.relative ? Math.round(t.position * e) : t.position
+function Ie(e, t) {
+    return e.relative ? Math.round(e.position * t) : e.position
 }
-var gs = class {
-    constructor(e = {}) {
+var _s = class {
+    constructor(t = {}) {
         let {
             id: r,
             x: s = 0,
             y: i = 0,
             width: n = "100%",
             height: o = "100%",
             padding: a = null
-        } = e;
+        } = t;
         this.id = r || this.constructor.displayName || "view", this.props = {
-            ...e,
+            ...t,
             id: this.id
-        }, this._x = Ct(s), this._y = Ct(i), this._width = Ct(n), this._height = Ct(o), this._padding = a && {
-            left: Ct(a.left || 0),
-            right: Ct(a.right || 0),
-            top: Ct(a.top || 0),
-            bottom: Ct(a.bottom || 0)
+        }, this._x = Ce(s), this._y = Ce(i), this._width = Ce(n), this._height = Ce(o), this._padding = a && {
+            left: Ce(a.left || 0),
+            right: Ce(a.right || 0),
+            top: Ce(a.top || 0),
+            bottom: Ce(a.bottom || 0)
         }, this.equals = this.equals.bind(this), Object.seal(this)
     }
-    equals(e) {
-        return this === e ? !0 : this.ViewportType === e.ViewportType && ue(this.props, e.props, 2)
+    equals(t) {
+        return this === t ? !0 : this.ViewportType === t.ViewportType && ut(this.props, t.props, 2)
     }
     makeViewport({
-        width: e,
+        width: t,
         height: r,
         viewState: s
     }) {
         s = this.filterViewState(s);
         let i = this.getDimensions({
-            width: e,
+            width: t,
             height: r
         });
         return !i.height || !i.width ? null : new this.ViewportType({
             ...s,
             ...this.props,
             ...i
         })
     }
     getViewStateId() {
         let {
-            viewState: e
+            viewState: t
         } = this.props;
-        return typeof e == "string" ? e : e?.id || this.id
+        return typeof t == "string" ? t : t?.id || this.id
     }
-    filterViewState(e) {
+    filterViewState(t) {
         if (this.props.viewState && typeof this.props.viewState == "object") {
             if (!this.props.viewState.id) return this.props.viewState;
             let r = {
-                ...e
+                ...t
             };
             for (let s in this.props.viewState) s !== "id" && (r[s] = this.props.viewState[s]);
             return r
         }
-        return e
+        return t
     }
     getDimensions({
-        width: e,
+        width: t,
         height: r
     }) {
         let s = {
-            x: It(this._x, e),
-            y: It(this._y, r),
-            width: It(this._width, e),
-            height: It(this._height, r)
+            x: Ie(this._x, t),
+            y: Ie(this._y, r),
+            width: Ie(this._width, t),
+            height: Ie(this._height, r)
         };
         return this._padding && (s.padding = {
-            left: It(this._padding.left, e),
-            top: It(this._padding.top, r),
-            right: It(this._padding.right, e),
-            bottom: It(this._padding.bottom, r)
+            left: Ie(this._padding.left, t),
+            top: Ie(this._padding.top, r),
+            right: Ie(this._padding.right, t),
+            bottom: Ie(this._padding.bottom, r)
         }), s
     }
     get controller() {
-        let e = this.props.controller;
-        return e ? e === !0 ? {
+        let t = this.props.controller;
+        return t ? t === !0 ? {
             type: this.ControllerType
-        } : typeof e == "function" ? {
-            type: e
+        } : typeof t == "function" ? {
+            type: t
         } : {
             type: this.ControllerType,
-            ...e
+            ...t
         } : null
     }
 };
-var qe = class {
-    constructor(e) {
+var qt = class {
+    constructor(t) {
         this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
             duration: 0
-        }, this._timeline = e
+        }, this._timeline = t
     }
     get inProgress() {
         return this._inProgress
     }
-    start(e) {
-        this.cancel(), this.settings = e, this._inProgress = !0, this.settings.onStart?.(this)
+    start(t) {
+        this.cancel(), this.settings = t, this._inProgress = !0, this.settings.onStart?.(this)
     }
     end() {
         this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this))
     }
     cancel() {
         this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1)
     }
     update() {
         if (!this._inProgress) return !1;
         if (this._handle === null) {
             let {
-                _timeline: e,
+                _timeline: t,
                 settings: r
             } = this;
-            this._handle = e.addChannel({
-                delay: e.getTime(),
+            this._handle = t.addChannel({
+                delay: t.getTime(),
                 duration: r.duration
             })
         }
         return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0
     }
     _onUpdate() {}
 };
 var xp = () => {},
     Jo = {
         BREAK: 1,
         SNAP_TO_END: 2,
         IGNORE: 3
     },
-    pA = t => t,
-    gA = Jo.BREAK,
-    ki = class {
-        constructor(e) {
+    gA = e => e,
+    mA = Jo.BREAK,
+    Di = class {
+        constructor(t) {
             this._onTransitionUpdate = r => {
                 let {
                     time: s,
                     settings: {
                         interpolator: i,
                         startProps: n,
                         endProps: o,
                         duration: a,
                         easing: c
                     }
-                } = r, l = c(s / a), h = i.interpolateProps(n, o, l);
+                } = r, l = c(s / a), f = i.interpolateProps(n, o, l);
                 this.propsInTransition = this.getControllerState({
                     ...this.props,
-                    ...h
+                    ...f
                 }).getViewportProps(), this.onViewStateChange({
                     viewState: this.propsInTransition,
                     oldViewState: this.props
                 })
-            }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new qe(e.timeline), this.onViewStateChange = e.onViewStateChange || xp, this.onStateChange = e.onStateChange || xp
+            }, this.getControllerState = t.getControllerState, this.propsInTransition = null, this.transition = new qt(t.timeline), this.onViewStateChange = t.onViewStateChange || xp, this.onStateChange = t.onStateChange || xp
         }
         finalize() {
             this.transition.cancel()
         }
         getViewportInTransition() {
             return this.propsInTransition
         }
-        processViewStateChange(e) {
+        processViewStateChange(t) {
             let r = !1,
                 s = this.props;
-            if (this.props = e, !s || this._shouldIgnoreViewportChange(s, e)) return !1;
-            if (this._isTransitionEnabled(e)) {
+            if (this.props = t, !s || this._shouldIgnoreViewportChange(s, t)) return !1;
+            if (this._isTransitionEnabled(t)) {
                 let i = s;
                 if (this.transition.inProgress) {
                     let {
                         interruption: n,
                         endProps: o
                     } = this.transition.settings;
                     i = {
                         ...s,
                         ...n === Jo.SNAP_TO_END ? o : this.propsInTransition || s
                     }
                 }
-                this._triggerTransition(i, e), r = !0
+                this._triggerTransition(i, t), r = !0
             } else this.transition.cancel();
             return r
         }
         updateTransition() {
             this.transition.update()
         }
-        _isTransitionEnabled(e) {
+        _isTransitionEnabled(t) {
             let {
                 transitionDuration: r,
                 transitionInterpolator: s
-            } = e;
+            } = t;
             return (r > 0 || r === "auto") && !!s
         }
-        _isUpdateDueToCurrentTransition(e) {
-            return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1
+        _isUpdateDueToCurrentTransition(t) {
+            return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(t, this.propsInTransition) : !1
         }
-        _shouldIgnoreViewportChange(e, r) {
-            return this.transition.inProgress ? this.transition.settings.interruption === Jo.IGNORE || this._isUpdateDueToCurrentTransition(r) : this._isTransitionEnabled(r) ? r.transitionInterpolator.arePropsEqual(e, r) : !0
+        _shouldIgnoreViewportChange(t, r) {
+            return this.transition.inProgress ? this.transition.settings.interruption === Jo.IGNORE || this._isUpdateDueToCurrentTransition(r) : this._isTransitionEnabled(r) ? r.transitionInterpolator.arePropsEqual(t, r) : !0
         }
-        _triggerTransition(e, r) {
-            let s = this.getControllerState(e),
+        _triggerTransition(t, r) {
+            let s = this.getControllerState(t),
                 i = this.getControllerState(r).shortestPathFrom(s),
                 n = r.transitionInterpolator,
-                o = n.getDuration ? n.getDuration(e, r) : r.transitionDuration;
+                o = n.getDuration ? n.getDuration(t, r) : r.transitionDuration;
             if (o === 0) return;
-            let a = n.initializeProps(e, i);
+            let a = n.initializeProps(t, i);
             this.propsInTransition = {};
             let c = {
                 duration: o,
-                easing: r.transitionEasing || pA,
+                easing: r.transitionEasing || gA,
                 interpolator: n,
-                interruption: r.transitionInterruption || gA,
+                interruption: r.transitionInterruption || mA,
                 startProps: a.start,
                 endProps: a.end,
                 onStart: r.onTransitionStart,
                 onUpdate: this._onTransitionUpdate,
                 onInterrupt: this._onTransitionEnd(r.onTransitionInterrupt),
                 onEnd: this._onTransitionEnd(r.onTransitionEnd)
             };
             this.transition.start(c), this.onStateChange({
                 inTransition: !0
             }), this.updateTransition()
         }
-        _onTransitionEnd(e) {
+        _onTransitionEnd(t) {
             return r => {
                 this.propsInTransition = null, this.onStateChange({
                     inTransition: !1,
                     isZooming: !1,
                     isPanning: !1,
                     isRotating: !1
-                }), e?.(r)
+                }), t?.(r)
             }
         }
     };
 
-function J(t, e) {
-    if (!t) throw new Error(e || "deck.gl: assertion failed.")
+function J(e, t) {
+    if (!e) throw new Error(t || "deck.gl: assertion failed.")
 }
-var _s = class {
-    constructor(e) {
+var gs = class {
+    constructor(t) {
         let {
             compare: r,
             extract: s,
             required: i
-        } = e;
+        } = t;
         this._propsToCompare = r, this._propsToExtract = s || r, this._requiredProps = i
     }
-    arePropsEqual(e, r) {
+    arePropsEqual(t, r) {
         for (let s of this._propsToCompare)
-            if (!(s in e) || !(s in r) || !wt(e[s], r[s])) return !1;
+            if (!(s in t) || !(s in r) || !Se(t[s], r[s])) return !1;
         return !0
     }
-    initializeProps(e, r) {
+    initializeProps(t, r) {
         let s = {},
             i = {};
-        for (let n of this._propsToExtract)(n in e || n in r) && (s[n] = e[n], i[n] = r[n]);
+        for (let n of this._propsToExtract)(n in t || n in r) && (s[n] = t[n], i[n] = r[n]);
         return this._checkRequiredProps(s), this._checkRequiredProps(i), {
             start: s,
             end: i
         }
     }
-    getDuration(e, r) {
+    getDuration(t, r) {
         return r.transitionDuration
     }
-    _checkRequiredProps(e) {
+    _checkRequiredProps(t) {
         this._requiredProps && this._requiredProps.forEach(r => {
-            let s = e[r];
+            let s = t[r];
             J(Number.isFinite(s) || Array.isArray(s), `${r} is required for transition`)
         })
     }
 };
-var _A = ["longitude", "latitude", "zoom", "bearing", "pitch"],
-    mA = ["longitude", "latitude", "zoom"],
-    Gt = class extends _s {
-        constructor(e = {}) {
-            let r = Array.isArray(e) ? e : e.transitionProps,
-                s = Array.isArray(e) ? {} : e;
+var bA = ["longitude", "latitude", "zoom", "bearing", "pitch"],
+    yA = ["longitude", "latitude", "zoom"],
+    Ge = class extends gs {
+        constructor(t = {}) {
+            let r = Array.isArray(t) ? t : t.transitionProps,
+                s = Array.isArray(t) ? {} : t;
             s.transitionProps = Array.isArray(r) ? {
                 compare: r,
                 required: r
             } : r || {
-                compare: _A,
-                required: mA
+                compare: bA,
+                required: yA
             }, super(s.transitionProps), this.opts = s
         }
-        initializeProps(e, r) {
-            let s = super.initializeProps(e, r),
+        initializeProps(t, r) {
+            let s = super.initializeProps(t, r),
                 {
                     makeViewport: i,
                     around: n
                 } = this.opts;
             if (i && n) {
-                let o = i(e),
+                let o = i(t),
                     a = i(r),
                     c = o.unproject(n);
                 s.start.around = n, Object.assign(s.end, {
                     around: a.project(c),
                     aroundPosition: c,
                     width: r.width,
                     height: r.height
                 })
             }
             return s
         }
-        interpolateProps(e, r, s) {
+        interpolateProps(t, r, s) {
             let i = {};
-            for (let n of this._propsToExtract) i[n] = vr(e[n] || 0, r[n] || 0, s);
+            for (let n of this._propsToExtract) i[n] = vr(t[n] || 0, r[n] || 0, s);
             if (r.aroundPosition && this.opts.makeViewport) {
                 let n = this.opts.makeViewport({
                     ...r,
                     ...i
                 });
-                Object.assign(i, n.panByPosition(r.aroundPosition, vr(e.around, r.around, s)))
+                Object.assign(i, n.panByPosition(r.aroundPosition, vr(t.around, r.around, s)))
             }
             return i
         }
     };
-var er = {
+var tr = {
         transitionDuration: 0
     },
     TA = 300,
-    Go = t => 1 - (1 - t) * (1 - t),
+    Go = e => 1 - (1 - e) * (1 - e),
     ms = {
         WHEEL: ["wheel"],
         PAN: ["panstart", "panmove", "panend"],
         PINCH: ["pinchstart", "pinchmove", "pinchend"],
         TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
         DOUBLE_TAP: ["doubletap"],
         KEYBOARD: ["keydown"]
     },
     Nr = {},
-    Ts = class {
-        constructor(e) {
+    bs = class {
+        constructor(t) {
             this.state = {}, this._events = {}, this._interactionState = {
                 isDragging: !1
-            }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new ki({
-                ...e,
+            }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new Di({
+                ...t,
                 getControllerState: r => new this.ControllerState(r),
                 onViewStateChange: this._onTransition.bind(this),
                 onStateChange: this._setInteractionState.bind(this)
-            }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {}), this.onStateChange = e.onStateChange || (() => {}), this.makeViewport = e.makeViewport
+            }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = t.eventManager, this.onViewStateChange = t.onViewStateChange || (() => {}), this.onStateChange = t.onStateChange || (() => {}), this.makeViewport = t.makeViewport
         }
-        set events(e) {
-            this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props)
+        set events(t) {
+            this.toggleEvents(this._customEvents, !1), this.toggleEvents(t, !0), this._customEvents = t, this.props && this.setProps(this.props)
         }
         finalize() {
-            for (let e in this._events) this._events[e] && this.eventManager?.off(e, this.handleEvent);
+            for (let t in this._events) this._events[t] && this.eventManager?.off(t, this.handleEvent);
             this.transitionManager.finalize()
         }
-        handleEvent(e) {
+        handleEvent(t) {
             this._controllerState = void 0;
             let r = this._eventStartBlocked;
-            switch (e.type) {
+            switch (t.type) {
                 case "panstart":
-                    return r ? !1 : this._onPanStart(e);
+                    return r ? !1 : this._onPanStart(t);
                 case "panmove":
-                    return this._onPan(e);
+                    return this._onPan(t);
                 case "panend":
-                    return this._onPanEnd(e);
+                    return this._onPanEnd(t);
                 case "pinchstart":
-                    return r ? !1 : this._onPinchStart(e);
+                    return r ? !1 : this._onPinchStart(t);
                 case "pinchmove":
-                    return this._onPinch(e);
+                    return this._onPinch(t);
                 case "pinchend":
-                    return this._onPinchEnd(e);
+                    return this._onPinchEnd(t);
                 case "tripanstart":
-                    return r ? !1 : this._onTriplePanStart(e);
+                    return r ? !1 : this._onTriplePanStart(t);
                 case "tripanmove":
-                    return this._onTriplePan(e);
+                    return this._onTriplePan(t);
                 case "tripanend":
-                    return this._onTriplePanEnd(e);
+                    return this._onTriplePanEnd(t);
                 case "doubletap":
-                    return this._onDoubleTap(e);
+                    return this._onDoubleTap(t);
                 case "wheel":
-                    return this._onWheel(e);
+                    return this._onWheel(t);
                 case "keydown":
-                    return this._onKeyDown(e);
+                    return this._onKeyDown(t);
                 default:
                     return !1
             }
         }
         get controllerState() {
             return this._controllerState = this._controllerState || new this.ControllerState({
                 makeViewport: this.makeViewport,
                 ...this.props,
                 ...this.state
             }), this._controllerState
         }
-        getCenter(e) {
+        getCenter(t) {
             let {
                 x: r,
                 y: s
             } = this.props, {
                 offsetCenter: i
-            } = e;
+            } = t;
             return [i.x - r, i.y - s]
         }
-        isPointInBounds(e, r) {
+        isPointInBounds(t, r) {
             let {
                 width: s,
                 height: i
             } = this.props;
             if (r && r.handled) return !1;
-            let n = e[0] >= 0 && e[0] <= s && e[1] >= 0 && e[1] <= i;
+            let n = t[0] >= 0 && t[0] <= s && t[1] >= 0 && t[1] <= i;
             return n && r && r.stopPropagation(), n
         }
-        isFunctionKeyPressed(e) {
+        isFunctionKeyPressed(t) {
             let {
                 srcEvent: r
-            } = e;
+            } = t;
             return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey)
         }
         isDragging() {
             return this._interactionState.isDragging || !1
         }
-        blockEvents(e) {
+        blockEvents(t) {
             let r = setTimeout(() => {
                 this._eventStartBlocked === r && (this._eventStartBlocked = null)
-            }, e);
+            }, t);
             this._eventStartBlocked = r
         }
-        setProps(e) {
-            e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
+        setProps(t) {
+            t.dragMode && (this.dragMode = t.dragMode), this.props = t, "transitionInterpolator" in t || (t.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(t);
             let {
                 inertia: r
-            } = e;
+            } = t;
             this.inertia = Number.isFinite(r) ? r : r === !0 ? TA : 0;
             let {
                 scrollZoom: s = !0,
                 dragPan: i = !0,
                 dragRotate: n = !0,
                 doubleClickZoom: o = !0,
                 touchZoom: a = !0,
                 touchRotate: c = !1,
                 keyboard: l = !0
-            } = e, h = !!this.onViewStateChange;
-            this.toggleEvents(ms.WHEEL, h && s), this.toggleEvents(ms.PAN, h), this.toggleEvents(ms.PINCH, h && (a || c)), this.toggleEvents(ms.TRIPLE_PAN, h && c), this.toggleEvents(ms.DOUBLE_TAP, h && o), this.toggleEvents(ms.KEYBOARD, h && l), this.scrollZoom = s, this.dragPan = i, this.dragRotate = n, this.doubleClickZoom = o, this.touchZoom = a, this.touchRotate = c, this.keyboard = l
+            } = t, f = !!this.onViewStateChange;
+            this.toggleEvents(ms.WHEEL, f && s), this.toggleEvents(ms.PAN, f), this.toggleEvents(ms.PINCH, f && (a || c)), this.toggleEvents(ms.TRIPLE_PAN, f && c), this.toggleEvents(ms.DOUBLE_TAP, f && o), this.toggleEvents(ms.KEYBOARD, f && l), this.scrollZoom = s, this.dragPan = i, this.dragRotate = n, this.doubleClickZoom = o, this.touchZoom = a, this.touchRotate = c, this.keyboard = l
         }
         updateTransition() {
             this.transitionManager.updateTransition()
         }
-        toggleEvents(e, r) {
-            this.eventManager && e.forEach(s => {
+        toggleEvents(t, r) {
+            this.eventManager && t.forEach(s => {
                 this._events[s] !== r && (this._events[s] = r, r ? this.eventManager.on(s, this.handleEvent) : this.eventManager.off(s, this.handleEvent))
             })
         }
-        updateViewport(e, r = null, s = {}) {
+        updateViewport(t, r = null, s = {}) {
             let i = {
-                    ...e.getViewportProps(),
+                    ...t.getViewportProps(),
                     ...r
                 },
-                n = this.controllerState !== e;
-            if (this.state = e.getState(), this._setInteractionState(s), n) {
+                n = this.controllerState !== t;
+            if (this.state = t.getState(), this._setInteractionState(s), n) {
                 let o = this.controllerState && this.controllerState.getViewportProps();
                 this.onViewStateChange && this.onViewStateChange({
                     viewState: i,
                     interactionState: this._interactionState,
                     oldViewState: o
                 })
             }
         }
-        _onTransition(e) {
+        _onTransition(t) {
             this.onViewStateChange({
-                ...e,
+                ...t,
                 interactionState: this._interactionState
             })
         }
-        _setInteractionState(e) {
-            Object.assign(this._interactionState, e), this.onStateChange(this._interactionState)
+        _setInteractionState(t) {
+            Object.assign(this._interactionState, t), this.onStateChange(this._interactionState)
         }
-        _onPanStart(e) {
-            let r = this.getCenter(e);
-            if (!this.isPointInBounds(r, e)) return !1;
-            let s = this.isFunctionKeyPressed(e) || e.rightButton || !1;
+        _onPanStart(t) {
+            let r = this.getCenter(t);
+            if (!this.isPointInBounds(r, t)) return !1;
+            let s = this.isFunctionKeyPressed(t) || t.rightButton || !1;
             (this.invertPan || this.dragMode === "pan") && (s = !s);
             let i = this.controllerState[s ? "panStart" : "rotateStart"]({
                 pos: r
             });
-            return this._panMove = s, this.updateViewport(i, er, {
+            return this._panMove = s, this.updateViewport(i, tr, {
                 isDragging: !0
             }), !0
         }
-        _onPan(e) {
-            return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1
+        _onPan(t) {
+            return this.isDragging() ? this._panMove ? this._onPanMove(t) : this._onPanRotate(t) : !1
         }
-        _onPanEnd(e) {
-            return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1
+        _onPanEnd(t) {
+            return this.isDragging() ? this._panMove ? this._onPanMoveEnd(t) : this._onPanRotateEnd(t) : !1
         }
-        _onPanMove(e) {
+        _onPanMove(t) {
             if (!this.dragPan) return !1;
-            let r = this.getCenter(e),
+            let r = this.getCenter(t),
                 s = this.controllerState.pan({
                     pos: r
                 });
-            return this.updateViewport(s, er, {
+            return this.updateViewport(s, tr, {
                 isDragging: !0,
                 isPanning: !0
             }), !0
         }
-        _onPanMoveEnd(e) {
+        _onPanMoveEnd(t) {
             let {
                 inertia: r
             } = this;
-            if (this.dragPan && r && e.velocity) {
-                let s = this.getCenter(e),
-                    i = [s[0] + e.velocityX * r / 2, s[1] + e.velocityY * r / 2],
+            if (this.dragPan && r && t.velocity) {
+                let s = this.getCenter(t),
+                    i = [s[0] + t.velocityX * r / 2, s[1] + t.velocityY * r / 2],
                     n = this.controllerState.pan({
                         pos: i
                     }).panEnd();
                 this.updateViewport(n, {
                     ...this._getTransitionProps(),
                     transitionDuration: r,
                     transitionEasing: Go
@@ -14065,32 +14065,32 @@
                 this.updateViewport(s, null, {
                     isDragging: !1,
                     isPanning: !1
                 })
             }
             return !0
         }
-        _onPanRotate(e) {
+        _onPanRotate(t) {
             if (!this.dragRotate) return !1;
-            let r = this.getCenter(e),
+            let r = this.getCenter(t),
                 s = this.controllerState.rotate({
                     pos: r
                 });
-            return this.updateViewport(s, er, {
+            return this.updateViewport(s, tr, {
                 isDragging: !0,
                 isRotating: !0
             }), !0
         }
-        _onPanRotateEnd(e) {
+        _onPanRotateEnd(t) {
             let {
                 inertia: r
             } = this;
-            if (this.dragRotate && r && e.velocity) {
-                let s = this.getCenter(e),
-                    i = [s[0] + e.velocityX * r / 2, s[1] + e.velocityY * r / 2],
+            if (this.dragRotate && r && t.velocity) {
+                let s = this.getCenter(t),
+                    i = [s[0] + t.velocityX * r / 2, s[1] + t.velocityY * r / 2],
                     n = this.controllerState.rotate({
                         pos: i
                     }).rotateEnd();
                 this.updateViewport(n, {
                     ...this._getTransitionProps(),
                     transitionDuration: r,
                     transitionEasing: Go
@@ -14103,25 +14103,25 @@
                 this.updateViewport(s, null, {
                     isDragging: !1,
                     isRotating: !1
                 })
             }
             return !0
         }
-        _onWheel(e) {
+        _onWheel(t) {
             if (!this.scrollZoom) return !1;
-            let r = this.getCenter(e);
-            if (!this.isPointInBounds(r, e)) return !1;
-            e.srcEvent.preventDefault();
+            let r = this.getCenter(t);
+            if (!this.isPointInBounds(r, t)) return !1;
+            t.srcEvent.preventDefault();
             let {
                 speed: s = .01,
                 smooth: i = !1
             } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
                 delta: n
-            } = e, o = 2 / (1 + Math.exp(-Math.abs(n * s)));
+            } = t, o = 2 / (1 + Math.exp(-Math.abs(n * s)));
             n < 0 && o !== 0 && (o = 1 / o);
             let a = this.controllerState.zoom({
                 pos: r,
                 scale: o
             });
             return this.updateViewport(a, {
                 ...this._getTransitionProps({
@@ -14129,44 +14129,44 @@
                 }),
                 transitionDuration: i ? 250 : 1
             }, {
                 isZooming: !0,
                 isPanning: !0
             }), !0
         }
-        _onTriplePanStart(e) {
-            let r = this.getCenter(e);
-            if (!this.isPointInBounds(r, e)) return !1;
+        _onTriplePanStart(t) {
+            let r = this.getCenter(t);
+            if (!this.isPointInBounds(r, t)) return !1;
             let s = this.controllerState.rotateStart({
                 pos: r
             });
-            return this.updateViewport(s, er, {
+            return this.updateViewport(s, tr, {
                 isDragging: !0
             }), !0
         }
-        _onTriplePan(e) {
+        _onTriplePan(t) {
             if (!this.touchRotate || !this.isDragging()) return !1;
-            let r = this.getCenter(e);
-            r[0] -= e.deltaX;
+            let r = this.getCenter(t);
+            r[0] -= t.deltaX;
             let s = this.controllerState.rotate({
                 pos: r
             });
-            return this.updateViewport(s, er, {
+            return this.updateViewport(s, tr, {
                 isDragging: !0,
                 isRotating: !0
             }), !0
         }
-        _onTriplePanEnd(e) {
+        _onTriplePanEnd(t) {
             if (!this.isDragging()) return !1;
             let {
                 inertia: r
             } = this;
-            if (this.touchRotate && r && e.velocityY) {
-                let s = this.getCenter(e),
-                    i = [s[0], s[1] += e.velocityY * r / 2],
+            if (this.touchRotate && r && t.velocityY) {
+                let s = this.getCenter(t),
+                    i = [s[0], s[1] += t.velocityY * r / 2],
                     n = this.controllerState.rotate({
                         pos: i
                     });
                 this.updateViewport(n, {
                     ...this._getTransitionProps(),
                     transitionDuration: r,
                     transitionEasing: Go
@@ -14179,65 +14179,65 @@
                 this.updateViewport(s, null, {
                     isDragging: !1,
                     isRotating: !1
                 })
             }
             return !0
         }
-        _onPinchStart(e) {
-            let r = this.getCenter(e);
-            if (!this.isPointInBounds(r, e)) return !1;
+        _onPinchStart(t) {
+            let r = this.getCenter(t);
+            if (!this.isPointInBounds(r, t)) return !1;
             let s = this.controllerState.zoomStart({
                 pos: r
             }).rotateStart({
                 pos: r
             });
-            return Nr._startPinchRotation = e.rotation, Nr._lastPinchEvent = e, this.updateViewport(s, er, {
+            return Nr._startPinchRotation = t.rotation, Nr._lastPinchEvent = t, this.updateViewport(s, tr, {
                 isDragging: !0
             }), !0
         }
-        _onPinch(e) {
+        _onPinch(t) {
             if (!this.touchZoom && !this.touchRotate || !this.isDragging()) return !1;
             let r = this.controllerState;
             if (this.touchZoom) {
                 let {
                     scale: s
-                } = e, i = this.getCenter(e);
+                } = t, i = this.getCenter(t);
                 r = r.zoom({
                     pos: i,
                     scale: s
                 })
             }
             if (this.touchRotate) {
                 let {
                     rotation: s
-                } = e;
+                } = t;
                 r = r.rotate({
                     deltaAngleX: Nr._startPinchRotation - s
                 })
             }
-            return this.updateViewport(r, er, {
+            return this.updateViewport(r, tr, {
                 isDragging: !0,
                 isPanning: this.touchZoom,
                 isZooming: this.touchZoom,
                 isRotating: this.touchRotate
-            }), Nr._lastPinchEvent = e, !0
+            }), Nr._lastPinchEvent = t, !0
         }
-        _onPinchEnd(e) {
+        _onPinchEnd(t) {
             if (!this.isDragging()) return !1;
             let {
                 inertia: r
             } = this, {
                 _lastPinchEvent: s
             } = Nr;
-            if (this.touchZoom && r && s && e.scale !== s.scale) {
-                let i = this.getCenter(e),
+            if (this.touchZoom && r && s && t.scale !== s.scale) {
+                let i = this.getCenter(t),
                     n = this.controllerState.rotateEnd(),
-                    o = Math.log2(e.scale),
-                    a = (o - Math.log2(s.scale)) / (e.deltaTime - s.deltaTime),
+                    o = Math.log2(t.scale),
+                    a = (o - Math.log2(s.scale)) / (t.deltaTime - s.deltaTime),
                     c = Math.pow(2, o + a * r / 2);
                 n = n.zoom({
                     pos: i,
                     scale: c
                 }).zoomEnd(), this.updateViewport(n, {
                     ...this._getTransitionProps({
                         around: i
@@ -14257,44 +14257,44 @@
                     isPanning: !1,
                     isZooming: !1,
                     isRotating: !1
                 })
             }
             return Nr._startPinchRotation = null, Nr._lastPinchEvent = null, !0
         }
-        _onDoubleTap(e) {
+        _onDoubleTap(t) {
             if (!this.doubleClickZoom) return !1;
-            let r = this.getCenter(e);
-            if (!this.isPointInBounds(r, e)) return !1;
-            let s = this.isFunctionKeyPressed(e),
+            let r = this.getCenter(t);
+            if (!this.isPointInBounds(r, t)) return !1;
+            let s = this.isFunctionKeyPressed(t),
                 i = this.controllerState.zoom({
                     pos: r,
                     scale: s ? .5 : 2
                 });
             return this.updateViewport(i, this._getTransitionProps({
                 around: r
             }), {
                 isZooming: !0,
                 isPanning: !0
             }), this.blockEvents(100), !0
         }
-        _onKeyDown(e) {
+        _onKeyDown(t) {
             if (!this.keyboard) return !1;
-            let r = this.isFunctionKeyPressed(e),
+            let r = this.isFunctionKeyPressed(t),
                 {
                     zoomSpeed: s,
                     moveSpeed: i,
                     rotateSpeedX: n,
                     rotateSpeedY: o
                 } = this.keyboard === !0 ? {} : this.keyboard,
                 {
                     controllerState: a
                 } = this,
                 c, l = {};
-            switch (e.srcEvent.code) {
+            switch (t.srcEvent.code) {
                 case "Minus":
                     c = r ? a.zoomOut(s).zoomOut(s) : a.zoomOut(s), l.isZooming = !0;
                     break;
                 case "Equal":
                     c = r ? a.zoomIn(s).zoomIn(s) : a.zoomIn(s), l.isZooming = !0;
                     break;
                 case "ArrowLeft":
@@ -14310,548 +14310,548 @@
                     r ? (c = a.rotateDown(o), l.isRotating = !0) : (c = a.moveDown(i), l.isPanning = !0);
                     break;
                 default:
                     return !1
             }
             return this.updateViewport(c, this._getTransitionProps(), l), !0
         }
-        _getTransitionProps(e) {
+        _getTransitionProps(t) {
             let {
                 transition: r
             } = this;
-            return !r || !r.transitionInterpolator ? er : e ? {
+            return !r || !r.transitionInterpolator ? tr : t ? {
                 ...r,
-                transitionInterpolator: new Gt({
-                    ...e,
+                transitionInterpolator: new Ge({
+                    ...t,
                     ...r.transitionInterpolator.opts,
                     makeViewport: this.controllerState.makeViewport
                 })
             } : r
         }
     };
 var Bi = class {
-    constructor(e, r) {
-        this._viewportProps = this.applyConstraints(e), this._state = r
+    constructor(t, r) {
+        this._viewportProps = this.applyConstraints(t), this._state = r
     }
     getViewportProps() {
         return this._viewportProps
     }
     getState() {
         return this._state
     }
 };
 var Sp = 5,
-    yA = 1.2,
-    Eh = class extends Bi {
-        constructor(e) {
+    wA = 1.2,
+    Af = class extends Bi {
+        constructor(t) {
             let {
                 width: r,
                 height: s,
                 latitude: i,
                 longitude: n,
                 zoom: o,
                 bearing: a = 0,
                 pitch: c = 0,
                 altitude: l = 1.5,
-                position: h = [0, 0, 0],
+                position: f = [0, 0, 0],
                 maxZoom: d = 20,
                 minZoom: p = 0,
                 maxPitch: m = 60,
                 minPitch: y = 0,
-                startPanLngLat: x,
-                startZoomLngLat: b,
-                startRotatePos: w,
+                startPanLngLat: E,
+                startZoomLngLat: T,
+                startRotatePos: S,
                 startBearing: R,
                 startPitch: v,
                 startZoom: C,
                 normalize: O = !0
-            } = e;
+            } = t;
             J(Number.isFinite(n)), J(Number.isFinite(i)), J(Number.isFinite(o)), super({
                 width: r,
                 height: s,
                 latitude: i,
                 longitude: n,
                 zoom: o,
                 bearing: a,
                 pitch: c,
                 altitude: l,
                 maxZoom: d,
                 minZoom: p,
                 maxPitch: m,
                 minPitch: y,
                 normalize: O,
-                position: h
+                position: f
             }, {
-                startPanLngLat: x,
-                startZoomLngLat: b,
-                startRotatePos: w,
+                startPanLngLat: E,
+                startZoomLngLat: T,
+                startRotatePos: S,
                 startBearing: R,
                 startPitch: v,
                 startZoom: C
-            }), this.makeViewport = e.makeViewport
+            }), this.makeViewport = t.makeViewport
         }
         panStart({
-            pos: e
+            pos: t
         }) {
             return this._getUpdatedState({
-                startPanLngLat: this._unproject(e)
+                startPanLngLat: this._unproject(t)
             })
         }
         pan({
-            pos: e,
+            pos: t,
             startPos: r
         }) {
             let s = this.getState().startPanLngLat || this._unproject(r);
             if (!s) return this;
-            let n = this.makeViewport(this.getViewportProps()).panByPosition(s, e);
+            let n = this.makeViewport(this.getViewportProps()).panByPosition(s, t);
             return this._getUpdatedState(n)
         }
         panEnd() {
             return this._getUpdatedState({
                 startPanLngLat: null
             })
         }
         rotateStart({
-            pos: e
+            pos: t
         }) {
             return this._getUpdatedState({
-                startRotatePos: e,
+                startRotatePos: t,
                 startBearing: this.getViewportProps().bearing,
                 startPitch: this.getViewportProps().pitch
             })
         }
         rotate({
-            pos: e,
+            pos: t,
             deltaAngleX: r = 0,
             deltaAngleY: s = 0
         }) {
             let {
                 startRotatePos: i,
                 startBearing: n,
                 startPitch: o
             } = this.getState();
             if (!i || n === void 0 || o === void 0) return this;
             let a;
-            return e ? a = this._getNewRotation(e, i, o, n) : a = {
+            return t ? a = this._getNewRotation(t, i, o, n) : a = {
                 bearing: n + r,
                 pitch: o + s
             }, this._getUpdatedState(a)
         }
         rotateEnd() {
             return this._getUpdatedState({
                 startBearing: null,
                 startPitch: null
             })
         }
         zoomStart({
-            pos: e
+            pos: t
         }) {
             return this._getUpdatedState({
-                startZoomLngLat: this._unproject(e),
+                startZoomLngLat: this._unproject(t),
                 startZoom: this.getViewportProps().zoom
             })
         }
         zoom({
-            pos: e,
+            pos: t,
             startPos: r,
             scale: s
         }) {
             let {
                 startZoom: i,
                 startZoomLngLat: n
             } = this.getState();
-            if (n || (i = this.getViewportProps().zoom, n = this._unproject(r) || this._unproject(e)), !n) return this;
+            if (n || (i = this.getViewportProps().zoom, n = this._unproject(r) || this._unproject(t)), !n) return this;
             let {
                 maxZoom: o,
                 minZoom: a
             } = this.getViewportProps(), c = i + Math.log2(s);
-            c = Le(c, a, o);
+            c = Lt(c, a, o);
             let l = this.makeViewport({
                 ...this.getViewportProps(),
                 zoom: c
             });
             return this._getUpdatedState({
                 zoom: c,
-                ...l.panByPosition(n, e)
+                ...l.panByPosition(n, t)
             })
         }
         zoomEnd() {
             return this._getUpdatedState({
                 startZoomLngLat: null,
                 startZoom: null
             })
         }
-        zoomIn(e = 2) {
-            return this._zoomFromCenter(e)
+        zoomIn(t = 2) {
+            return this._zoomFromCenter(t)
         }
-        zoomOut(e = 2) {
-            return this._zoomFromCenter(1 / e)
+        zoomOut(t = 2) {
+            return this._zoomFromCenter(1 / t)
         }
-        moveLeft(e = 100) {
-            return this._panFromCenter([e, 0])
+        moveLeft(t = 100) {
+            return this._panFromCenter([t, 0])
         }
-        moveRight(e = 100) {
-            return this._panFromCenter([-e, 0])
+        moveRight(t = 100) {
+            return this._panFromCenter([-t, 0])
         }
-        moveUp(e = 100) {
-            return this._panFromCenter([0, e])
+        moveUp(t = 100) {
+            return this._panFromCenter([0, t])
         }
-        moveDown(e = 100) {
-            return this._panFromCenter([0, -e])
+        moveDown(t = 100) {
+            return this._panFromCenter([0, -t])
         }
-        rotateLeft(e = 15) {
+        rotateLeft(t = 15) {
             return this._getUpdatedState({
-                bearing: this.getViewportProps().bearing - e
+                bearing: this.getViewportProps().bearing - t
             })
         }
-        rotateRight(e = 15) {
+        rotateRight(t = 15) {
             return this._getUpdatedState({
-                bearing: this.getViewportProps().bearing + e
+                bearing: this.getViewportProps().bearing + t
             })
         }
-        rotateUp(e = 10) {
+        rotateUp(t = 10) {
             return this._getUpdatedState({
-                pitch: this.getViewportProps().pitch + e
+                pitch: this.getViewportProps().pitch + t
             })
         }
-        rotateDown(e = 10) {
+        rotateDown(t = 10) {
             return this._getUpdatedState({
-                pitch: this.getViewportProps().pitch - e
+                pitch: this.getViewportProps().pitch - t
             })
         }
-        shortestPathFrom(e) {
-            let r = e.getViewportProps(),
+        shortestPathFrom(t) {
+            let r = t.getViewportProps(),
                 s = {
                     ...this.getViewportProps()
                 },
                 {
                     bearing: i,
                     longitude: n
                 } = s;
             return Math.abs(i - r.bearing) > 180 && (s.bearing = i < 0 ? i + 360 : i - 360), Math.abs(n - r.longitude) > 180 && (s.longitude = n < 0 ? n + 360 : n - 360), s
         }
-        applyConstraints(e) {
+        applyConstraints(t) {
             let {
                 maxZoom: r,
                 minZoom: s,
                 zoom: i
-            } = e;
-            e.zoom = Le(i, s, r);
+            } = t;
+            t.zoom = Lt(i, s, r);
             let {
                 maxPitch: n,
                 minPitch: o,
                 pitch: a
-            } = e;
-            e.pitch = Le(a, o, n);
+            } = t;
+            t.pitch = Lt(a, o, n);
             let {
                 normalize: c = !0
-            } = e;
-            return c && Object.assign(e, gh(e)), e
+            } = t;
+            return c && Object.assign(t, gf(t)), t
         }
-        _zoomFromCenter(e) {
+        _zoomFromCenter(t) {
             let {
                 width: r,
                 height: s
             } = this.getViewportProps();
             return this.zoom({
                 pos: [r / 2, s / 2],
-                scale: e
+                scale: t
             })
         }
-        _panFromCenter(e) {
+        _panFromCenter(t) {
             let {
                 width: r,
                 height: s
             } = this.getViewportProps();
             return this.pan({
                 startPos: [r / 2, s / 2],
-                pos: [r / 2 + e[0], s / 2 + e[1]]
+                pos: [r / 2 + t[0], s / 2 + t[1]]
             })
         }
-        _getUpdatedState(e) {
+        _getUpdatedState(t) {
             return new this.constructor({
                 makeViewport: this.makeViewport,
                 ...this.getViewportProps(),
                 ...this.getState(),
-                ...e
+                ...t
             })
         }
-        _unproject(e) {
+        _unproject(t) {
             let r = this.makeViewport(this.getViewportProps());
-            return e && r.unproject(e)
+            return t && r.unproject(t)
         }
-        _getNewRotation(e, r, s, i) {
-            let n = e[0] - r[0],
-                o = e[1] - r[1],
-                a = e[1],
+        _getNewRotation(t, r, s, i) {
+            let n = t[0] - r[0],
+                o = t[1] - r[1],
+                a = t[1],
                 c = r[1],
                 {
                     width: l,
-                    height: h
+                    height: f
                 } = this.getViewportProps(),
                 d = n / l,
                 p = 0;
-            o > 0 ? Math.abs(h - c) > Sp && (p = o / (c - h) * yA) : o < 0 && c > Sp && (p = 1 - a / c), p = Le(p, -1, 1);
+            o > 0 ? Math.abs(f - c) > Sp && (p = o / (c - f) * wA) : o < 0 && c > Sp && (p = 1 - a / c), p = Lt(p, -1, 1);
             let {
                 minPitch: m,
                 maxPitch: y
-            } = this.getViewportProps(), x = i + 180 * d, b = s;
-            return p > 0 ? b = s + p * (y - s) : p < 0 && (b = s - p * (m - s)), {
-                pitch: b,
-                bearing: x
+            } = this.getViewportProps(), E = i + 180 * d, T = s;
+            return p > 0 ? T = s + p * (y - s) : p < 0 && (T = s - p * (m - s)), {
+                pitch: T,
+                bearing: E
             }
         }
     },
-    ys = class extends Ts {
+    ys = class extends bs {
         constructor() {
-            super(...arguments), this.ControllerState = Eh, this.transition = {
+            super(...arguments), this.ControllerState = Af, this.transition = {
                 transitionDuration: 300,
-                transitionInterpolator: new Gt({
+                transitionInterpolator: new Ge({
                     transitionProps: {
                         compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
                         required: ["longitude", "latitude", "zoom"]
                     }
                 })
             }, this.dragMode = "pan"
         }
-        setProps(e) {
-            e.position = e.position || [0, 0, 0];
+        setProps(t) {
+            t.position = t.position || [0, 0, 0];
             let r = this.props;
-            super.setProps(e), (!r || r.height !== e.height) && this.updateViewport(new this.ControllerState({
+            super.setProps(t), (!r || r.height !== t.height) && this.updateViewport(new this.ControllerState({
                 makeViewport: this.makeViewport,
-                ...e,
+                ...t,
                 ...this.state
             }))
         }
     };
-var Ah = class Ah extends gs {
+var Ef = class Ef extends _s {
     get ViewportType() {
-        return Zt
+        return Ze
     }
     get ControllerType() {
         return ys
     }
 };
-Ah.displayName = "MapView";
-var bs = Ah;
-var bA = new Pr;
-
-function EA(t, e) {
-    let r = t.order ?? 1 / 0,
-        s = e.order ?? 1 / 0;
+Ef.displayName = "MapView";
+var Ts = Ef;
+var AA = new Pr;
+
+function EA(e, t) {
+    let r = e.order ?? 1 / 0,
+        s = t.order ?? 1 / 0;
     return r - s
 }
 var Ui = class {
-    constructor(e) {
-        this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([])
+    constructor(t) {
+        this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = t, this._needsRedraw = "Initial render", this._setEffects([])
     }
-    addDefaultEffect(e) {
+    addDefaultEffect(t) {
         let r = this._defaultEffects;
-        if (!r.find(s => s.id === e.id)) {
-            let s = r.findIndex(i => EA(i, e) > 0);
-            s < 0 ? r.push(e) : r.splice(s, 0, e), e.setup(this._context), this._setEffects(this.effects)
+        if (!r.find(s => s.id === t.id)) {
+            let s = r.findIndex(i => EA(i, t) > 0);
+            s < 0 ? r.push(t) : r.splice(s, 0, t), t.setup(this._context), this._setEffects(this.effects)
         }
     }
-    setProps(e) {
-        "effects" in e && (ue(e.effects, this.effects, 1) || this._setEffects(e.effects))
+    setProps(t) {
+        "effects" in t && (ut(t.effects, this.effects, 1) || this._setEffects(t.effects))
     }
-    needsRedraw(e = {
+    needsRedraw(t = {
         clearRedrawFlags: !1
     }) {
         let r = this._needsRedraw;
-        return e.clearRedrawFlags && (this._needsRedraw = !1), r
+        return t.clearRedrawFlags && (this._needsRedraw = !1), r
     }
     getEffects() {
         return this._resolvedEffects
     }
-    _setEffects(e) {
+    _setEffects(t) {
         let r = {};
         for (let i of this.effects) r[i.id] = i;
         let s = [];
-        for (let i of e) {
+        for (let i of t) {
             let n = r[i.id],
                 o = i;
             n && n !== i ? n.setProps ? (n.setProps(i.props), o = n) : n.cleanup(this._context) : n || i.setup(this._context), s.push(o), delete r[i.id]
         }
         for (let i in r) r[i].cleanup(this._context);
-        this.effects = s, this._resolvedEffects = s.concat(this._defaultEffects), e.some(i => i instanceof Pr) || this._resolvedEffects.push(bA), this._needsRedraw = "effects changed"
+        this.effects = s, this._resolvedEffects = s.concat(this._defaultEffects), t.some(i => i instanceof Pr) || this._resolvedEffects.push(AA), this._needsRedraw = "effects changed"
     }
     finalize() {
-        for (let e of this._resolvedEffects) e.cleanup(this._context);
+        for (let t of this._resolvedEffects) t.cleanup(this._context);
         this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0
     }
 };
-var Li = class extends vt {
-    shouldDrawLayer(e) {
+var Li = class extends ve {
+    shouldDrawLayer(t) {
         let {
             operation: r
-        } = e.props;
+        } = t.props;
         return r.includes("draw") || r.includes("terrain")
     }
 };
-var AA = "deckRenderer.renderLayers",
-    Es = class {
-        constructor(e) {
-            this.device = e, this.gl = e.gl, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new Li(e), this.pickLayersPass = new Or(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null
+var xA = "deckRenderer.renderLayers",
+    ws = class {
+        constructor(t) {
+            this.device = t, this.gl = t.gl, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new Li(t), this.pickLayersPass = new Or(t), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null
         }
-        setProps(e) {
-            this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed")
+        setProps(t) {
+            this.layerFilter !== t.layerFilter && (this.layerFilter = t.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== t.drawPickingColors && (this.drawPickingColors = t.drawPickingColors, this._needsRedraw = "drawPickingColors changed")
         }
-        renderLayers(e) {
-            if (!e.viewports.length) return;
+        renderLayers(t) {
+            if (!t.viewports.length) return;
             let r = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass,
                 s = {
                     layerFilter: this.layerFilter,
                     isPicking: this.drawPickingColors,
-                    ...e
+                    ...t
                 };
             s.effects && this._preRender(s.effects, s);
             let i = this.lastPostProcessEffect ? this.renderBuffers[0] : s.target;
             this.lastPostProcessEffect && (s.clearColor = [0, 0, 0, 0], s.clearCanvas = !0);
             let n = r.render({
                 ...s,
                 target: i
             });
-            s.effects && this._postRender(s.effects, s), this.renderCount++, re(AA, this, n, e)
+            s.effects && this._postRender(s.effects, s), this.renderCount++, rt(xA, this, n, t)
         }
-        needsRedraw(e = {
+        needsRedraw(t = {
             clearRedrawFlags: !1
         }) {
             let r = this._needsRedraw;
-            return e.clearRedrawFlags && (this._needsRedraw = !1), r
+            return t.clearRedrawFlags && (this._needsRedraw = !1), r
         }
         finalize() {
             let {
-                renderBuffers: e
+                renderBuffers: t
             } = this;
-            for (let r of e) r.delete();
-            e.length = 0
+            for (let r of t) r.delete();
+            t.length = 0
         }
-        _preRender(e, r) {
+        _preRender(t, r) {
             this.lastPostProcessEffect = null, r.preRenderStats = r.preRenderStats || {};
-            for (let s of e) r.preRenderStats[s.id] = s.preRender(r), s.postRender && (this.lastPostProcessEffect = s.id);
+            for (let s of t) r.preRenderStats[s.id] = s.preRender(r), s.postRender && (this.lastPostProcessEffect = s.id);
             this.lastPostProcessEffect && this._resizeRenderBuffers()
         }
         _resizeRenderBuffers() {
             let {
-                renderBuffers: e
+                renderBuffers: t
             } = this, r = this.device.canvasContext.getDrawingBufferSize();
-            e.length === 0 && [0, 1].map(s => {
+            t.length === 0 && [0, 1].map(s => {
                 let i = this.device.createTexture({
                     sampler: {
                         minFilter: "linear",
                         magFilter: "linear"
                     }
                 });
-                e.push(this.device.createFramebuffer({
+                t.push(this.device.createFramebuffer({
                     id: `deck-renderbuffer-${s}`,
                     colorAttachments: [i]
                 }))
             });
-            for (let s of e) s.resize(r)
+            for (let s of t) s.resize(r)
         }
-        _postRender(e, r) {
+        _postRender(t, r) {
             let {
                 renderBuffers: s
             } = this, i = {
                 ...r,
                 inputBuffer: s[0],
                 swapBuffer: s[1]
             };
-            for (let n of e)
+            for (let n of t)
                 if (n.postRender) {
                     i.target = n.id === this.lastPostProcessEffect ? r.target : void 0;
                     let o = n.postRender(i);
                     i.inputBuffer = o, i.swapBuffer = o === s[0] ? s[1] : s[0]
                 }
         }
     };
-var xA = {
+var SA = {
     pickedColor: null,
     pickedObjectIndex: -1
 };
 
-function wp({
-    pickedColors: t,
-    decodePickingColor: e,
+function Rp({
+    pickedColors: e,
+    decodePickingColor: t,
     deviceX: r,
     deviceY: s,
     deviceRadius: i,
     deviceRect: n
 }) {
     let {
         x: o,
         y: a,
         width: c,
         height: l
-    } = n, h = i * i, d = -1, p = 0;
+    } = n, f = i * i, d = -1, p = 0;
     for (let m = 0; m < l; m++) {
         let y = m + a - s,
-            x = y * y;
-        if (x > h) p += 4 * c;
+            E = y * y;
+        if (E > f) p += 4 * c;
         else
-            for (let b = 0; b < c; b++) {
-                if (t[p + 3] - 1 >= 0) {
-                    let R = b + o - r,
-                        v = R * R + x;
-                    v <= h && (h = v, d = p)
+            for (let T = 0; T < c; T++) {
+                if (e[p + 3] - 1 >= 0) {
+                    let R = T + o - r,
+                        v = R * R + E;
+                    v <= f && (f = v, d = p)
                 }
                 p += 4
             }
     }
     if (d >= 0) {
-        let m = t.slice(d, d + 4),
-            y = e(m);
+        let m = e.slice(d, d + 4),
+            y = t(m);
         if (y) {
-            let x = Math.floor(d / 4 / c),
-                b = d / 4 - x * c;
+            let E = Math.floor(d / 4 / c),
+                T = d / 4 - E * c;
             return {
                 ...y,
                 pickedColor: m,
-                pickedX: o + b,
-                pickedY: a + x
+                pickedX: o + T,
+                pickedY: a + E
             }
         }
         W.error("Picked non-existent layer. Is picking buffer corrupt?")()
     }
-    return xA
+    return SA
 }
 
-function Rp({
-    pickedColors: t,
-    decodePickingColor: e
+function vp({
+    pickedColors: e,
+    decodePickingColor: t
 }) {
     let r = new Map;
-    if (t) {
-        for (let s = 0; s < t.length; s += 4)
-            if (t[s + 3] - 1 >= 0) {
-                let n = t.slice(s, s + 4),
+    if (e) {
+        for (let s = 0; s < e.length; s += 4)
+            if (e[s + 3] - 1 >= 0) {
+                let n = e.slice(s, s + 4),
                     o = n.join(",");
                 if (!r.has(o)) {
-                    let a = e(n);
+                    let a = t(n);
                     a ? r.set(o, {
                         ...a,
                         color: n
                     }) : W.error("Picked non-existent layer. Is picking buffer corrupt?")()
                 }
             }
     }
     return Array.from(r.values())
 }
 
-function xh({
-    pickInfo: t,
-    viewports: e,
+function xf({
+    pickInfo: e,
+    viewports: t,
     pixelRatio: r,
     x: s,
     y: i,
     z: n
 }) {
-    let o = e[0];
-    e.length > 1 && (o = SA(t?.pickedViewports || e, {
+    let o = t[0];
+    t.length > 1 && (o = RA(e?.pickedViewports || t, {
         x: s,
         y: i
     }));
     let a;
     if (o) {
         let c = [s - o.x, i - o.y];
         n !== void 0 && (c[2] = n), a = o.unproject(c)
@@ -14862,119 +14862,119 @@
         viewport: o,
         index: -1,
         picked: !1,
         x: s,
         y: i,
         pixel: [s, i],
         coordinate: a,
-        devicePixel: t && "pickedX" in t ? [t.pickedX, t.pickedY] : void 0,
+        devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
         pixelRatio: r
     }
 }
 
-function vp(t) {
+function Mp(e) {
     let {
-        pickInfo: e,
+        pickInfo: t,
         lastPickedInfo: r,
         mode: s,
         layers: i
-    } = t, {
+    } = e, {
         pickedColor: n,
         pickedLayer: o,
         pickedObjectIndex: a
-    } = e, c = o ? [o] : [];
+    } = t, c = o ? [o] : [];
     if (s === "hover") {
         let d = r.index,
             p = r.layerId,
             m = o ? o.props.id : null;
         if (m !== p || a !== d) {
             if (m !== p) {
-                let y = i.find(x => x.props.id === p);
+                let y = i.find(E => E.props.id === p);
                 y && c.unshift(y)
             }
             r.layerId = m, r.index = a, r.info = null
         }
     }
-    let l = xh(t),
-        h = new Map;
-    return h.set(null, l), c.forEach(d => {
+    let l = xf(e),
+        f = new Map;
+    return f.set(null, l), c.forEach(d => {
         let p = {
             ...l
         };
-        d === o && (p.color = n, p.index = a, p.picked = !0), p = Sh({
+        d === o && (p.color = n, p.index = a, p.picked = !0), p = Sf({
             layer: d,
             info: p,
             mode: s
         });
         let m = p.layer;
-        d === o && s === "hover" && (r.info = p), h.set(m.id, p), s === "hover" && m.updateAutoHighlight(p)
-    }), h
+        d === o && s === "hover" && (r.info = p), f.set(m.id, p), s === "hover" && m.updateAutoHighlight(p)
+    }), f
 }
 
-function Sh({
-    layer: t,
-    info: e,
+function Sf({
+    layer: e,
+    info: t,
     mode: r
 }) {
-    for (; t && e;) {
-        let s = e.layer || null;
-        e.sourceLayer = s, e.layer = t, e = t.getPickingInfo({
-            info: e,
+    for (; e && t;) {
+        let s = t.layer || null;
+        t.sourceLayer = s, t.layer = e, t = e.getPickingInfo({
+            info: t,
             mode: r,
             sourceLayer: s
-        }), t = t.parent
+        }), e = e.parent
     }
-    return e
+    return t
 }
 
-function SA(t, e) {
-    for (let r = t.length - 1; r >= 0; r--) {
-        let s = t[r];
-        if (s.containsPixel(e)) return s
+function RA(e, t) {
+    for (let r = e.length - 1; r >= 0; r--) {
+        let s = e[r];
+        if (s.containsPixel(t)) return s
     }
-    return t[0]
+    return e[0]
 }
 var Vi = class {
-    constructor(e) {
-        this._pickable = !0, this.device = e, this.pickLayersPass = new Or(e), this.lastPickedInfo = {
+    constructor(t) {
+        this._pickable = !0, this.device = t, this.pickLayersPass = new Or(t), this.lastPickedInfo = {
             index: -1,
             layerId: null,
             info: null
         }
     }
-    setProps(e) {
-        "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable)
+    setProps(t) {
+        "layerFilter" in t && (this.layerFilter = t.layerFilter), "_pickable" in t && (this._pickable = t._pickable)
     }
     finalize() {
         this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy()
     }
-    pickObject(e) {
-        return this._pickClosestObject(e)
+    pickObject(t) {
+        return this._pickClosestObject(t)
     }
-    pickObjects(e) {
-        return this._pickVisibleObjects(e)
+    pickObjects(t) {
+        return this._pickVisibleObjects(t)
     }
     getLastPickedObject({
-        x: e,
+        x: t,
         y: r,
         layers: s,
         viewports: i
     }, n = this.lastPickedInfo.info) {
         let o = n && n.layer && n.layer.id,
             a = n && n.viewport && n.viewport.id,
             c = o ? s.find(p => p.id === o) : null,
             l = a && i.find(p => p.id === a) || i[0],
-            h = l && l.unproject([e - l.x, r - l.y]);
+            f = l && l.unproject([t - l.x, r - l.y]);
         return {
             ...n,
             ...{
-                x: e,
+                x: t,
                 y: r,
                 viewport: l,
-                coordinate: h,
+                coordinate: f,
                 layer: c
             }
         }
     }
     _resizeBuffer() {
         if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
                 colorAttachments: ["rgba8unorm"],
@@ -14982,277 +14982,277 @@
             }), this.device.isTextureFormatRenderable("rgba32float"))) {
             let r = this.device.createFramebuffer({
                 colorAttachments: ["rgba32float"],
                 depthStencilAttachment: "depth16unorm"
             });
             this.depthFBO = r
         }
-        let e = this.device.gl;
+        let t = this.device.gl;
         this.pickingFBO?.resize({
-            width: e.canvas.width,
-            height: e.canvas.height
+            width: t.canvas.width,
+            height: t.canvas.height
         }), this.depthFBO?.resize({
-            width: e.canvas.width,
-            height: e.canvas.height
+            width: t.canvas.width,
+            height: t.canvas.height
         })
     }
-    _getPickable(e) {
+    _getPickable(t) {
         if (this._pickable === !1) return null;
-        let r = e.filter(s => this.pickLayersPass.shouldDrawLayer(s) && !s.isComposite);
+        let r = t.filter(s => this.pickLayersPass.shouldDrawLayer(s) && !s.isComposite);
         return r.length ? r : null
     }
     _pickClosestObject({
-        layers: e,
+        layers: t,
         views: r,
         viewports: s,
         x: i,
         y: n,
         radius: o = 0,
         depth: a = 1,
         mode: c = "query",
         unproject3D: l,
-        onViewportActive: h,
+        onViewportActive: f,
         effects: d
     }) {
         let p = this.device.canvasContext.cssToDeviceRatio(),
-            m = this._getPickable(e);
+            m = this._getPickable(t);
         if (!m || s.length === 0) return {
             result: [],
-            emptyInfo: xh({
+            emptyInfo: xf({
                 viewports: s,
                 x: i,
                 y: n,
                 pixelRatio: p
             })
         };
         this._resizeBuffer();
         let y = this.device.canvasContext.cssToDevicePixels([i, n], !0),
-            x = [y.x + Math.floor(y.width / 2), y.y + Math.floor(y.height / 2)],
-            b = Math.round(o * p),
+            E = [y.x + Math.floor(y.width / 2), y.y + Math.floor(y.height / 2)],
+            T = Math.round(o * p),
             {
-                width: w,
+                width: S,
                 height: R
             } = this.pickingFBO,
             v = this._getPickingRect({
-                deviceX: x[0],
-                deviceY: x[1],
-                deviceRadius: b,
-                deviceWidth: w,
+                deviceX: E[0],
+                deviceY: E[1],
+                deviceRadius: T,
+                deviceWidth: S,
                 deviceHeight: R
             }),
             C = {
                 x: i - o,
                 y: n - o,
                 width: o * 2 + 1,
                 height: o * 2 + 1
             },
             O, N = [],
             U = new Set;
-        for (let k = 0; k < a; k++) {
+        for (let D = 0; D < a; D++) {
             let B;
             if (v) {
                 let L = this._drawAndSample({
                     layers: m,
                     views: r,
                     viewports: s,
-                    onViewportActive: h,
+                    onViewportActive: f,
                     deviceRect: v,
                     cullRect: C,
                     effects: d,
                     pass: `picking:${c}`
                 });
-                B = wp({
+                B = Rp({
                     ...L,
-                    deviceX: x[0],
-                    deviceY: x[1],
-                    deviceRadius: b,
+                    deviceX: E[0],
+                    deviceY: E[1],
+                    deviceRadius: T,
                     deviceRect: v
                 })
             } else B = {
                 pickedColor: null,
                 pickedObjectIndex: -1
             };
             let F;
             if (B.pickedLayer && l && this.depthFBO) {
                 let {
                     pickedColors: L
                 } = this._drawAndSample({
                     layers: [B.pickedLayer],
                     views: r,
                     viewports: s,
-                    onViewportActive: h,
+                    onViewportActive: f,
                     deviceRect: {
                         x: B.pickedX,
                         y: B.pickedY,
                         width: 1,
                         height: 1
                     },
                     cullRect: C,
                     effects: d,
                     pass: `picking:${c}:z`
                 }, !0);
                 L[3] && (F = L[0])
             }
-            B.pickedLayer && k + 1 < a && (U.add(B.pickedLayer), B.pickedLayer.disablePickingIndex(B.pickedObjectIndex)), O = vp({
+            B.pickedLayer && D + 1 < a && (U.add(B.pickedLayer), B.pickedLayer.disablePickingIndex(B.pickedObjectIndex)), O = Mp({
                 pickInfo: B,
                 lastPickedInfo: this.lastPickedInfo,
                 mode: c,
                 layers: m,
                 viewports: s,
                 x: i,
                 y: n,
                 z: F,
                 pixelRatio: p
             });
             for (let L of O.values()) L.layer && N.push(L);
             if (!B.pickedColor) break
         }
-        for (let k of U) k.restorePickingColors();
+        for (let D of U) D.restorePickingColors();
         return {
             result: N,
             emptyInfo: O.get(null)
         }
     }
     _pickVisibleObjects({
-        layers: e,
+        layers: t,
         views: r,
         viewports: s,
         x: i,
         y: n,
         width: o = 1,
         height: a = 1,
         mode: c = "query",
         maxObjects: l = null,
-        onViewportActive: h,
+        onViewportActive: f,
         effects: d
     }) {
-        let p = this._getPickable(e);
+        let p = this._getPickable(t);
         if (!p || s.length === 0) return [];
         this._resizeBuffer();
         let m = this.device.canvasContext.cssToDeviceRatio(),
             y = this.device.canvasContext.cssToDevicePixels([i, n], !0),
-            x = y.x,
-            b = y.y + y.height,
-            w = this.device.canvasContext.cssToDevicePixels([i + o, n + a], !0),
-            R = w.x + w.width,
-            v = w.y,
+            E = y.x,
+            T = y.y + y.height,
+            S = this.device.canvasContext.cssToDevicePixels([i + o, n + a], !0),
+            R = S.x + S.width,
+            v = S.y,
             C = {
-                x,
+                x: E,
                 y: v,
-                width: R - x,
-                height: b - v
+                width: R - E,
+                height: T - v
             },
             O = this._drawAndSample({
                 layers: p,
                 views: r,
                 viewports: s,
-                onViewportActive: h,
+                onViewportActive: f,
                 deviceRect: C,
                 cullRect: {
                     x: i,
                     y: n,
                     width: o,
                     height: a
                 },
                 effects: d,
                 pass: `picking:${c}`
             }),
-            N = Rp(O),
+            N = vp(O),
             U = new Map,
-            k = [],
+            D = [],
             B = Number.isFinite(l);
-        for (let F = 0; F < N.length && !(B && k.length >= l); F++) {
+        for (let F = 0; F < N.length && !(B && D.length >= l); F++) {
             let L = N[F],
                 Y = {
                     color: L.pickedColor,
                     layer: null,
                     index: L.pickedObjectIndex,
                     picked: !0,
                     x: i,
                     y: n,
                     pixelRatio: m
                 };
-            Y = Sh({
+            Y = Sf({
                 layer: L.pickedLayer,
                 info: Y,
                 mode: c
             });
             let $ = Y.layer.id;
             U.has($) || U.set($, new Set);
-            let j = U.get($),
-                de = Y.object ?? Y.index;
-            j.has(de) || (j.add(de), k.push(Y))
+            let H = U.get($),
+                dt = Y.object ?? Y.index;
+            H.has(dt) || (H.add(dt), D.push(Y))
         }
-        return k
+        return D
     }
     _drawAndSample({
-        layers: e,
+        layers: t,
         views: r,
         viewports: s,
         onViewportActive: i,
         deviceRect: n,
         cullRect: o,
         effects: a,
         pass: c
     }, l = !1) {
-        let h = l ? this.depthFBO : this.pickingFBO,
+        let f = l ? this.depthFBO : this.pickingFBO,
             d = {
-                layers: e,
+                layers: t,
                 layerFilter: this.layerFilter,
                 views: r,
                 viewports: s,
                 onViewportActive: i,
-                pickingFBO: h,
+                pickingFBO: f,
                 deviceRect: n,
                 cullRect: o,
                 effects: a,
                 pass: c,
                 pickZ: l,
                 preRenderStats: {}
             };
         for (let R of a) R.useInPicking && (d.preRenderStats[R.id] = R.preRender(d));
         let {
             decodePickingColor: p
         } = this.pickLayersPass.render(d), {
             x: m,
             y,
-            width: x,
-            height: b
-        } = n, w = new(l ? Float32Array : Uint8Array)(x * b * 4);
-        return this.device.readPixelsToArrayWebGL(h, {
+            width: E,
+            height: T
+        } = n, S = new(l ? Float32Array : Uint8Array)(E * T * 4);
+        return this.device.readPixelsToArrayWebGL(f, {
             sourceX: m,
             sourceY: y,
-            sourceWidth: x,
-            sourceHeight: b,
-            target: w
+            sourceWidth: E,
+            sourceHeight: T,
+            target: S
         }), {
-            pickedColors: w,
+            pickedColors: S,
             decodePickingColor: p
         }
     }
     _getPickingRect({
-        deviceX: e,
+        deviceX: t,
         deviceY: r,
         deviceRadius: s,
         deviceWidth: i,
         deviceHeight: n
     }) {
-        let o = Math.max(0, e - s),
+        let o = Math.max(0, t - s),
             a = Math.max(0, r - s),
-            c = Math.min(i, e + s + 1) - o,
+            c = Math.min(i, t + s + 1) - o,
             l = Math.min(n, r + s + 1) - a;
         return c <= 0 || l <= 0 ? null : {
             x: o,
             y: a,
             width: c,
             height: l
         }
     }
 };
-var wA = {
+var vA = {
         "top-left": {
             top: 0,
             left: 0
         },
         "top-right": {
             top: 0,
             right: 0
@@ -15268,87 +15268,87 @@
         fill: {
             top: 0,
             left: 0,
             bottom: 0,
             right: 0
         }
     },
-    RA = "top-left",
-    Mp = "__root",
-    ea = class {
+    MA = "top-left",
+    Pp = "__root",
+    ta = class {
         constructor({
-            deck: e,
+            deck: t,
             parentElement: r
         }) {
-            this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, this.parentElement = r
+            this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = t, this.parentElement = r
         }
         getWidgets() {
             return this.resolvedWidgets
         }
-        setProps(e) {
-            e.widgets && !ue(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets)
+        setProps(t) {
+            t.widgets && !ut(t.widgets, this.widgets, 1) && this._setWidgets(t.widgets)
         }
         finalize() {
-            for (let e of this.getWidgets()) this._remove(e);
+            for (let t of this.getWidgets()) this._remove(t);
             this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
-            for (let e in this.containers) this.containers[e].remove()
+            for (let t in this.containers) this.containers[t].remove()
         }
-        addDefault(e) {
-            this.defaultWidgets.find(r => r.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets))
+        addDefault(t) {
+            this.defaultWidgets.find(r => r.id === t.id) || (this._add(t), this.defaultWidgets.push(t), this._setWidgets(this.widgets))
         }
-        _setWidgets(e) {
+        _setWidgets(t) {
             let r = {};
             for (let s of this.resolvedWidgets) r[s.id] = s;
             this.resolvedWidgets.length = 0;
             for (let s of this.defaultWidgets) r[s.id] = null, this.resolvedWidgets.push(s);
-            for (let s of e) {
+            for (let s of t) {
                 let i = r[s.id];
                 i ? i.viewId !== s.viewId || i.placement !== s.placement ? (this._remove(i), this._add(s)) : s !== i && (i.setProps(s.props), s = i) : this._add(s), r[s.id] = null, this.resolvedWidgets.push(s)
             }
             for (let s in r) {
                 let i = r[s];
                 i && this._remove(i)
             }
-            this.widgets = e
+            this.widgets = t
         }
-        _add(e) {
+        _add(t) {
             let {
                 viewId: r = null,
-                placement: s = RA
-            } = e, i = e.onAdd({
+                placement: s = MA
+            } = t, i = t.onAdd({
                 deck: this.deck,
                 viewId: r
             });
-            i && this._getContainer(r, s).append(i), e._element = i
+            i && this._getContainer(r, s).append(i), t._element = i
         }
-        _remove(e) {
-            e.onRemove(), e._element && e._element.remove(), e._element = void 0
+        _remove(t) {
+            t.onRemove(), t._element && t._element.remove(), t._element = void 0
         }
-        _getContainer(e, r) {
-            let s = e || Mp,
+        _getContainer(t, r) {
+            let s = t || Pp,
                 i = this.containers[s];
             i || (i = document.createElement("div"), i.style.pointerEvents = "none", i.style.position = "absolute", i.style.overflow = "hidden", this.parentElement?.append(i), this.containers[s] = i);
             let n = i.querySelector(`.${r}`);
-            return n || (n = document.createElement("div"), n.className = r, n.style.position = "absolute", Object.assign(n.style, wA[r]), i.append(n)), n
+            return n || (n = document.createElement("div"), n.className = r, n.style.position = "absolute", Object.assign(n.style, vA[r]), i.append(n)), n
         }
         _updateContainers() {
-            let e = this.deck.width,
+            let t = this.deck.width,
                 r = this.deck.height;
             for (let s in this.containers) {
                 let i = this.lastViewports[s] || null,
-                    n = s === Mp || i,
+                    n = s === Pp || i,
                     o = this.containers[s];
-                n ? (o.style.display = "block", o.style.left = `${i?i.x:0}px`, o.style.top = `${i?i.y:0}px`, o.style.width = `${i?i.width:e}px`, o.style.height = `${i?i.height:r}px`) : o.style.display = "none"
+                n ? (o.style.display = "block", o.style.left = `${i?i.x:0}px`, o.style.top = `${i?i.y:0}px`, o.style.width = `${i?i.width:t}px`, o.style.height = `${i?i.height:r}px`) : o.style.display = "none"
             }
         }
         onRedraw({
-            viewports: e,
+            viewports: t,
             layers: r
         }) {
-            let s = e.reduce((n, o) => (n[o.id] = o, n), {}),
+            let s = t.reduce((n, o) => (n[o.id] = o, n), {}),
                 {
                     lastViewports: i
                 } = this;
             for (let n of this.getWidgets()) {
                 let {
                     viewId: o
                 } = n;
@@ -15356,43 +15356,43 @@
                     let a = s[o];
                     a && (n.onViewportChange && !a.equals(i[o]) && n.onViewportChange(a), n.onRedraw?.({
                         viewports: [a],
                         layers: r
                     }))
                 } else {
                     if (n.onViewportChange)
-                        for (let a of e) a.equals(i[a.id]) || n.onViewportChange(a);
+                        for (let a of t) a.equals(i[a.id]) || n.onViewportChange(a);
                     n.onRedraw?.({
-                        viewports: e,
+                        viewports: t,
                         layers: r
                     })
                 }
             }
             this.lastViewports = s, this._updateContainers()
         }
-        onHover(e, r) {
+        onHover(t, r) {
             for (let s of this.getWidgets()) {
                 let {
                     viewId: i
                 } = s;
-                (!i || i === e.viewport?.id) && s.onHover?.(e, r)
+                (!i || i === t.viewport?.id) && s.onHover?.(t, r)
             }
         }
-        onEvent(e, r) {
-            let s = Ti[r.type];
+        onEvent(t, r) {
+            let s = bi[r.type];
             if (s)
                 for (let i of this.getWidgets()) {
                     let {
                         viewId: n
                     } = i;
-                    (!n || n === e.viewport?.id) && i[s.handler]?.(e, r)
+                    (!n || n === t.viewport?.id) && i[s.handler]?.(t, r)
                 }
         }
     };
-var vA = {
+var PA = {
         zIndex: "1",
         position: "absolute",
         pointerEvents: "none",
         color: "#a0a7b4",
         backgroundColor: "#29323c",
         padding: "10px",
         top: "0",
@@ -15400,52 +15400,52 @@
         display: "none"
     },
     Wi = class {
         constructor() {
             this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1
         }
         onAdd({
-            deck: e
+            deck: t
         }) {
             let r = document.createElement("div");
-            return r.className = "deck-tooltip", Object.assign(r.style, vA), this.deck = e, this.element = r, r
+            return r.className = "deck-tooltip", Object.assign(r.style, PA), this.deck = t, this.element = r, r
         }
         onRemove() {
             this.deck = void 0, this.element = void 0
         }
         setProps() {}
-        onViewportChange(e) {
-            this.isVisible && e.id === this.lastViewport?.id && e !== this.lastViewport && this.setTooltip(null)
+        onViewportChange(t) {
+            this.isVisible && t.id === this.lastViewport?.id && t !== this.lastViewport && this.setTooltip(null)
         }
-        onHover(e) {
+        onHover(t) {
             let {
                 deck: r
             } = this, s = r && r.props.getTooltip;
             if (!s) return;
-            let i = s(e);
-            this.lastViewport = e.viewport, this.setTooltip(i, e.x, e.y)
+            let i = s(t);
+            this.lastViewport = t.viewport, this.setTooltip(i, t.x, t.y)
         }
-        setTooltip(e, r, s) {
+        setTooltip(t, r, s) {
             let i = this.element;
             if (i) {
-                if (typeof e == "string") i.innerText = e;
-                else if (e) e.text && (i.innerText = e.text), e.html && (i.innerHTML = e.html), e.className && (i.className = e.className);
+                if (typeof t == "string") i.innerText = t;
+                else if (t) t.text && (i.innerText = t.text), t.html && (i.innerHTML = t.html), t.className && (i.className = t.className);
                 else {
                     this.isVisible = !1, i.style.display = "none";
                     return
                 }
-                this.isVisible = !0, i.style.display = "block", i.style.transform = `translate(${r}px, ${s}px)`, e && typeof e == "object" && "style" in e && Object.assign(i.style, e.style)
+                this.isVisible = !0, i.style.display = "block", i.style.transform = `translate(${r}px, ${s}px)`, t && typeof t == "object" && "style" in t && Object.assign(i.style, t.style)
             }
         }
     };
-var tr;
-(function(t) {
-    t[t.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", t[t.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", t[t.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t[t.ZERO = 0] = "ZERO", t[t.ONE = 1] = "ONE", t[t.SRC_COLOR = 768] = "SRC_COLOR", t[t.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", t[t.SRC_ALPHA = 770] = "SRC_ALPHA", t[t.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", t[t.DST_ALPHA = 772] = "DST_ALPHA", t[t.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", t[t.DST_COLOR = 774] = "DST_COLOR", t[t.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", t[t.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", t[t.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", t[t.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", t[t.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", t[t.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", t[t.FUNC_ADD = 32774] = "FUNC_ADD", t[t.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", t[t.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", t[t.BLEND_EQUATION = 32777] = "BLEND_EQUATION", t[t.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", t[t.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", t[t.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", t[t.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", t[t.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", t[t.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", t[t.BLEND_COLOR = 32773] = "BLEND_COLOR", t[t.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", t[t.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", t[t.LINE_WIDTH = 2849] = "LINE_WIDTH", t[t.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", t[t.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", t[t.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", t[t.FRONT_FACE = 2886] = "FRONT_FACE", t[t.DEPTH_RANGE = 2928] = "DEPTH_RANGE", t[t.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", t[t.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", t[t.DEPTH_FUNC = 2932] = "DEPTH_FUNC", t[t.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", t[t.STENCIL_FUNC = 2962] = "STENCIL_FUNC", t[t.STENCIL_FAIL = 2964] = "STENCIL_FAIL", t[t.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", t[t.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", t[t.STENCIL_REF = 2967] = "STENCIL_REF", t[t.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", t[t.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", t[t.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", t[t.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", t[t.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", t[t.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", t[t.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", t[t.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", t[t.VIEWPORT = 2978] = "VIEWPORT", t[t.SCISSOR_BOX = 3088] = "SCISSOR_BOX", t[t.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", t[t.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", t[t.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", t[t.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", t[t.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", t[t.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", t[t.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", t[t.RED_BITS = 3410] = "RED_BITS", t[t.GREEN_BITS = 3411] = "GREEN_BITS", t[t.BLUE_BITS = 3412] = "BLUE_BITS", t[t.ALPHA_BITS = 3413] = "ALPHA_BITS", t[t.DEPTH_BITS = 3414] = "DEPTH_BITS", t[t.STENCIL_BITS = 3415] = "STENCIL_BITS", t[t.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", t[t.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", t[t.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", t[t.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", t[t.SAMPLES = 32937] = "SAMPLES", t[t.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", t[t.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", t[t.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", t[t.VENDOR = 7936] = "VENDOR", t[t.RENDERER = 7937] = "RENDERER", t[t.VERSION = 7938] = "VERSION", t[t.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", t[t.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", t[t.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", t[t.STATIC_DRAW = 35044] = "STATIC_DRAW", t[t.STREAM_DRAW = 35040] = "STREAM_DRAW", t[t.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.BUFFER_SIZE = 34660] = "BUFFER_SIZE", t[t.BUFFER_USAGE = 34661] = "BUFFER_USAGE", t[t.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", t[t.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", t[t.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", t[t.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", t[t.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", t[t.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", t[t.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", t[t.CULL_FACE = 2884] = "CULL_FACE", t[t.FRONT = 1028] = "FRONT", t[t.BACK = 1029] = "BACK", t[t.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", t[t.BLEND = 3042] = "BLEND", t[t.DEPTH_TEST = 2929] = "DEPTH_TEST", t[t.DITHER = 3024] = "DITHER", t[t.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", t[t.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", t[t.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", t[t.SCISSOR_TEST = 3089] = "SCISSOR_TEST", t[t.STENCIL_TEST = 2960] = "STENCIL_TEST", t[t.NO_ERROR = 0] = "NO_ERROR", t[t.INVALID_ENUM = 1280] = "INVALID_ENUM", t[t.INVALID_VALUE = 1281] = "INVALID_VALUE", t[t.INVALID_OPERATION = 1282] = "INVALID_OPERATION", t[t.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", t[t.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", t[t.CW = 2304] = "CW", t[t.CCW = 2305] = "CCW", t[t.DONT_CARE = 4352] = "DONT_CARE", t[t.FASTEST = 4353] = "FASTEST", t[t.NICEST = 4354] = "NICEST", t[t.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", t[t.BYTE = 5120] = "BYTE", t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.SHORT = 5122] = "SHORT", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.INT = 5124] = "INT", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.FLOAT = 5126] = "FLOAT", t[t.DOUBLE = 5130] = "DOUBLE", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.ALPHA = 6406] = "ALPHA", t[t.RGB = 6407] = "RGB", t[t.RGBA = 6408] = "RGBA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", t[t.VERTEX_SHADER = 35633] = "VERTEX_SHADER", t[t.COMPILE_STATUS = 35713] = "COMPILE_STATUS", t[t.DELETE_STATUS = 35712] = "DELETE_STATUS", t[t.LINK_STATUS = 35714] = "LINK_STATUS", t[t.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", t[t.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", t[t.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", t[t.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", t[t.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", t[t.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", t[t.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", t[t.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", t[t.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", t[t.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", t[t.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", t[t.SHADER_TYPE = 35663] = "SHADER_TYPE", t[t.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", t[t.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", t[t.NEVER = 512] = "NEVER", t[t.LESS = 513] = "LESS", t[t.EQUAL = 514] = "EQUAL", t[t.LEQUAL = 515] = "LEQUAL", t[t.GREATER = 516] = "GREATER", t[t.NOTEQUAL = 517] = "NOTEQUAL", t[t.GEQUAL = 518] = "GEQUAL", t[t.ALWAYS = 519] = "ALWAYS", t[t.KEEP = 7680] = "KEEP", t[t.REPLACE = 7681] = "REPLACE", t[t.INCR = 7682] = "INCR", t[t.DECR = 7683] = "DECR", t[t.INVERT = 5386] = "INVERT", t[t.INCR_WRAP = 34055] = "INCR_WRAP", t[t.DECR_WRAP = 34056] = "DECR_WRAP", t[t.NEAREST = 9728] = "NEAREST", t[t.LINEAR = 9729] = "LINEAR", t[t.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", t[t.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", t[t.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", t[t.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", t[t.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", t[t.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", t[t.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", t[t.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE = 5890] = "TEXTURE", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t[t.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", t[t.TEXTURE0 = 33984] = "TEXTURE0", t[t.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", t[t.REPEAT = 10497] = "REPEAT", t[t.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t[t.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", t[t.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", t[t.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", t[t.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", t[t.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", t[t.INT_VEC2 = 35667] = "INT_VEC2", t[t.INT_VEC3 = 35668] = "INT_VEC3", t[t.INT_VEC4 = 35669] = "INT_VEC4", t[t.BOOL = 35670] = "BOOL", t[t.BOOL_VEC2 = 35671] = "BOOL_VEC2", t[t.BOOL_VEC3 = 35672] = "BOOL_VEC3", t[t.BOOL_VEC4 = 35673] = "BOOL_VEC4", t[t.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", t[t.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", t[t.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", t[t.SAMPLER_2D = 35678] = "SAMPLER_2D", t[t.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", t[t.LOW_FLOAT = 36336] = "LOW_FLOAT", t[t.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", t[t.HIGH_FLOAT = 36338] = "HIGH_FLOAT", t[t.LOW_INT = 36339] = "LOW_INT", t[t.MEDIUM_INT = 36340] = "MEDIUM_INT", t[t.HIGH_INT = 36341] = "HIGH_INT", t[t.FRAMEBUFFER = 36160] = "FRAMEBUFFER", t[t.RENDERBUFFER = 36161] = "RENDERBUFFER", t[t.RGBA4 = 32854] = "RGBA4", t[t.RGB5_A1 = 32855] = "RGB5_A1", t[t.RGB565 = 36194] = "RGB565", t[t.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", t[t.STENCIL_INDEX = 6401] = "STENCIL_INDEX", t[t.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t[t.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", t[t.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", t[t.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", t[t.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", t[t.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", t[t.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", t[t.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", t[t.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", t[t.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", t[t.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", t[t.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", t[t.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", t[t.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", t[t.NONE = 0] = "NONE", t[t.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", t[t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", t[t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", t[t.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", t[t.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", t[t.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", t[t.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", t[t.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", t[t.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", t[t.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", t[t.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", t[t.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", t[t.READ_BUFFER = 3074] = "READ_BUFFER", t[t.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", t[t.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", t[t.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", t[t.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", t[t.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", t[t.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", t[t.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", t[t.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", t[t.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", t[t.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", t[t.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", t[t.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", t[t.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", t[t.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", t[t.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", t[t.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", t[t.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", t[t.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", t[t.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", t[t.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", t[t.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", t[t.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", t[t.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", t[t.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", t[t.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", t[t.RED = 6403] = "RED", t[t.RGB8 = 32849] = "RGB8", t[t.RGBA8 = 32856] = "RGBA8", t[t.RGB10_A2 = 32857] = "RGB10_A2", t[t.TEXTURE_3D = 32879] = "TEXTURE_3D", t[t.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", t[t.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", t[t.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", t[t.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", t[t.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", t[t.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", t[t.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", t[t.SRGB = 35904] = "SRGB", t[t.SRGB8 = 35905] = "SRGB8", t[t.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", t[t.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", t[t.RGBA32F = 34836] = "RGBA32F", t[t.RGB32F = 34837] = "RGB32F", t[t.RGBA16F = 34842] = "RGBA16F", t[t.RGB16F = 34843] = "RGB16F", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", t[t.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", t[t.RGB9_E5 = 35901] = "RGB9_E5", t[t.RGBA32UI = 36208] = "RGBA32UI", t[t.RGB32UI = 36209] = "RGB32UI", t[t.RGBA16UI = 36214] = "RGBA16UI", t[t.RGB16UI = 36215] = "RGB16UI", t[t.RGBA8UI = 36220] = "RGBA8UI", t[t.RGB8UI = 36221] = "RGB8UI", t[t.RGBA32I = 36226] = "RGBA32I", t[t.RGB32I = 36227] = "RGB32I", t[t.RGBA16I = 36232] = "RGBA16I", t[t.RGB16I = 36233] = "RGB16I", t[t.RGBA8I = 36238] = "RGBA8I", t[t.RGB8I = 36239] = "RGB8I", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.R8 = 33321] = "R8", t[t.RG8 = 33323] = "RG8", t[t.R16F = 33325] = "R16F", t[t.R32F = 33326] = "R32F", t[t.RG16F = 33327] = "RG16F", t[t.RG32F = 33328] = "RG32F", t[t.R8I = 33329] = "R8I", t[t.R8UI = 33330] = "R8UI", t[t.R16I = 33331] = "R16I", t[t.R16UI = 33332] = "R16UI", t[t.R32I = 33333] = "R32I", t[t.R32UI = 33334] = "R32UI", t[t.RG8I = 33335] = "RG8I", t[t.RG8UI = 33336] = "RG8UI", t[t.RG16I = 33337] = "RG16I", t[t.RG16UI = 33338] = "RG16UI", t[t.RG32I = 33339] = "RG32I", t[t.RG32UI = 33340] = "RG32UI", t[t.R8_SNORM = 36756] = "R8_SNORM", t[t.RG8_SNORM = 36757] = "RG8_SNORM", t[t.RGB8_SNORM = 36758] = "RGB8_SNORM", t[t.RGBA8_SNORM = 36759] = "RGBA8_SNORM", t[t.RGB10_A2UI = 36975] = "RGB10_A2UI", t[t.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", t[t.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.HALF_FLOAT = 5131] = "HALF_FLOAT", t[t.RG = 33319] = "RG", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", t[t.CURRENT_QUERY = 34917] = "CURRENT_QUERY", t[t.QUERY_RESULT = 34918] = "QUERY_RESULT", t[t.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", t[t.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", t[t.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", t[t.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", t[t.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", t[t.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", t[t.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", t[t.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", t[t.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", t[t.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", t[t.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", t[t.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", t[t.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", t[t.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", t[t.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", t[t.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", t[t.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", t[t.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", t[t.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", t[t.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", t[t.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", t[t.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", t[t.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", t[t.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", t[t.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", t[t.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", t[t.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", t[t.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", t[t.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", t[t.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", t[t.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", t[t.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", t[t.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", t[t.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", t[t.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", t[t.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", t[t.SAMPLER_3D = 35679] = "SAMPLER_3D", t[t.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", t[t.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", t[t.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", t[t.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", t[t.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", t[t.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", t[t.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", t[t.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", t[t.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", t[t.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", t[t.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", t[t.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", t[t.MAX_SAMPLES = 36183] = "MAX_SAMPLES", t[t.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", t[t.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", t[t.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", t[t.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", t[t.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", t[t.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", t[t.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", t[t.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", t[t.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", t[t.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", t[t.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", t[t.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", t[t.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", t[t.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", t[t.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", t[t.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", t[t.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", t[t.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", t[t.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", t[t.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", t[t.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", t[t.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", t[t.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", t[t.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", t[t.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", t[t.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", t[t.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", t[t.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", t[t.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", t[t.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", t[t.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", t[t.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", t[t.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", t[t.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", t[t.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", t[t.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", t[t.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", t[t.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", t[t.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", t[t.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", t[t.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", t[t.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", t[t.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", t[t.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", t[t.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", t[t.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", t[t.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", t[t.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t[t.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", t[t.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", t[t.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", t[t.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", t[t.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", t[t.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", t[t.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", t[t.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", t[t.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", t[t.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", t[t.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", t[t.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", t[t.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", t[t.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", t[t.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", t[t.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", t[t.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", t[t.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", t[t.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", t[t.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", t[t.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", t[t.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", t[t.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", t[t.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", t[t.OBJECT_TYPE = 37138] = "OBJECT_TYPE", t[t.SYNC_CONDITION = 37139] = "SYNC_CONDITION", t[t.SYNC_STATUS = 37140] = "SYNC_STATUS", t[t.SYNC_FLAGS = 37141] = "SYNC_FLAGS", t[t.SYNC_FENCE = 37142] = "SYNC_FENCE", t[t.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", t[t.UNSIGNALED = 37144] = "UNSIGNALED", t[t.SIGNALED = 37145] = "SIGNALED", t[t.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", t[t.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", t[t.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", t[t.WAIT_FAILED = 37149] = "WAIT_FAILED", t[t.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", t[t.COLOR = 6144] = "COLOR", t[t.DEPTH = 6145] = "DEPTH", t[t.STENCIL = 6146] = "STENCIL", t[t.MIN = 32775] = "MIN", t[t.MAX = 32776] = "MAX", t[t.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", t[t.STREAM_READ = 35041] = "STREAM_READ", t[t.STREAM_COPY = 35042] = "STREAM_COPY", t[t.STATIC_READ = 35045] = "STATIC_READ", t[t.STATIC_COPY = 35046] = "STATIC_COPY", t[t.DYNAMIC_READ = 35049] = "DYNAMIC_READ", t[t.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", t[t.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", t[t.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", t[t.INVALID_INDEX = 4294967295] = "INVALID_INDEX", t[t.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", t[t.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", t[t.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", t[t.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", t[t.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", t[t.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", t[t.R16_EXT = 33322] = "R16_EXT", t[t.RG16_EXT = 33324] = "RG16_EXT", t[t.RGB16_EXT = 32852] = "RGB16_EXT", t[t.RGBA16_EXT = 32859] = "RGBA16_EXT", t[t.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", t[t.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", t[t.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", t[t.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", t[t.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", t[t.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", t[t.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", t[t.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", t[t.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", t[t.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t[t.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", t[t.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", t[t.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", t[t.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", t[t.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", t[t.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", t[t.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", t[t.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", t[t.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", t[t.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", t[t.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", t[t.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", t[t.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", t[t.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", t[t.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", t[t.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", t[t.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", t[t.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", t[t.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", t[t.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", t[t.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", t[t.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", t[t.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", t[t.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", t[t.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", t[t.LINE_WEBGL = 6913] = "LINE_WEBGL", t[t.FILL_WEBGL = 6914] = "FILL_WEBGL", t[t.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", t[t.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", t[t.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", t[t.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", t[t.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", t[t.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", t[t.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", t[t.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", t[t.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", t[t.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", t[t.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", t[t.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", t[t.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", t[t.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", t[t.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", t[t.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", t[t.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", t[t.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", t[t.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", t[t.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", t[t.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", t[t.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", t[t.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", t[t.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT"
-})(tr || (tr = {}));
-var Hi = {
+var er;
+(function(e) {
+    e[e.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", e[e.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", e[e.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", e[e.ZERO = 0] = "ZERO", e[e.ONE = 1] = "ONE", e[e.SRC_COLOR = 768] = "SRC_COLOR", e[e.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", e[e.SRC_ALPHA = 770] = "SRC_ALPHA", e[e.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", e[e.DST_ALPHA = 772] = "DST_ALPHA", e[e.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", e[e.DST_COLOR = 774] = "DST_COLOR", e[e.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", e[e.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", e[e.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", e[e.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", e[e.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", e[e.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", e[e.FUNC_ADD = 32774] = "FUNC_ADD", e[e.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", e[e.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", e[e.BLEND_EQUATION = 32777] = "BLEND_EQUATION", e[e.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", e[e.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", e[e.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", e[e.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", e[e.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", e[e.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", e[e.BLEND_COLOR = 32773] = "BLEND_COLOR", e[e.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", e[e.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", e[e.LINE_WIDTH = 2849] = "LINE_WIDTH", e[e.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", e[e.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", e[e.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", e[e.FRONT_FACE = 2886] = "FRONT_FACE", e[e.DEPTH_RANGE = 2928] = "DEPTH_RANGE", e[e.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", e[e.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", e[e.DEPTH_FUNC = 2932] = "DEPTH_FUNC", e[e.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", e[e.STENCIL_FUNC = 2962] = "STENCIL_FUNC", e[e.STENCIL_FAIL = 2964] = "STENCIL_FAIL", e[e.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", e[e.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", e[e.STENCIL_REF = 2967] = "STENCIL_REF", e[e.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", e[e.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", e[e.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", e[e.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", e[e.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", e[e.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", e[e.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", e[e.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", e[e.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", e[e.VIEWPORT = 2978] = "VIEWPORT", e[e.SCISSOR_BOX = 3088] = "SCISSOR_BOX", e[e.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", e[e.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", e[e.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", e[e.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", e[e.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", e[e.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", e[e.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", e[e.RED_BITS = 3410] = "RED_BITS", e[e.GREEN_BITS = 3411] = "GREEN_BITS", e[e.BLUE_BITS = 3412] = "BLUE_BITS", e[e.ALPHA_BITS = 3413] = "ALPHA_BITS", e[e.DEPTH_BITS = 3414] = "DEPTH_BITS", e[e.STENCIL_BITS = 3415] = "STENCIL_BITS", e[e.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", e[e.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", e[e.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", e[e.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", e[e.SAMPLES = 32937] = "SAMPLES", e[e.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", e[e.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", e[e.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", e[e.VENDOR = 7936] = "VENDOR", e[e.RENDERER = 7937] = "RENDERER", e[e.VERSION = 7938] = "VERSION", e[e.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", e[e.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", e[e.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", e[e.STATIC_DRAW = 35044] = "STATIC_DRAW", e[e.STREAM_DRAW = 35040] = "STREAM_DRAW", e[e.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", e[e.BUFFER_SIZE = 34660] = "BUFFER_SIZE", e[e.BUFFER_USAGE = 34661] = "BUFFER_USAGE", e[e.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", e[e.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", e[e.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", e[e.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", e[e.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", e[e.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", e[e.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", e[e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", e[e.CULL_FACE = 2884] = "CULL_FACE", e[e.FRONT = 1028] = "FRONT", e[e.BACK = 1029] = "BACK", e[e.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", e[e.BLEND = 3042] = "BLEND", e[e.DEPTH_TEST = 2929] = "DEPTH_TEST", e[e.DITHER = 3024] = "DITHER", e[e.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", e[e.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", e[e.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", e[e.SCISSOR_TEST = 3089] = "SCISSOR_TEST", e[e.STENCIL_TEST = 2960] = "STENCIL_TEST", e[e.NO_ERROR = 0] = "NO_ERROR", e[e.INVALID_ENUM = 1280] = "INVALID_ENUM", e[e.INVALID_VALUE = 1281] = "INVALID_VALUE", e[e.INVALID_OPERATION = 1282] = "INVALID_OPERATION", e[e.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", e[e.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", e[e.CW = 2304] = "CW", e[e.CCW = 2305] = "CCW", e[e.DONT_CARE = 4352] = "DONT_CARE", e[e.FASTEST = 4353] = "FASTEST", e[e.NICEST = 4354] = "NICEST", e[e.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", e[e.BYTE = 5120] = "BYTE", e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.SHORT = 5122] = "SHORT", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.INT = 5124] = "INT", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.FLOAT = 5126] = "FLOAT", e[e.DOUBLE = 5130] = "DOUBLE", e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", e[e.ALPHA = 6406] = "ALPHA", e[e.RGB = 6407] = "RGB", e[e.RGBA = 6408] = "RGBA", e[e.LUMINANCE = 6409] = "LUMINANCE", e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", e[e.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", e[e.VERTEX_SHADER = 35633] = "VERTEX_SHADER", e[e.COMPILE_STATUS = 35713] = "COMPILE_STATUS", e[e.DELETE_STATUS = 35712] = "DELETE_STATUS", e[e.LINK_STATUS = 35714] = "LINK_STATUS", e[e.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", e[e.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", e[e.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", e[e.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", e[e.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", e[e.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", e[e.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", e[e.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", e[e.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", e[e.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", e[e.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", e[e.SHADER_TYPE = 35663] = "SHADER_TYPE", e[e.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", e[e.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", e[e.NEVER = 512] = "NEVER", e[e.LESS = 513] = "LESS", e[e.EQUAL = 514] = "EQUAL", e[e.LEQUAL = 515] = "LEQUAL", e[e.GREATER = 516] = "GREATER", e[e.NOTEQUAL = 517] = "NOTEQUAL", e[e.GEQUAL = 518] = "GEQUAL", e[e.ALWAYS = 519] = "ALWAYS", e[e.KEEP = 7680] = "KEEP", e[e.REPLACE = 7681] = "REPLACE", e[e.INCR = 7682] = "INCR", e[e.DECR = 7683] = "DECR", e[e.INVERT = 5386] = "INVERT", e[e.INCR_WRAP = 34055] = "INCR_WRAP", e[e.DECR_WRAP = 34056] = "DECR_WRAP", e[e.NEAREST = 9728] = "NEAREST", e[e.LINEAR = 9729] = "LINEAR", e[e.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", e[e.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", e[e.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", e[e.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", e[e.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", e[e.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", e[e.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", e[e.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", e[e.TEXTURE_2D = 3553] = "TEXTURE_2D", e[e.TEXTURE = 5890] = "TEXTURE", e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", e[e.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", e[e.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", e[e.TEXTURE0 = 33984] = "TEXTURE0", e[e.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", e[e.REPEAT = 10497] = "REPEAT", e[e.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e[e.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", e[e.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", e[e.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", e[e.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", e[e.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", e[e.INT_VEC2 = 35667] = "INT_VEC2", e[e.INT_VEC3 = 35668] = "INT_VEC3", e[e.INT_VEC4 = 35669] = "INT_VEC4", e[e.BOOL = 35670] = "BOOL", e[e.BOOL_VEC2 = 35671] = "BOOL_VEC2", e[e.BOOL_VEC3 = 35672] = "BOOL_VEC3", e[e.BOOL_VEC4 = 35673] = "BOOL_VEC4", e[e.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", e[e.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", e[e.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", e[e.SAMPLER_2D = 35678] = "SAMPLER_2D", e[e.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", e[e.LOW_FLOAT = 36336] = "LOW_FLOAT", e[e.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", e[e.HIGH_FLOAT = 36338] = "HIGH_FLOAT", e[e.LOW_INT = 36339] = "LOW_INT", e[e.MEDIUM_INT = 36340] = "MEDIUM_INT", e[e.HIGH_INT = 36341] = "HIGH_INT", e[e.FRAMEBUFFER = 36160] = "FRAMEBUFFER", e[e.RENDERBUFFER = 36161] = "RENDERBUFFER", e[e.RGBA4 = 32854] = "RGBA4", e[e.RGB5_A1 = 32855] = "RGB5_A1", e[e.RGB565 = 36194] = "RGB565", e[e.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", e[e.STENCIL_INDEX = 6401] = "STENCIL_INDEX", e[e.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", e[e.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", e[e.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", e[e.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", e[e.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", e[e.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", e[e.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", e[e.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", e[e.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", e[e.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", e[e.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", e[e.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", e[e.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", e[e.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", e[e.NONE = 0] = "NONE", e[e.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", e[e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", e[e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", e[e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", e[e.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", e[e.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", e[e.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", e[e.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", e[e.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", e[e.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", e[e.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", e[e.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", e[e.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", e[e.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", e[e.READ_BUFFER = 3074] = "READ_BUFFER", e[e.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", e[e.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", e[e.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", e[e.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", e[e.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", e[e.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", e[e.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", e[e.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", e[e.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", e[e.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", e[e.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", e[e.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", e[e.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", e[e.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", e[e.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", e[e.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", e[e.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", e[e.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", e[e.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", e[e.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", e[e.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", e[e.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", e[e.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", e[e.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", e[e.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", e[e.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", e[e.RED = 6403] = "RED", e[e.RGB8 = 32849] = "RGB8", e[e.RGBA8 = 32856] = "RGBA8", e[e.RGB10_A2 = 32857] = "RGB10_A2", e[e.TEXTURE_3D = 32879] = "TEXTURE_3D", e[e.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", e[e.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", e[e.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", e[e.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", e[e.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", e[e.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", e[e.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", e[e.SRGB = 35904] = "SRGB", e[e.SRGB8 = 35905] = "SRGB8", e[e.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", e[e.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", e[e.RGBA32F = 34836] = "RGBA32F", e[e.RGB32F = 34837] = "RGB32F", e[e.RGBA16F = 34842] = "RGBA16F", e[e.RGB16F = 34843] = "RGB16F", e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", e[e.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", e[e.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", e[e.RGB9_E5 = 35901] = "RGB9_E5", e[e.RGBA32UI = 36208] = "RGBA32UI", e[e.RGB32UI = 36209] = "RGB32UI", e[e.RGBA16UI = 36214] = "RGBA16UI", e[e.RGB16UI = 36215] = "RGB16UI", e[e.RGBA8UI = 36220] = "RGBA8UI", e[e.RGB8UI = 36221] = "RGB8UI", e[e.RGBA32I = 36226] = "RGBA32I", e[e.RGB32I = 36227] = "RGB32I", e[e.RGBA16I = 36232] = "RGBA16I", e[e.RGB16I = 36233] = "RGB16I", e[e.RGBA8I = 36238] = "RGBA8I", e[e.RGB8I = 36239] = "RGB8I", e[e.RED_INTEGER = 36244] = "RED_INTEGER", e[e.RGB_INTEGER = 36248] = "RGB_INTEGER", e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER", e[e.R8 = 33321] = "R8", e[e.RG8 = 33323] = "RG8", e[e.R16F = 33325] = "R16F", e[e.R32F = 33326] = "R32F", e[e.RG16F = 33327] = "RG16F", e[e.RG32F = 33328] = "RG32F", e[e.R8I = 33329] = "R8I", e[e.R8UI = 33330] = "R8UI", e[e.R16I = 33331] = "R16I", e[e.R16UI = 33332] = "R16UI", e[e.R32I = 33333] = "R32I", e[e.R32UI = 33334] = "R32UI", e[e.RG8I = 33335] = "RG8I", e[e.RG8UI = 33336] = "RG8UI", e[e.RG16I = 33337] = "RG16I", e[e.RG16UI = 33338] = "RG16UI", e[e.RG32I = 33339] = "RG32I", e[e.RG32UI = 33340] = "RG32UI", e[e.R8_SNORM = 36756] = "R8_SNORM", e[e.RG8_SNORM = 36757] = "RG8_SNORM", e[e.RGB8_SNORM = 36758] = "RGB8_SNORM", e[e.RGBA8_SNORM = 36759] = "RGBA8_SNORM", e[e.RGB10_A2UI = 36975] = "RGB10_A2UI", e[e.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", e[e.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", e[e.HALF_FLOAT = 5131] = "HALF_FLOAT", e[e.RG = 33319] = "RG", e[e.RG_INTEGER = 33320] = "RG_INTEGER", e[e.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", e[e.CURRENT_QUERY = 34917] = "CURRENT_QUERY", e[e.QUERY_RESULT = 34918] = "QUERY_RESULT", e[e.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", e[e.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", e[e.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", e[e.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", e[e.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", e[e.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", e[e.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", e[e.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", e[e.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", e[e.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", e[e.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", e[e.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", e[e.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", e[e.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", e[e.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", e[e.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", e[e.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", e[e.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", e[e.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", e[e.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", e[e.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", e[e.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", e[e.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", e[e.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", e[e.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", e[e.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", e[e.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", e[e.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", e[e.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", e[e.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", e[e.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", e[e.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", e[e.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", e[e.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", e[e.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", e[e.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", e[e.SAMPLER_3D = 35679] = "SAMPLER_3D", e[e.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", e[e.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", e[e.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", e[e.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", e[e.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", e[e.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", e[e.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", e[e.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", e[e.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", e[e.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", e[e.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", e[e.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", e[e.MAX_SAMPLES = 36183] = "MAX_SAMPLES", e[e.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", e[e.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", e[e.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", e[e.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", e[e.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", e[e.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", e[e.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", e[e.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", e[e.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", e[e.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", e[e.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", e[e.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", e[e.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", e[e.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", e[e.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", e[e.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", e[e.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", e[e.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", e[e.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", e[e.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", e[e.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", e[e.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", e[e.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", e[e.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", e[e.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", e[e.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", e[e.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", e[e.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", e[e.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", e[e.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", e[e.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", e[e.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", e[e.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", e[e.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", e[e.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", e[e.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", e[e.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", e[e.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", e[e.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", e[e.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", e[e.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", e[e.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", e[e.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", e[e.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", e[e.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", e[e.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", e[e.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", e[e.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", e[e.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", e[e.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", e[e.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", e[e.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", e[e.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", e[e.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", e[e.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", e[e.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", e[e.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", e[e.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", e[e.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", e[e.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", e[e.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", e[e.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", e[e.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", e[e.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", e[e.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", e[e.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", e[e.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", e[e.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", e[e.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", e[e.OBJECT_TYPE = 37138] = "OBJECT_TYPE", e[e.SYNC_CONDITION = 37139] = "SYNC_CONDITION", e[e.SYNC_STATUS = 37140] = "SYNC_STATUS", e[e.SYNC_FLAGS = 37141] = "SYNC_FLAGS", e[e.SYNC_FENCE = 37142] = "SYNC_FENCE", e[e.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", e[e.UNSIGNALED = 37144] = "UNSIGNALED", e[e.SIGNALED = 37145] = "SIGNALED", e[e.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", e[e.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", e[e.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", e[e.WAIT_FAILED = 37149] = "WAIT_FAILED", e[e.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", e[e.COLOR = 6144] = "COLOR", e[e.DEPTH = 6145] = "DEPTH", e[e.STENCIL = 6146] = "STENCIL", e[e.MIN = 32775] = "MIN", e[e.MAX = 32776] = "MAX", e[e.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", e[e.STREAM_READ = 35041] = "STREAM_READ", e[e.STREAM_COPY = 35042] = "STREAM_COPY", e[e.STATIC_READ = 35045] = "STATIC_READ", e[e.STATIC_COPY = 35046] = "STATIC_COPY", e[e.DYNAMIC_READ = 35049] = "DYNAMIC_READ", e[e.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", e[e.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", e[e.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", e[e.INVALID_INDEX = 4294967295] = "INVALID_INDEX", e[e.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", e[e.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", e[e.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", e[e.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", e[e.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", e[e.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", e[e.R16_EXT = 33322] = "R16_EXT", e[e.RG16_EXT = 33324] = "RG16_EXT", e[e.RGB16_EXT = 32852] = "RGB16_EXT", e[e.RGBA16_EXT = 32859] = "RGBA16_EXT", e[e.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", e[e.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", e[e.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", e[e.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", e[e.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", e[e.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", e[e.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", e[e.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", e[e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", e[e.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", e[e.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", e[e.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", e[e.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", e[e.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", e[e.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", e[e.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", e[e.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", e[e.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", e[e.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", e[e.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", e[e.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", e[e.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", e[e.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", e[e.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", e[e.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", e[e.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", e[e.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", e[e.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", e[e.LINE_WEBGL = 6913] = "LINE_WEBGL", e[e.FILL_WEBGL = 6914] = "FILL_WEBGL", e[e.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", e[e.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", e[e.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", e[e.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", e[e.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", e[e.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", e[e.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", e[e.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", e[e.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", e[e.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", e[e.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", e[e.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", e[e.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", e[e.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", e[e.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", e[e.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", e[e.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", e[e.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", e[e.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", e[e.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", e[e.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", e[e.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", e[e.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", e[e.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT"
+})(er || (er = {}));
+var ji = {
         3042: !1,
         32773: new Float32Array([0, 0, 0, 0]),
         32777: 32774,
         34877: 32774,
         32969: 1,
         32968: 0,
         32971: 1,
@@ -15512,604 +15512,604 @@
         3331: 0,
         3314: 0,
         32878: 0,
         3316: 0,
         3315: 0,
         32877: 0
     },
-    ie = (t, e, r) => e ? t.enable(r) : t.disable(r),
-    Pp = (t, e, r) => t.hint(r, e),
-    Pe = (t, e, r) => t.pixelStorei(r, e),
-    Cp = (t, e, r) => {
+    it = (e, t, r) => t ? e.enable(r) : e.disable(r),
+    Cp = (e, t, r) => e.hint(r, t),
+    Pt = (e, t, r) => e.pixelStorei(r, t),
+    Ip = (e, t, r) => {
         let s = r === 36006 ? 36009 : 36008;
-        return t.bindFramebuffer(s, e)
+        return e.bindFramebuffer(s, t)
     },
-    zi = (t, e, r) => {
+    zi = (e, t, r) => {
         let i = {
             34964: 34962,
             36662: 36662,
             36663: 36663,
             35053: 35051,
             35055: 35052
         } [r];
-        t.bindBuffer(i, e)
+        e.bindBuffer(i, t)
     };
 
-function wh(t) {
-    return Array.isArray(t) || ArrayBuffer.isView(t) && !(t instanceof DataView)
+function Rf(e) {
+    return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView)
 }
-var Ip = {
-    3042: ie,
-    32773: (t, e) => t.blendColor(...e),
+var Op = {
+    3042: it,
+    32773: (e, t) => e.blendColor(...t),
     32777: "blendEquation",
     34877: "blendEquation",
     32969: "blendFunc",
     32968: "blendFunc",
     32971: "blendFunc",
     32970: "blendFunc",
-    3106: (t, e) => t.clearColor(...e),
-    3107: (t, e) => t.colorMask(...e),
-    2884: ie,
-    2885: (t, e) => t.cullFace(e),
-    2929: ie,
-    2931: (t, e) => t.clearDepth(e),
-    2932: (t, e) => t.depthFunc(e),
-    2928: (t, e) => t.depthRange(...e),
-    2930: (t, e) => t.depthMask(e),
-    3024: ie,
-    35723: Pp,
-    35725: (t, e) => t.useProgram(e),
-    36007: (t, e) => t.bindRenderbuffer(36161, e),
-    36389: (t, e) => t.bindTransformFeedback?.(36386, e),
-    34229: (t, e) => t.bindVertexArray(e),
-    36006: Cp,
-    36010: Cp,
+    3106: (e, t) => e.clearColor(...t),
+    3107: (e, t) => e.colorMask(...t),
+    2884: it,
+    2885: (e, t) => e.cullFace(t),
+    2929: it,
+    2931: (e, t) => e.clearDepth(t),
+    2932: (e, t) => e.depthFunc(t),
+    2928: (e, t) => e.depthRange(...t),
+    2930: (e, t) => e.depthMask(t),
+    3024: it,
+    35723: Cp,
+    35725: (e, t) => e.useProgram(t),
+    36007: (e, t) => e.bindRenderbuffer(36161, t),
+    36389: (e, t) => e.bindTransformFeedback?.(36386, t),
+    34229: (e, t) => e.bindVertexArray(t),
+    36006: Ip,
+    36010: Ip,
     34964: zi,
     36662: zi,
     36663: zi,
     35053: zi,
     35055: zi,
-    2886: (t, e) => t.frontFace(e),
-    33170: Pp,
-    2849: (t, e) => t.lineWidth(e),
-    32823: ie,
+    2886: (e, t) => e.frontFace(t),
+    33170: Cp,
+    2849: (e, t) => e.lineWidth(t),
+    32823: it,
     32824: "polygonOffset",
     10752: "polygonOffset",
-    35977: ie,
-    32926: ie,
-    32928: ie,
+    35977: it,
+    32926: it,
+    32928: it,
     32938: "sampleCoverage",
     32939: "sampleCoverage",
-    3089: ie,
-    3088: (t, e) => t.scissor(...e),
-    2960: ie,
-    2961: (t, e) => t.clearStencil(e),
-    2968: (t, e) => t.stencilMaskSeparate(1028, e),
-    36005: (t, e) => t.stencilMaskSeparate(1029, e),
+    3089: it,
+    3088: (e, t) => e.scissor(...t),
+    2960: it,
+    2961: (e, t) => e.clearStencil(t),
+    2968: (e, t) => e.stencilMaskSeparate(1028, t),
+    36005: (e, t) => e.stencilMaskSeparate(1029, t),
     2962: "stencilFuncFront",
     2967: "stencilFuncFront",
     2963: "stencilFuncFront",
     34816: "stencilFuncBack",
     36003: "stencilFuncBack",
     36004: "stencilFuncBack",
     2964: "stencilOpFront",
     2965: "stencilOpFront",
     2966: "stencilOpFront",
     34817: "stencilOpBack",
     34818: "stencilOpBack",
     34819: "stencilOpBack",
-    2978: (t, e) => t.viewport(...e),
-    34383: ie,
-    10754: ie,
-    12288: ie,
-    12289: ie,
-    12290: ie,
-    12291: ie,
-    12292: ie,
-    12293: ie,
-    12294: ie,
-    12295: ie,
-    3333: Pe,
-    3317: Pe,
-    37440: Pe,
-    37441: Pe,
-    37443: Pe,
-    3330: Pe,
-    3332: Pe,
-    3331: Pe,
-    3314: Pe,
-    32878: Pe,
-    3316: Pe,
-    3315: Pe,
-    32877: Pe,
-    framebuffer: (t, e) => {
-        let r = e && "handle" in e ? e.handle : e;
-        return t.bindFramebuffer(36160, r)
-    },
-    blend: (t, e) => e ? t.enable(3042) : t.disable(3042),
-    blendColor: (t, e) => t.blendColor(...e),
-    blendEquation: (t, e) => {
-        let r = typeof e == "number" ? [e, e] : e;
-        t.blendEquationSeparate(...r)
-    },
-    blendFunc: (t, e) => {
-        let r = e?.length === 2 ? [...e, ...e] : e;
-        t.blendFuncSeparate(...r)
-    },
-    clearColor: (t, e) => t.clearColor(...e),
-    clearDepth: (t, e) => t.clearDepth(e),
-    clearStencil: (t, e) => t.clearStencil(e),
-    colorMask: (t, e) => t.colorMask(...e),
-    cull: (t, e) => e ? t.enable(2884) : t.disable(2884),
-    cullFace: (t, e) => t.cullFace(e),
-    depthTest: (t, e) => e ? t.enable(2929) : t.disable(2929),
-    depthFunc: (t, e) => t.depthFunc(e),
-    depthMask: (t, e) => t.depthMask(e),
-    depthRange: (t, e) => t.depthRange(...e),
-    dither: (t, e) => e ? t.enable(3024) : t.disable(3024),
-    derivativeHint: (t, e) => {
-        t.hint(35723, e)
-    },
-    frontFace: (t, e) => t.frontFace(e),
-    mipmapHint: (t, e) => t.hint(33170, e),
-    lineWidth: (t, e) => t.lineWidth(e),
-    polygonOffsetFill: (t, e) => e ? t.enable(32823) : t.disable(32823),
-    polygonOffset: (t, e) => t.polygonOffset(...e),
-    sampleCoverage: (t, e) => t.sampleCoverage(...e),
-    scissorTest: (t, e) => e ? t.enable(3089) : t.disable(3089),
-    scissor: (t, e) => t.scissor(...e),
-    stencilTest: (t, e) => e ? t.enable(2960) : t.disable(2960),
-    stencilMask: (t, e) => {
-        e = wh(e) ? e : [e, e];
-        let [r, s] = e;
-        t.stencilMaskSeparate(1028, r), t.stencilMaskSeparate(1029, s)
-    },
-    stencilFunc: (t, e) => {
-        e = wh(e) && e.length === 3 ? [...e, ...e] : e;
-        let [r, s, i, n, o, a] = e;
-        t.stencilFuncSeparate(1028, r, s, i), t.stencilFuncSeparate(1029, n, o, a)
-    },
-    stencilOp: (t, e) => {
-        e = wh(e) && e.length === 3 ? [...e, ...e] : e;
-        let [r, s, i, n, o, a] = e;
-        t.stencilOpSeparate(1028, r, s, i), t.stencilOpSeparate(1029, n, o, a)
-    },
-    viewport: (t, e) => t.viewport(...e)
-};
-
-function ee(t, e, r) {
-    return e[t] !== void 0 ? e[t] : r[t]
-}
-var Op = {
-        blendEquation: (t, e, r) => t.blendEquationSeparate(ee(32777, e, r), ee(34877, e, r)),
-        blendFunc: (t, e, r) => t.blendFuncSeparate(ee(32969, e, r), ee(32968, e, r), ee(32971, e, r), ee(32970, e, r)),
-        polygonOffset: (t, e, r) => t.polygonOffset(ee(32824, e, r), ee(10752, e, r)),
-        sampleCoverage: (t, e, r) => t.sampleCoverage(ee(32938, e, r), ee(32939, e, r)),
-        stencilFuncFront: (t, e, r) => t.stencilFuncSeparate(1028, ee(2962, e, r), ee(2967, e, r), ee(2963, e, r)),
-        stencilFuncBack: (t, e, r) => t.stencilFuncSeparate(1029, ee(34816, e, r), ee(36003, e, r), ee(36004, e, r)),
-        stencilOpFront: (t, e, r) => t.stencilOpSeparate(1028, ee(2964, e, r), ee(2965, e, r), ee(2966, e, r)),
-        stencilOpBack: (t, e, r) => t.stencilOpSeparate(1029, ee(34817, e, r), ee(34818, e, r), ee(34819, e, r))
-    },
-    Rh = {
-        enable: (t, e) => t({
-            [e]: !0
+    2978: (e, t) => e.viewport(...t),
+    34383: it,
+    10754: it,
+    12288: it,
+    12289: it,
+    12290: it,
+    12291: it,
+    12292: it,
+    12293: it,
+    12294: it,
+    12295: it,
+    3333: Pt,
+    3317: Pt,
+    37440: Pt,
+    37441: Pt,
+    37443: Pt,
+    3330: Pt,
+    3332: Pt,
+    3331: Pt,
+    3314: Pt,
+    32878: Pt,
+    3316: Pt,
+    3315: Pt,
+    32877: Pt,
+    framebuffer: (e, t) => {
+        let r = t && "handle" in t ? t.handle : t;
+        return e.bindFramebuffer(36160, r)
+    },
+    blend: (e, t) => t ? e.enable(3042) : e.disable(3042),
+    blendColor: (e, t) => e.blendColor(...t),
+    blendEquation: (e, t) => {
+        let r = typeof t == "number" ? [t, t] : t;
+        e.blendEquationSeparate(...r)
+    },
+    blendFunc: (e, t) => {
+        let r = t?.length === 2 ? [...t, ...t] : t;
+        e.blendFuncSeparate(...r)
+    },
+    clearColor: (e, t) => e.clearColor(...t),
+    clearDepth: (e, t) => e.clearDepth(t),
+    clearStencil: (e, t) => e.clearStencil(t),
+    colorMask: (e, t) => e.colorMask(...t),
+    cull: (e, t) => t ? e.enable(2884) : e.disable(2884),
+    cullFace: (e, t) => e.cullFace(t),
+    depthTest: (e, t) => t ? e.enable(2929) : e.disable(2929),
+    depthFunc: (e, t) => e.depthFunc(t),
+    depthMask: (e, t) => e.depthMask(t),
+    depthRange: (e, t) => e.depthRange(...t),
+    dither: (e, t) => t ? e.enable(3024) : e.disable(3024),
+    derivativeHint: (e, t) => {
+        e.hint(35723, t)
+    },
+    frontFace: (e, t) => e.frontFace(t),
+    mipmapHint: (e, t) => e.hint(33170, t),
+    lineWidth: (e, t) => e.lineWidth(t),
+    polygonOffsetFill: (e, t) => t ? e.enable(32823) : e.disable(32823),
+    polygonOffset: (e, t) => e.polygonOffset(...t),
+    sampleCoverage: (e, t) => e.sampleCoverage(...t),
+    scissorTest: (e, t) => t ? e.enable(3089) : e.disable(3089),
+    scissor: (e, t) => e.scissor(...t),
+    stencilTest: (e, t) => t ? e.enable(2960) : e.disable(2960),
+    stencilMask: (e, t) => {
+        t = Rf(t) ? t : [t, t];
+        let [r, s] = t;
+        e.stencilMaskSeparate(1028, r), e.stencilMaskSeparate(1029, s)
+    },
+    stencilFunc: (e, t) => {
+        t = Rf(t) && t.length === 3 ? [...t, ...t] : t;
+        let [r, s, i, n, o, a] = t;
+        e.stencilFuncSeparate(1028, r, s, i), e.stencilFuncSeparate(1029, n, o, a)
+    },
+    stencilOp: (e, t) => {
+        t = Rf(t) && t.length === 3 ? [...t, ...t] : t;
+        let [r, s, i, n, o, a] = t;
+        e.stencilOpSeparate(1028, r, s, i), e.stencilOpSeparate(1029, n, o, a)
+    },
+    viewport: (e, t) => e.viewport(...t)
+};
+
+function tt(e, t, r) {
+    return t[e] !== void 0 ? t[e] : r[e]
+}
+var Np = {
+        blendEquation: (e, t, r) => e.blendEquationSeparate(tt(32777, t, r), tt(34877, t, r)),
+        blendFunc: (e, t, r) => e.blendFuncSeparate(tt(32969, t, r), tt(32968, t, r), tt(32971, t, r), tt(32970, t, r)),
+        polygonOffset: (e, t, r) => e.polygonOffset(tt(32824, t, r), tt(10752, t, r)),
+        sampleCoverage: (e, t, r) => e.sampleCoverage(tt(32938, t, r), tt(32939, t, r)),
+        stencilFuncFront: (e, t, r) => e.stencilFuncSeparate(1028, tt(2962, t, r), tt(2967, t, r), tt(2963, t, r)),
+        stencilFuncBack: (e, t, r) => e.stencilFuncSeparate(1029, tt(34816, t, r), tt(36003, t, r), tt(36004, t, r)),
+        stencilOpFront: (e, t, r) => e.stencilOpSeparate(1028, tt(2964, t, r), tt(2965, t, r), tt(2966, t, r)),
+        stencilOpBack: (e, t, r) => e.stencilOpSeparate(1029, tt(34817, t, r), tt(34818, t, r), tt(34819, t, r))
+    },
+    vf = {
+        enable: (e, t) => e({
+            [t]: !0
         }),
-        disable: (t, e) => t({
-            [e]: !1
+        disable: (e, t) => e({
+            [t]: !1
         }),
-        pixelStorei: (t, e, r) => t({
-            [e]: r
+        pixelStorei: (e, t, r) => e({
+            [t]: r
         }),
-        hint: (t, e, r) => t({
-            [e]: r
+        hint: (e, t, r) => e({
+            [t]: r
         }),
-        useProgram: (t, e) => t({
-            35725: e
+        useProgram: (e, t) => e({
+            35725: t
         }),
-        bindRenderbuffer: (t, e, r) => t({
+        bindRenderbuffer: (e, t, r) => e({
             36007: r
         }),
-        bindTransformFeedback: (t, e, r) => t({
+        bindTransformFeedback: (e, t, r) => e({
             36389: r
         }),
-        bindVertexArray: (t, e) => t({
-            34229: e
+        bindVertexArray: (e, t) => e({
+            34229: t
         }),
-        bindFramebuffer: (t, e, r) => {
-            switch (e) {
+        bindFramebuffer: (e, t, r) => {
+            switch (t) {
                 case 36160:
-                    return t({
+                    return e({
                         36006: r,
                         36010: r
                     });
                 case 36009:
-                    return t({
+                    return e({
                         36006: r
                     });
                 case 36008:
-                    return t({
+                    return e({
                         36010: r
                     });
                 default:
                     return null
             }
         },
-        bindBuffer: (t, e, r) => {
+        bindBuffer: (e, t, r) => {
             let s = {
                 34962: [34964],
                 36662: [36662],
                 36663: [36663],
                 35051: [35053],
                 35052: [35055]
-            } [e];
-            return s ? t({
+            } [t];
+            return s ? e({
                 [s]: r
             }) : {
                 valueChanged: !0
             }
         },
-        blendColor: (t, e, r, s, i) => t({
-            32773: new Float32Array([e, r, s, i])
+        blendColor: (e, t, r, s, i) => e({
+            32773: new Float32Array([t, r, s, i])
         }),
-        blendEquation: (t, e) => t({
-            32777: e,
-            34877: e
+        blendEquation: (e, t) => e({
+            32777: t,
+            34877: t
         }),
-        blendEquationSeparate: (t, e, r) => t({
-            32777: e,
+        blendEquationSeparate: (e, t, r) => e({
+            32777: t,
             34877: r
         }),
-        blendFunc: (t, e, r) => t({
-            32969: e,
+        blendFunc: (e, t, r) => e({
+            32969: t,
             32968: r,
-            32971: e,
+            32971: t,
             32970: r
         }),
-        blendFuncSeparate: (t, e, r, s, i) => t({
-            32969: e,
+        blendFuncSeparate: (e, t, r, s, i) => e({
+            32969: t,
             32968: r,
             32971: s,
             32970: i
         }),
-        clearColor: (t, e, r, s, i) => t({
-            3106: new Float32Array([e, r, s, i])
+        clearColor: (e, t, r, s, i) => e({
+            3106: new Float32Array([t, r, s, i])
         }),
-        clearDepth: (t, e) => t({
-            2931: e
+        clearDepth: (e, t) => e({
+            2931: t
         }),
-        clearStencil: (t, e) => t({
-            2961: e
+        clearStencil: (e, t) => e({
+            2961: t
         }),
-        colorMask: (t, e, r, s, i) => t({
-            3107: [e, r, s, i]
+        colorMask: (e, t, r, s, i) => e({
+            3107: [t, r, s, i]
         }),
-        cullFace: (t, e) => t({
-            2885: e
+        cullFace: (e, t) => e({
+            2885: t
         }),
-        depthFunc: (t, e) => t({
-            2932: e
+        depthFunc: (e, t) => e({
+            2932: t
         }),
-        depthRange: (t, e, r) => t({
-            2928: new Float32Array([e, r])
+        depthRange: (e, t, r) => e({
+            2928: new Float32Array([t, r])
         }),
-        depthMask: (t, e) => t({
-            2930: e
+        depthMask: (e, t) => e({
+            2930: t
         }),
-        frontFace: (t, e) => t({
-            2886: e
+        frontFace: (e, t) => e({
+            2886: t
         }),
-        lineWidth: (t, e) => t({
-            2849: e
+        lineWidth: (e, t) => e({
+            2849: t
         }),
-        polygonOffset: (t, e, r) => t({
-            32824: e,
+        polygonOffset: (e, t, r) => e({
+            32824: t,
             10752: r
         }),
-        sampleCoverage: (t, e, r) => t({
-            32938: e,
+        sampleCoverage: (e, t, r) => e({
+            32938: t,
             32939: r
         }),
-        scissor: (t, e, r, s, i) => t({
-            3088: new Int32Array([e, r, s, i])
+        scissor: (e, t, r, s, i) => e({
+            3088: new Int32Array([t, r, s, i])
         }),
-        stencilMask: (t, e) => t({
-            2968: e,
-            36005: e
+        stencilMask: (e, t) => e({
+            2968: t,
+            36005: t
         }),
-        stencilMaskSeparate: (t, e, r) => t({
-            [e === 1028 ? 2968 : 36005]: r
+        stencilMaskSeparate: (e, t, r) => e({
+            [t === 1028 ? 2968 : 36005]: r
         }),
-        stencilFunc: (t, e, r, s) => t({
-            2962: e,
+        stencilFunc: (e, t, r, s) => e({
+            2962: t,
             2967: r,
             2963: s,
-            34816: e,
+            34816: t,
             36003: r,
             36004: s
         }),
-        stencilFuncSeparate: (t, e, r, s, i) => t({
-            [e === 1028 ? 2962 : 34816]: r,
-            [e === 1028 ? 2967 : 36003]: s,
-            [e === 1028 ? 2963 : 36004]: i
+        stencilFuncSeparate: (e, t, r, s, i) => e({
+            [t === 1028 ? 2962 : 34816]: r,
+            [t === 1028 ? 2967 : 36003]: s,
+            [t === 1028 ? 2963 : 36004]: i
         }),
-        stencilOp: (t, e, r, s) => t({
-            2964: e,
+        stencilOp: (e, t, r, s) => e({
+            2964: t,
             2965: r,
             2966: s,
-            34817: e,
+            34817: t,
             34818: r,
             34819: s
         }),
-        stencilOpSeparate: (t, e, r, s, i) => t({
-            [e === 1028 ? 2964 : 34817]: r,
-            [e === 1028 ? 2965 : 34818]: s,
-            [e === 1028 ? 2966 : 34819]: i
+        stencilOpSeparate: (e, t, r, s, i) => e({
+            [t === 1028 ? 2964 : 34817]: r,
+            [t === 1028 ? 2965 : 34818]: s,
+            [t === 1028 ? 2966 : 34819]: i
         }),
-        viewport: (t, e, r, s, i) => t({
-            2978: [e, r, s, i]
+        viewport: (e, t, r, s, i) => e({
+            2978: [t, r, s, i]
         })
     },
-    pt = (t, e) => t.isEnabled(e),
-    vh = {
-        3042: pt,
-        2884: pt,
-        2929: pt,
-        3024: pt,
-        32823: pt,
-        32926: pt,
-        32928: pt,
-        3089: pt,
-        2960: pt,
-        35977: pt
+    pe = (e, t) => e.isEnabled(t),
+    Mf = {
+        3042: pe,
+        2884: pe,
+        2929: pe,
+        3024: pe,
+        32823: pe,
+        32926: pe,
+        32928: pe,
+        3089: pe,
+        2960: pe,
+        35977: pe
     },
-    Np = new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
+    Fp = new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
 
-function Ke(t, e) {
-    if (MA(e)) return;
+function Kt(e, t) {
+    if (CA(t)) return;
     let r = {};
-    for (let i in e) {
+    for (let i in t) {
         let n = Number(i),
-            o = Ip[i];
-        o && (typeof o == "string" ? r[o] = !0 : o(t, e[i], n))
+            o = Op[i];
+        o && (typeof o == "string" ? r[o] = !0 : o(e, t[i], n))
     }
-    let s = t.state && t.state.cache;
+    let s = e.state && e.state.cache;
     if (s)
         for (let i in r) {
-            let n = Op[i];
-            n(t, e, s)
+            let n = Np[i];
+            n(e, t, s)
         }
 }
 
-function ta(t, e = Hi) {
-    if (typeof e == "number") {
-        let i = e,
-            n = vh[i];
-        return n ? n(t, i) : t.getParameter(i)
+function ea(e, t = ji) {
+    if (typeof t == "number") {
+        let i = t,
+            n = Mf[i];
+        return n ? n(e, i) : e.getParameter(i)
     }
-    let r = Array.isArray(e) ? e : Object.keys(e),
+    let r = Array.isArray(t) ? t : Object.keys(t),
         s = {};
     for (let i of r) {
-        let n = vh[i];
-        s[i] = n ? n(t, Number(i)) : t.getParameter(Number(i))
+        let n = Mf[i];
+        s[i] = n ? n(e, Number(i)) : e.getParameter(Number(i))
     }
     return s
 }
 
-function Fp(t) {
-    Ke(t, Hi)
+function kp(e) {
+    Kt(e, ji)
 }
 
-function MA(t) {
-    for (let e in t) return !1;
+function CA(e) {
+    for (let t in e) return !1;
     return !0
 }
 
-function Dp(t, e) {
-    if (t === e) return !0;
-    let r = Array.isArray(t) || ArrayBuffer.isView(t),
-        s = Array.isArray(e) || ArrayBuffer.isView(e);
-    if (r && s && t.length === e.length) {
-        for (let i = 0; i < t.length; ++i)
-            if (t[i] !== e[i]) return !1;
+function Dp(e, t) {
+    if (e === t) return !0;
+    let r = Array.isArray(e) || ArrayBuffer.isView(e),
+        s = Array.isArray(t) || ArrayBuffer.isView(t);
+    if (r && s && e.length === t.length) {
+        for (let i = 0; i < e.length; ++i)
+            if (e[i] !== t[i]) return !1;
         return !0
     }
     return !1
 }
-var Mh = class {
-    constructor(e, {
+var Pf = class {
+    constructor(t, {
         copyState: r = !1,
         log: s = () => {}
     } = {}) {
-        f(this, "gl");
-        f(this, "program", null);
-        f(this, "stateStack", []);
-        f(this, "enable", !0);
-        f(this, "cache");
-        f(this, "log");
-        this.gl = e, this.cache = r ? ta(e) : Object.assign({}, Hi), this.log = s, this._updateCache = this._updateCache.bind(this), Object.seal(this)
+        h(this, "gl");
+        h(this, "program", null);
+        h(this, "stateStack", []);
+        h(this, "enable", !0);
+        h(this, "cache");
+        h(this, "log");
+        this.gl = t, this.cache = r ? ea(t) : Object.assign({}, ji), this.log = s, this._updateCache = this._updateCache.bind(this), Object.seal(this)
     }
-    push(e = {}) {
+    push(t = {}) {
         this.stateStack.push({})
     }
     pop() {
         z(this.stateStack.length > 0);
-        let e = this.stateStack[this.stateStack.length - 1];
-        Ke(this.gl, e), this.stateStack.pop()
+        let t = this.stateStack[this.stateStack.length - 1];
+        Kt(this.gl, t), this.stateStack.pop()
     }
-    _updateCache(e) {
+    _updateCache(t) {
         let r = !1,
             s, i = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
-        for (let n in e) {
+        for (let n in t) {
             z(n !== void 0);
-            let o = e[n],
+            let o = t[n],
                 a = this.cache[n];
             Dp(o, a) || (r = !0, s = a, i && !(n in i) && (i[n] = a), this.cache[n] = o)
         }
         return {
             valueChanged: r,
             oldValue: s
         }
     }
 };
 
-function Fr(t) {
-    return t.state
+function Fr(e) {
+    return e.state
 }
 
-function Ph(t, e) {
+function Cf(e, t) {
     let {
         enable: r = !0,
         copyState: s
-    } = e;
-    if (z(s !== void 0), !t.state) {
-        t.state = new Mh(t, {
+    } = t;
+    if (z(s !== void 0), !e.state) {
+        e.state = new Pf(e, {
             copyState: s
-        }), CA(t);
-        for (let n in Rh) {
-            let o = Rh[n];
-            PA(t, n, o)
+        }), OA(e);
+        for (let n in vf) {
+            let o = vf[n];
+            IA(e, n, o)
         }
-        kp(t, "getParameter"), kp(t, "isEnabled")
+        Bp(e, "getParameter"), Bp(e, "isEnabled")
     }
-    let i = Fr(t);
-    return i.enable = r, t
+    let i = Fr(e);
+    return i.enable = r, e
 }
 
-function rr(t) {
-    let e = Fr(t);
-    e || (Ph(t, {
+function rr(e) {
+    let t = Fr(e);
+    t || (Cf(e, {
         copyState: !1
-    }), e = Fr(t)), e.push()
+    }), t = Fr(e)), t.push()
 }
 
-function Ot(t) {
-    let e = Fr(t);
-    z(e), e.pop()
+function Oe(e) {
+    let t = Fr(e);
+    z(t), t.pop()
 }
 
-function kp(t, e) {
-    let r = t[e].bind(t);
-    t[e] = function(i) {
-        if (i === void 0 || Np.has(i)) return r(i);
-        let n = Fr(t);
+function Bp(e, t) {
+    let r = e[t].bind(e);
+    e[t] = function(i) {
+        if (i === void 0 || Fp.has(i)) return r(i);
+        let n = Fr(e);
         return i in n.cache || (n.cache[i] = r(i)), n.enable ? n.cache[i] : r(i)
-    }, Object.defineProperty(t[e], "name", {
-        value: `${e}-from-cache`,
+    }, Object.defineProperty(e[t], "name", {
+        value: `${t}-from-cache`,
         configurable: !1
     })
 }
 
-function PA(t, e, r) {
-    if (!t[e]) return;
-    let s = t[e].bind(t);
-    t[e] = function(...n) {
-        let o = Fr(t),
+function IA(e, t, r) {
+    if (!e[t]) return;
+    let s = e[t].bind(e);
+    e[t] = function(...n) {
+        let o = Fr(e),
             {
                 valueChanged: a,
                 oldValue: c
             } = r(o._updateCache, ...n);
         return a && s(...n), c
-    }, Object.defineProperty(t[e], "name", {
-        value: `${e}-to-cache`,
+    }, Object.defineProperty(e[t], "name", {
+        value: `${t}-to-cache`,
         configurable: !1
     })
 }
 
-function CA(t) {
-    let e = t.useProgram.bind(t);
-    t.useProgram = function(s) {
-        let i = Fr(t);
-        i.program !== s && (e(s), i.program = s)
+function OA(e) {
+    let t = e.useProgram.bind(e);
+    e.useProgram = function(s) {
+        let i = Fr(e);
+        i.program !== s && (t(s), i.program = s)
     }
 }
-var IA = {
+var NA = {
     powerPreference: "high-performance",
     onContextLost: () => console.error("WebGL context lost"),
     onContextRestored: () => console.info("WebGL context restored")
 };
 
-function Bp(t, e) {
-    e = {
-        ...IA,
-        ...e
+function Up(e, t) {
+    t = {
+        ...NA,
+        ...t
     };
     let r = null,
         s = n => r = n.statusMessage || r;
-    t.addEventListener("webglcontextcreationerror", s, !1);
+    e.addEventListener("webglcontextcreationerror", s, !1);
     let i = null;
-    if (i || (i = t.getContext("webgl2", e)), t.removeEventListener("webglcontextcreationerror", s, !1), !i) throw new Error(`Failed to create WebGL context: ${r||"Unknown error"}`);
-    if (e.onContextLost) {
+    if (i || (i = e.getContext("webgl2", t)), e.removeEventListener("webglcontextcreationerror", s, !1), !i) throw new Error(`Failed to create WebGL context: ${r||"Unknown error"}`);
+    if (t.onContextLost) {
         let {
             onContextLost: n
-        } = e;
-        t.addEventListener("webglcontextlost", o => n(o), !1)
+        } = t;
+        e.addEventListener("webglcontextlost", o => n(o), !1)
     }
-    if (e.onContextRestored) {
+    if (t.onContextRestored) {
         let {
             onContextRestored: n
-        } = e;
-        t.addEventListener("webglcontextrestored", o => n(o), !1)
+        } = t;
+        e.addEventListener("webglcontextrestored", o => n(o), !1)
     }
     return i
 }
 
-function ze(t, e, r) {
-    return r[e] === void 0 && (r[e] = t.getExtension(e) || null), r[e]
+function zt(e, t, r) {
+    return r[t] === void 0 && (r[t] = e.getExtension(t) || null), r[t]
 }
 
-function Up(t, e) {
-    let r = t.getParameter(7936),
-        s = t.getParameter(7937);
-    ze(t, "WEBGL_debug_renderer_info", e);
-    let i = e.WEBGL_debug_renderer_info,
-        n = t.getParameter(i ? i.UNMASKED_VENDOR_WEBGL : 7936),
-        o = t.getParameter(i ? i.UNMASKED_RENDERER_WEBGL : 7937),
+function Lp(e, t) {
+    let r = e.getParameter(7936),
+        s = e.getParameter(7937);
+    zt(e, "WEBGL_debug_renderer_info", t);
+    let i = t.WEBGL_debug_renderer_info,
+        n = e.getParameter(i ? i.UNMASKED_VENDOR_WEBGL : 7936),
+        o = e.getParameter(i ? i.UNMASKED_RENDERER_WEBGL : 7937),
         a = n || r,
         c = o || s,
-        l = t.getParameter(7938),
-        h = Lp(a, c),
-        d = OA(a, c),
-        p = NA(a, c);
+        l = e.getParameter(7938),
+        f = Vp(a, c),
+        d = FA(a, c),
+        p = kA(a, c);
     return {
         type: "webgl",
-        gpu: h,
+        gpu: f,
         gpuType: p,
         gpuBackend: d,
         vendor: a,
         renderer: c,
         version: l,
         shadingLanguage: "glsl",
         shadingLanguageVersion: 300
     }
 }
 
-function Lp(t, e) {
-    return /NVIDIA/i.exec(t) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(t) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(t) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(t) || /AMD/i.exec(e) || /ATI/i.exec(t) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(t) || /SwiftShader/i.exec(e) ? "software" : "unknown"
+function Vp(e, t) {
+    return /NVIDIA/i.exec(e) || /NVIDIA/i.exec(t) ? "nvidia" : /INTEL/i.exec(e) || /INTEL/i.exec(t) ? "intel" : /Apple/i.exec(e) || /Apple/i.exec(t) ? "apple" : /AMD/i.exec(e) || /AMD/i.exec(t) || /ATI/i.exec(e) || /ATI/i.exec(t) ? "amd" : /SwiftShader/i.exec(e) || /SwiftShader/i.exec(t) ? "software" : "unknown"
 }
 
-function OA(t, e) {
-    return /Metal/i.exec(t) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(t) || /ANGLE/i.exec(e) ? "opengl" : "unknown"
+function FA(e, t) {
+    return /Metal/i.exec(e) || /Metal/i.exec(t) ? "metal" : /ANGLE/i.exec(e) || /ANGLE/i.exec(t) ? "opengl" : "unknown"
 }
 
-function NA(t, e) {
-    if (/SwiftShader/i.exec(t) || /SwiftShader/i.exec(e)) return "cpu";
-    switch (Lp(t, e)) {
+function kA(e, t) {
+    if (/SwiftShader/i.exec(e) || /SwiftShader/i.exec(t)) return "cpu";
+    switch (Vp(e, t)) {
         case "intel":
             return "integrated";
         case "software":
             return "cpu";
         case "unknown":
             return "unknown";
         default:
             return "discrete"
     }
 }
 
-function ra(t) {
-    switch (t) {
+function ra(e) {
+    switch (e) {
         case "uint8":
             return 5121;
         case "sint8":
             return 5120;
         case "unorm8":
             return 5121;
         case "snorm8":
@@ -16127,69 +16127,69 @@
         case "sint32":
             return 5124;
         case "float16":
             return 5131;
         case "float32":
             return 5126
     }
-    throw new Error(String(t))
+    throw new Error(String(e))
 }
-var me = "texture-compression-bc",
+var mt = "texture-compression-bc",
     Z = "texture-compression-astc",
-    gt = "texture-compression-etc2",
-    FA = "texture-compression-etc1-webgl",
+    _e = "texture-compression-etc2",
+    DA = "texture-compression-etc1-webgl",
     sa = "texture-compression-pvrtc-webgl",
-    Ch = "texture-compression-atc-webgl",
-    ji = "float32-renderable-webgl",
-    Ih = "float16-renderable-webgl",
-    DA = "rgb9e5ufloat_renderable-webgl",
-    Oh = "snorm8-renderable-webgl",
+    If = "texture-compression-atc-webgl",
+    Hi = "float32-renderable-webgl",
+    Of = "float16-renderable-webgl",
+    BA = "rgb9e5ufloat_renderable-webgl",
+    Nf = "snorm8-renderable-webgl",
     Xi = "norm16-renderable-webgl",
-    Nh = "snorm16-renderable-webgl",
+    Ff = "snorm16-renderable-webgl",
     ia = "float32-filterable",
-    Vp = "float16-filterable-webgl",
+    Wp = "float16-filterable-webgl",
     $i = "WEBGL_compressed_texture_s3tc",
     Yi = "WEBGL_compressed_texture_s3tc_srgb",
     As = "EXT_texture_compression_rgtc",
-    xs = "EXT_texture_compression_bptc",
-    kA = "WEBGL_compressed_texture_etc",
-    BA = "WEBGL_compressed_texture_astc",
-    UA = "WEBGL_compressed_texture_etc1",
-    LA = "WEBGL_compressed_texture_pvrtc",
-    VA = "WEBGL_compressed_texture_atc",
-    Wp = "EXT_texture_norm16",
-    zp = "EXT_render_snorm",
-    WA = "EXT_color_buffer_float",
+    Es = "EXT_texture_compression_bptc",
+    UA = "WEBGL_compressed_texture_etc",
+    LA = "WEBGL_compressed_texture_astc",
+    VA = "WEBGL_compressed_texture_etc1",
+    WA = "WEBGL_compressed_texture_pvrtc",
+    zA = "WEBGL_compressed_texture_atc",
+    zp = "EXT_texture_norm16",
+    jp = "EXT_render_snorm",
+    jA = "EXT_color_buffer_float",
     na = {
         "float32-renderable-webgl": ["EXT_color_buffer_float"],
         "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
         "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
-        "snorm8-renderable-webgl": [zp],
-        "norm16-renderable-webgl": [Wp],
-        "snorm16-renderable-webgl": [Wp, zp],
+        "snorm8-renderable-webgl": [jp],
+        "norm16-renderable-webgl": [zp],
+        "snorm16-renderable-webgl": [zp, jp],
         "float32-filterable": ["OES_texture_float_linear"],
         "float16-filterable-webgl": ["OES_texture_half_float_linear"],
         "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
         "texture-blend-float-webgl": ["EXT_float_blend"],
-        "texture-compression-bc": [$i, Yi, As, xs],
+        "texture-compression-bc": [$i, Yi, As, Es],
         "texture-compression-bc5-webgl": [As],
-        "texture-compression-bc7-webgl": [xs],
-        "texture-compression-etc2": [kA],
-        "texture-compression-astc": [BA],
-        "texture-compression-etc1-webgl": [UA],
-        "texture-compression-pvrtc-webgl": [LA],
-        "texture-compression-atc-webgl": [VA]
+        "texture-compression-bc7-webgl": [Es],
+        "texture-compression-etc2": [UA],
+        "texture-compression-astc": [LA],
+        "texture-compression-etc1-webgl": [VA],
+        "texture-compression-pvrtc-webgl": [WA],
+        "texture-compression-atc-webgl": [zA]
     };
 
-function Hp(t) {
-    return t in na
+function Hp(e) {
+    return e in na
 }
 
-function jp(t, e, r) {
-    return (na[e] || []).every(i => ze(t, i, r))
+function Xp(e, t, r) {
+    return (na[t] || []).every(i => zt(e, i, r))
 }
 var oa = {
         "rgb8unorm-unsized": {
             gl: 6407,
             b: 4,
             c: 2,
             bpp: 4,
@@ -16210,15 +16210,15 @@
             c: 1,
             rb: !0
         },
         r8snorm: {
             gl: 36756,
             b: 1,
             c: 1,
-            render: Oh
+            render: Nf
         },
         r8uint: {
             gl: 33330,
             b: 1,
             c: 1,
             rb: !0
         },
@@ -16234,15 +16234,15 @@
             c: 2,
             rb: !0
         },
         rg8snorm: {
             gl: 36757,
             b: 2,
             c: 2,
-            render: Oh
+            render: Nf
         },
         rg8uint: {
             gl: 33336,
             b: 2,
             c: 2,
             rb: !0
         },
@@ -16264,30 +16264,30 @@
             c: 1,
             rb: !0
         },
         r16float: {
             gl: 33325,
             b: 2,
             c: 1,
-            render: Ih,
+            render: Of,
             filter: "float16-filterable-webgl",
             rb: !0
         },
         "r16unorm-webgl": {
             gl: 33322,
             b: 2,
             c: 1,
             f: Xi,
             rb: !0
         },
         "r16snorm-webgl": {
             gl: 36760,
             b: 2,
             c: 1,
-            f: Nh
+            f: Ff
         },
         "rgba4unorm-webgl": {
             gl: 32854,
             b: 2,
             c: 4,
             wgpu: !1,
             rb: !0
@@ -16330,15 +16330,15 @@
             c: 4,
             bpp: 4
         },
         rgba8snorm: {
             gl: 36759,
             b: 4,
             c: 4,
-            render: Oh
+            render: Nf
         },
         rgba8uint: {
             gl: 36220,
             b: 4,
             c: 4,
             bpp: 4
         },
@@ -16369,29 +16369,29 @@
             bpp: 4
         },
         rg16float: {
             gl: 33327,
             bpp: 4,
             b: 4,
             c: 2,
-            render: Ih,
-            filter: Vp,
+            render: Of,
+            filter: Wp,
             rb: !0
         },
         "rg16unorm-webgl": {
             gl: 33324,
             b: 2,
             c: 2,
             render: Xi
         },
         "rg16snorm-webgl": {
             gl: 36761,
             b: 2,
             c: 2,
-            render: Nh
+            render: Ff
         },
         r32uint: {
             gl: 33334,
             b: 4,
             c: 1,
             bpp: 4,
             rb: !0
@@ -16404,30 +16404,30 @@
             rb: !0
         },
         r32float: {
             gl: 33326,
             bpp: 4,
             b: 4,
             c: 1,
-            render: ji,
+            render: Hi,
             filter: ia
         },
         rgb9e5ufloat: {
             gl: 35901,
             b: 4,
             c: 3,
             p: 1,
-            render: DA
+            render: BA
         },
         rg11b10ufloat: {
             gl: 35898,
             b: 4,
             c: 3,
             p: 1,
-            render: ji,
+            render: Hi,
             rb: !0
         },
         rgb10a2unorm: {
             gl: 32857,
             b: 4,
             c: 4,
             p: 1,
@@ -16466,15 +16466,15 @@
             c: 2,
             rb: !0
         },
         rg32float: {
             gl: 33328,
             b: 8,
             c: 2,
-            render: ji,
+            render: Hi,
             filter: ia,
             rb: !0
         },
         rgba16uint: {
             gl: 36214,
             b: 8,
             c: 4,
@@ -16486,35 +16486,35 @@
             c: 4,
             rb: !0
         },
         rgba16float: {
             gl: 34842,
             b: 8,
             c: 4,
-            render: Ih,
-            filter: Vp
+            render: Of,
+            filter: Wp
         },
         "rgba16unorm-webgl": {
             gl: 32859,
             b: 2,
             c: 4,
             render: Xi,
             rb: !0
         },
         "rgba16snorm-webgl": {
             gl: 36763,
             b: 2,
             c: 4,
-            render: Nh
+            render: Ff
         },
         "rgb32float-webgl": {
             gl: 34837,
-            render: ji,
+            render: Hi,
             filter: ia,
-            gl2ext: WA,
+            gl2ext: jA,
             dataFormat: 6407,
             types: [5126]
         },
         rgba32uint: {
             gl: 36208,
             b: 16,
             c: 4,
@@ -16526,15 +16526,15 @@
             c: 4,
             rb: !0
         },
         rgba32float: {
             gl: 34836,
             b: 16,
             c: 4,
-            render: ji,
+            render: Hi,
             filter: ia,
             rb: !0
         },
         stencil8: {
             gl: 36168,
             b: 1,
             c: 1,
@@ -16597,130 +16597,130 @@
             dataFormat: 34041,
             types: [36269],
             rb: !0
         },
         "bc1-rgb-unorm-webgl": {
             gl: 33776,
             x: $i,
-            f: me
+            f: mt
         },
         "bc1-rgb-unorm-srgb-webgl": {
             gl: 35916,
             x: Yi,
-            f: me
+            f: mt
         },
         "bc1-rgba-unorm": {
             gl: 33777,
             x: $i,
-            f: me
+            f: mt
         },
         "bc1-rgba-unorm-srgb": {
             gl: 35916,
             x: Yi,
-            f: me
+            f: mt
         },
         "bc2-rgba-unorm": {
             gl: 33778,
             x: $i,
-            f: me
+            f: mt
         },
         "bc2-rgba-unorm-srgb": {
             gl: 35918,
             x: Yi,
-            f: me
+            f: mt
         },
         "bc3-rgba-unorm": {
             gl: 33779,
             x: $i,
-            f: me
+            f: mt
         },
         "bc3-rgba-unorm-srgb": {
             gl: 35919,
             x: Yi,
-            f: me
+            f: mt
         },
         "bc4-r-unorm": {
             gl: 36283,
             x: As,
-            f: me
+            f: mt
         },
         "bc4-r-snorm": {
             gl: 36284,
             x: As,
-            f: me
+            f: mt
         },
         "bc5-rg-unorm": {
             gl: 36285,
             x: As,
-            f: me
+            f: mt
         },
         "bc5-rg-snorm": {
             gl: 36286,
             x: As,
-            f: me
+            f: mt
         },
         "bc6h-rgb-ufloat": {
             gl: 36495,
-            x: xs,
-            f: me
+            x: Es,
+            f: mt
         },
         "bc6h-rgb-float": {
             gl: 36494,
-            x: xs,
-            f: me
+            x: Es,
+            f: mt
         },
         "bc7-rgba-unorm": {
             gl: 36492,
-            x: xs,
-            f: me
+            x: Es,
+            f: mt
         },
         "bc7-rgba-unorm-srgb": {
             gl: 36493,
-            x: xs,
-            f: me
+            x: Es,
+            f: mt
         },
         "etc2-rgb8unorm": {
             gl: 37492,
-            f: gt
+            f: _e
         },
         "etc2-rgb8unorm-srgb": {
             gl: 37494,
-            f: gt
+            f: _e
         },
         "etc2-rgb8a1unorm": {
             gl: 37496,
-            f: gt
+            f: _e
         },
         "etc2-rgb8a1unorm-srgb": {
             gl: 37497,
-            f: gt
+            f: _e
         },
         "etc2-rgba8unorm": {
             gl: 37493,
-            f: gt
+            f: _e
         },
         "etc2-rgba8unorm-srgb": {
             gl: 37495,
-            f: gt
+            f: _e
         },
         "eac-r11unorm": {
             gl: 37488,
-            f: gt
+            f: _e
         },
         "eac-r11snorm": {
             gl: 37489,
-            f: gt
+            f: _e
         },
         "eac-rg11unorm": {
             gl: 37490,
-            f: gt
+            f: _e
         },
         "eac-rg11snorm": {
             gl: 37491,
-            f: gt
+            f: _e
         },
         "astc-4x4-unorm": {
             gl: 37808,
             f: Z
         },
         "astc-4x4-unorm-srgb": {
             gl: 37840,
@@ -16844,164 +16844,164 @@
         },
         "pvrtc-rgba2unorm-webgl": {
             gl: 35843,
             f: sa
         },
         "etc1-rbg-unorm-webgl": {
             gl: 36196,
-            f: FA
+            f: DA
         },
         "atc-rgb-unorm-webgl": {
             gl: 35986,
-            f: Ch
+            f: If
         },
         "atc-rgba-unorm-webgl": {
             gl: 35986,
-            f: Ch
+            f: If
         },
         "atc-rgbai-unorm-webgl": {
             gl: 34798,
-            f: Ch
+            f: If
         }
     },
-    zA = {
+    HA = {
         6403: 1,
         36244: 1,
         33319: 2,
         33320: 2,
         6407: 3,
         36248: 3,
         6408: 4,
         36249: 4,
         6402: 1,
         34041: 1,
         6406: 1,
         6409: 1,
         6410: 2
     },
-    HA = {
+    XA = {
         5126: 4,
         5125: 4,
         5124: 4,
         5123: 2,
         5122: 2,
         5131: 2,
         5120: 1,
         5121: 1
     };
 
-function aa(t, e, r) {
-    let s = oa[e];
+function aa(e, t, r) {
+    let s = oa[t];
     if (!s || s.gl === void 0) return !1;
     let i = s.x || s.gl2ext;
-    return i ? !!ze(t, i, r) : !0
+    return i ? !!zt(e, i, r) : !0
 }
 
-function Fh(t) {
-    let r = oa[t]?.gl;
-    if (r === void 0) throw new Error(`Unsupported texture format ${t}`);
+function kf(e) {
+    let r = oa[e]?.gl;
+    if (r === void 0) throw new Error(`Unsupported texture format ${e}`);
     return r
 }
 
-function Xp(t, e, r) {
-    if (!aa(t, e, r) || e.startsWith("depth") || e.startsWith("stencil")) return !1;
+function $p(e, t, r) {
+    if (!aa(e, t, r) || t.startsWith("depth") || t.startsWith("stencil")) return !1;
     try {
-        if (Hn(e).signed) return !1
+        if (jn(t).signed) return !1
     } catch {
         return !1
     }
-    return e.endsWith("32float") ? !!ze(t, "OES_texture_float_linear, extensions", r) : e.endsWith("16float") ? !!ze(t, "OES_texture_half_float_linear, extensions", r) : !0
+    return t.endsWith("32float") ? !!zt(e, "OES_texture_float_linear, extensions", r) : t.endsWith("16float") ? !!zt(e, "OES_texture_half_float_linear, extensions", r) : !0
 }
 
-function $p(t, e, r) {
-    return !(!aa(t, e, r) || typeof e == "number")
+function Yp(e, t, r) {
+    return !(!aa(e, t, r) || typeof t == "number")
 }
 
-function Ss(t) {
-    let e = oa[t],
-        r = Fh(t),
-        s = Hn(t);
+function xs(e) {
+    let t = oa[e],
+        r = kf(e),
+        s = jn(e);
     return {
         format: r,
-        dataFormat: e?.dataFormat || jA(s.format, s.integer, s.normalized, r),
-        type: s.dataType ? ra(s.dataType) : e?.types?.[0] || 5121,
+        dataFormat: t?.dataFormat || $A(s.format, s.integer, s.normalized, r),
+        type: s.dataType ? ra(s.dataType) : t?.types?.[0] || 5121,
         compressed: s.compressed
     }
 }
 
-function Yp(t) {
-    let e = oa[t];
-    if (!e?.attachment) throw new Error(`${t} is not a depth stencil format`);
-    return e.attachment
+function qp(e) {
+    let t = oa[e];
+    if (!t?.attachment) throw new Error(`${e} is not a depth stencil format`);
+    return t.attachment
 }
 
-function Dh(t) {
-    let e = Ss(t),
-        r = zA[e.dataFormat] || 4,
-        s = HA[e.type] || 1;
+function Df(e) {
+    let t = xs(e),
+        r = HA[t.dataFormat] || 4,
+        s = XA[t.type] || 1;
     return r * s
 }
 
-function jA(t, e, r, s) {
+function $A(e, t, r, s) {
     if (s === 6408 || s === 6407) return s;
-    switch (t) {
+    switch (e) {
         case "r":
-            return e && !r ? 36244 : 6403;
+            return t && !r ? 36244 : 6403;
         case "rg":
-            return e && !r ? 33320 : 33319;
+            return t && !r ? 33320 : 33319;
         case "rgb":
-            return e && !r ? 36248 : 6407;
+            return t && !r ? 36248 : 6407;
         case "rgba":
-            return e && !r ? 36249 : 6408;
+            return t && !r ? 36249 : 6408;
         default:
             return 6408
     }
 }
-var qp = {
+var Kp = {
         "depth-clip-control": "EXT_depth_clamp",
         "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
         "compilation-status-async-webgl": "KHR_parallel_shader_compile",
         "polygon-mode-webgl": "WEBGL_polygon_mode",
         "provoking-vertex-webgl": "WEBGL_provoking_vertex",
         "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
         "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
         "shader-conservative-depth-webgl": "EXT_conservative_depth"
     },
-    ca = class extends ti {
+    ca = class extends ei {
         constructor(r, s, i) {
             super([], i);
-            f(this, "gl");
-            f(this, "extensions");
-            f(this, "testedFeatures", new Set);
-            this.gl = r, this.extensions = s, ze(r, "EXT_color_buffer_float", s)
+            h(this, "gl");
+            h(this, "extensions");
+            h(this, "testedFeatures", new Set);
+            this.gl = r, this.extensions = s, zt(r, "EXT_color_buffer_float", s)
         }*[Symbol.iterator]() {
             let r = this.getFeatures();
             for (let s of r) this.has(s) && (yield s);
             return []
         }
         has(r) {
-            return this.disabledFeatures[r] ? !1 : (this.testedFeatures.has(r) || (this.testedFeatures.add(r), Hp(r) && jp(this.gl, r, this.extensions) && this.features.add(r), this.getWebGLFeature(r) && this.features.add(r)), this.features.has(r))
+            return this.disabledFeatures[r] ? !1 : (this.testedFeatures.has(r) || (this.testedFeatures.add(r), Hp(r) && Xp(this.gl, r, this.extensions) && this.features.add(r), this.getWebGLFeature(r) && this.features.add(r)), this.features.has(r))
         }
         initializeFeatures() {
             let r = this.getFeatures().filter(s => s !== "polygon-mode-webgl");
             for (let s of r) this.has(s)
         }
         getFeatures() {
-            return [...Object.keys(qp), ...Object.keys(na)]
+            return [...Object.keys(Kp), ...Object.keys(na)]
         }
         getWebGLFeature(r) {
-            let s = qp[r];
-            return typeof s == "string" ? !!ze(this.gl, s, this.extensions) : !!s
+            let s = Kp[r];
+            return typeof s == "string" ? !!zt(this.gl, s, this.extensions) : !!s
         }
     };
-var la = class extends ei {
+var la = class extends ti {
     constructor(r) {
         super();
-        f(this, "gl");
-        f(this, "limits", {});
+        h(this, "gl");
+        h(this, "limits", {});
         this.gl = r
     }
     get maxTextureDimension1D() {
         return 0
     }
     get maxTextureDimension2D() {
         return this.getParameter(3379)
@@ -17079,150 +17079,150 @@
         return 0
     }
     getParameter(r) {
         return this.limits[r] === void 0 && (this.limits[r] = this.gl.getParameter(r)), this.limits[r]
     }
 };
 
-function He(t, e, r) {
-    if (XA(e)) return r(t);
+function jt(e, t, r) {
+    if (YA(t)) return r(e);
     let {
         nocatch: s = !0
-    } = e;
-    rr(t), Ke(t, e);
+    } = t;
+    rr(e), Kt(e, t);
     let i;
-    if (s) i = r(t), Ot(t);
+    if (s) i = r(e), Oe(e);
     else try {
-        i = r(t)
+        i = r(e)
     } finally {
-        Ot(t)
+        Oe(e)
     }
     return i
 }
 
-function XA(t) {
-    for (let e in t) return !1;
+function YA(e) {
+    for (let t in e) return !1;
     return !0
 }
 
-function Zp(t, e, r, s) {
-    if (Vt(e)) return s(t);
-    let i = t;
+function Qp(e, t, r, s) {
+    if (Ve(t)) return s(e);
+    let i = e;
     rr(i.gl);
     try {
-        return $A(t, e), Ke(i.gl, r), s(t)
+        return qA(e, t), Kt(i.gl, r), s(e)
     } finally {
-        Ot(i.gl)
+        Oe(i.gl)
     }
 }
 
-function $A(t, e) {
-    let r = t,
+function qA(e, t) {
+    let r = e,
         {
             gl: s
         } = r;
-    if (e.cullMode) switch (e.cullMode) {
+    if (t.cullMode) switch (t.cullMode) {
         case "none":
             s.disable(2884);
             break;
         case "front":
             s.enable(2884), s.cullFace(1028);
             break;
         case "back":
             s.enable(2884), s.cullFace(1029);
             break
     }
-    if (e.frontFace && s.frontFace(Dr("frontFace", e.frontFace, {
+    if (t.frontFace && s.frontFace(kr("frontFace", t.frontFace, {
             ccw: 2305,
             cw: 2304
-        })), e.unclippedDepth && t.features.has("depth-clip-control") && s.enable(34383), e.depthBias !== void 0 && (s.enable(32823), s.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && t.features.has("provoking-vertex-webgl")) {
+        })), t.unclippedDepth && e.features.has("depth-clip-control") && s.enable(34383), t.depthBias !== void 0 && (s.enable(32823), s.polygonOffset(t.depthBias, t.depthBiasSlopeScale || 0)), t.provokingVertex && e.features.has("provoking-vertex-webgl")) {
         let n = r.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex,
-            o = Dr("provokingVertex", e.provokingVertex, {
+            o = kr("provokingVertex", t.provokingVertex, {
                 first: 36429,
                 last: 36430
             });
         n?.provokingVertexWEBGL(o)
     }
-    if ((e.polygonMode || e.polygonOffsetLine) && t.features.has("polygon-mode-webgl")) {
-        if (e.polygonMode) {
+    if ((t.polygonMode || t.polygonOffsetLine) && e.features.has("polygon-mode-webgl")) {
+        if (t.polygonMode) {
             let n = r.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode,
-                o = Dr("polygonMode", e.polygonMode, {
+                o = kr("polygonMode", t.polygonMode, {
                     fill: 6914,
                     line: 6913
                 });
             n?.polygonModeWEBGL(1028, o), n?.polygonModeWEBGL(1029, o)
         }
-        e.polygonOffsetLine && s.enable(10754)
+        t.polygonOffsetLine && s.enable(10754)
     }
-    if (t.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && s.enable(12288), e.clipDistance1 && s.enable(12289), e.clipDistance2 && s.enable(12290), e.clipDistance3 && s.enable(12291), e.clipDistance4 && s.enable(12292), e.clipDistance5 && s.enable(12293), e.clipDistance6 && s.enable(12294), e.clipDistance7 && s.enable(12295)), e.depthWriteEnabled !== void 0 && s.depthMask(qA("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? s.enable(2929) : s.disable(2929), s.depthFunc(fa("depthCompare", e.depthCompare))), e.stencilWriteMask) {
-        let i = e.stencilWriteMask;
+    if (e.features.has("shader-clip-cull-distance-webgl") && (t.clipDistance0 && s.enable(12288), t.clipDistance1 && s.enable(12289), t.clipDistance2 && s.enable(12290), t.clipDistance3 && s.enable(12291), t.clipDistance4 && s.enable(12292), t.clipDistance5 && s.enable(12293), t.clipDistance6 && s.enable(12294), t.clipDistance7 && s.enable(12295)), t.depthWriteEnabled !== void 0 && s.depthMask(ZA("depthWriteEnabled", t.depthWriteEnabled)), t.depthCompare && (t.depthCompare !== "always" ? s.enable(2929) : s.disable(2929), s.depthFunc(ha("depthCompare", t.depthCompare))), t.stencilWriteMask) {
+        let i = t.stencilWriteMask;
         s.stencilMaskSeparate(1028, i), s.stencilMaskSeparate(1029, i)
     }
-    if (e.stencilReadMask && P.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
-        let i = e.stencilReadMask || 4294967295,
-            n = fa("depthCompare", e.stencilCompare);
-        e.stencilCompare !== "always" ? s.enable(2960) : s.disable(2960), s.stencilFuncSeparate(1028, n, 0, i), s.stencilFuncSeparate(1029, n, 0, i)
-    }
-    if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
-        let i = kh("stencilPassOperation", e.stencilPassOperation),
-            n = kh("stencilFailOperation", e.stencilFailOperation),
-            o = kh("stencilDepthFailOperation", e.stencilDepthFailOperation);
+    if (t.stencilReadMask && P.warn("stencilReadMask not supported under WebGL"), t.stencilCompare) {
+        let i = t.stencilReadMask || 4294967295,
+            n = ha("depthCompare", t.stencilCompare);
+        t.stencilCompare !== "always" ? s.enable(2960) : s.disable(2960), s.stencilFuncSeparate(1028, n, 0, i), s.stencilFuncSeparate(1029, n, 0, i)
+    }
+    if (t.stencilPassOperation && t.stencilFailOperation && t.stencilDepthFailOperation) {
+        let i = Bf("stencilPassOperation", t.stencilPassOperation),
+            n = Bf("stencilFailOperation", t.stencilFailOperation),
+            o = Bf("stencilDepthFailOperation", t.stencilDepthFailOperation);
         s.stencilOpSeparate(1028, n, o, i), s.stencilOpSeparate(1029, n, o, i)
     }
-    if (e.blendColorOperation || e.blendAlphaOperation) {
+    if (t.blendColorOperation || t.blendAlphaOperation) {
         s.enable(3042);
-        let i = Kp("blendColorOperation", e.blendColorOperation || "add"),
-            n = Kp("blendAlphaOperation", e.blendAlphaOperation || "add");
+        let i = Zp("blendColorOperation", t.blendColorOperation || "add"),
+            n = Zp("blendAlphaOperation", t.blendAlphaOperation || "add");
         s.blendEquationSeparate(i, n);
-        let o = ha("blendColorSrcFactor", e.blendColorSrcFactor || "one"),
-            a = ha("blendColorDstFactor", e.blendColorDstFactor || "zero"),
-            c = ha("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"),
-            l = ha("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
+        let o = fa("blendColorSrcFactor", t.blendColorSrcFactor || "one"),
+            a = fa("blendColorDstFactor", t.blendColorDstFactor || "zero"),
+            c = fa("blendAlphaSrcFactor", t.blendAlphaSrcFactor || "one"),
+            l = fa("blendAlphaDstFactor", t.blendAlphaDstFactor || "zero");
         s.blendFuncSeparate(o, a, c, l)
     }
 }
 
-function fa(t, e) {
-    return Dr(t, e, {
+function ha(e, t) {
+    return kr(e, t, {
         never: 512,
         less: 513,
         equal: 514,
         "less-equal": 515,
         greater: 516,
         "not-equal": 517,
         "greater-equal": 518,
         always: 519
     })
 }
 
-function kh(t, e) {
-    return Dr(t, e, {
+function Bf(e, t) {
+    return kr(e, t, {
         keep: 7680,
         zero: 0,
         replace: 7681,
         invert: 5386,
         "increment-clamp": 7682,
         "decrement-clamp": 7683,
         "increment-wrap": 34055,
         "decrement-wrap": 34056
     })
 }
 
-function Kp(t, e) {
-    return Dr(t, e, {
+function Zp(e, t) {
+    return kr(e, t, {
         add: 32774,
         subtract: 32778,
         "reverse-subtract": 32779,
         min: 32775,
         max: 32776
     })
 }
 
-function ha(t, e) {
-    return Dr(t, e, {
+function fa(e, t) {
+    return kr(e, t, {
         one: 1,
         zero: 0,
         "src-color": 768,
         "one-minus-src-color": 769,
         "dst-color": 774,
         "one-minus-dst-color": 775,
         "src-alpha": 770,
@@ -17233,78 +17233,78 @@
         "constant-color": 32769,
         "one-minus-constant-color": 32770,
         "constant-alpha": 32771,
         "one-minus-constant-alpha": 32772
     })
 }
 
-function YA(t, e) {
-    return `Illegal parameter ${e} for ${t}`
+function KA(e, t) {
+    return `Illegal parameter ${t} for ${e}`
 }
 
-function Dr(t, e, r) {
-    if (!(e in r)) throw new Error(YA(t, e));
-    return r[e]
+function kr(e, t, r) {
+    if (!(t in r)) throw new Error(KA(e, t));
+    return r[t]
 }
 
-function qA(t, e) {
-    return e
+function ZA(e, t) {
+    return t
 }
 
-function ua(t) {
-    let e = {};
-    return t.addressModeU && (e[10242] = Bh(t.addressModeU)), t.addressModeV && (e[10243] = Bh(t.addressModeV)), t.addressModeW && (e[32882] = Bh(t.addressModeW)), t.magFilter && (e[10240] = Qp(t.magFilter)), (t.minFilter || t.mipmapFilter) && (e[10241] = KA(t.minFilter || "linear", t.mipmapFilter)), t.lodMinClamp !== void 0 && (e[33082] = t.lodMinClamp), t.lodMaxClamp !== void 0 && (e[33083] = t.lodMaxClamp), t.type === "comparison-sampler" && (e[34892] = 34894), t.compare && (e[34893] = fa("compare", t.compare)), t.maxAnisotropy && (e[34046] = t.maxAnisotropy), e
+function ua(e) {
+    let t = {};
+    return e.addressModeU && (t[10242] = Uf(e.addressModeU)), e.addressModeV && (t[10243] = Uf(e.addressModeV)), e.addressModeW && (t[32882] = Uf(e.addressModeW)), e.magFilter && (t[10240] = Jp(e.magFilter)), (e.minFilter || e.mipmapFilter) && (t[10241] = QA(e.minFilter || "linear", e.mipmapFilter)), e.lodMinClamp !== void 0 && (t[33082] = e.lodMinClamp), e.lodMaxClamp !== void 0 && (t[33083] = e.lodMaxClamp), e.type === "comparison-sampler" && (t[34892] = 34894), e.compare && (t[34893] = ha("compare", e.compare)), e.maxAnisotropy && (t[34046] = e.maxAnisotropy), t
 }
 
-function Bh(t) {
-    switch (t) {
+function Uf(e) {
+    switch (e) {
         case "clamp-to-edge":
             return 33071;
         case "repeat":
             return 10497;
         case "mirror-repeat":
             return 33648
     }
 }
 
-function Qp(t) {
-    switch (t) {
+function Jp(e) {
+    switch (e) {
         case "nearest":
             return 9728;
         case "linear":
             return 9729
     }
 }
 
-function KA(t, e) {
-    if (!e) return Qp(t);
-    switch (t) {
+function QA(e, t) {
+    if (!t) return Jp(e);
+    switch (e) {
         case "nearest":
-            return e === "nearest" ? 9984 : 9986;
+            return t === "nearest" ? 9984 : 9986;
         case "linear":
-            return e === "nearest" ? 9985 : 9987
+            return t === "nearest" ? 9985 : 9987
     }
 }
-var Ae = class extends K {
+var At = class extends K {
     constructor(r, s = {}) {
         super(r, s);
-        f(this, "device");
-        f(this, "gl");
-        f(this, "handle");
-        f(this, "glTarget");
-        f(this, "glUsage");
-        f(this, "glIndexType", 5123);
-        f(this, "byteLength");
-        f(this, "bytesUsed");
+        h(this, "device");
+        h(this, "gl");
+        h(this, "handle");
+        h(this, "glTarget");
+        h(this, "glUsage");
+        h(this, "glIndexType", 5123);
+        h(this, "byteLength");
+        h(this, "bytesUsed");
         this.device = r, this.gl = this.device.gl;
         let i = typeof s == "object" ? s.handle : void 0;
         this.handle = i || this.gl.createBuffer(), r.setSpectorMetadata(this.handle, {
             ...this.props,
             data: typeof this.props.data
-        }), this.glTarget = ZA(this.props.usage), this.glUsage = QA(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, s.data ? this._initWithData(s.data, s.byteOffset, s.byteLength) : this._initWithByteLength(s.byteLength || 0)
+        }), this.glTarget = JA(this.props.usage), this.glUsage = GA(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, s.data ? this._initWithData(s.data, s.byteOffset, s.byteLength) : this._initWithByteLength(s.byteLength || 0)
     }
     _initWithData(r, s = 0, i = r.byteLength + s) {
         let n = this.glTarget;
         this.gl.bindBuffer(n, this.handle), this.gl.bufferData(n, i, this.glUsage), this.gl.bufferSubData(n, s, r), this.gl.bindBuffer(n, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(r, s, i), this.trackAllocatedMemory(i)
     }
     _initWithByteLength(r) {
         z(r >= 0);
@@ -17326,27 +17326,27 @@
         s = s ?? this.byteLength - r;
         let i = new Uint8Array(s),
             n = 0;
         return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, r, i, n, s), this.gl.bindBuffer(36662, null), this._setDebugData(i, r, s), i
     }
 };
 
-function ZA(t) {
-    return t & K.INDEX ? 34963 : t & K.VERTEX ? 34962 : t & K.UNIFORM ? 35345 : 34962
+function JA(e) {
+    return e & K.INDEX ? 34963 : e & K.VERTEX ? 34962 : e & K.UNIFORM ? 35345 : 34962
 }
 
-function QA(t) {
-    return t & K.INDEX || t & K.VERTEX ? 35044 : t & K.UNIFORM ? 35048 : 35044
+function GA(e) {
+    return e & K.INDEX || e & K.VERTEX ? 35044 : e & K.UNIFORM ? 35048 : 35044
 }
-var kr = class extends Ar {
+var Dr = class extends Ar {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "handle");
-        f(this, "parameters");
+        h(this, "device");
+        h(this, "handle");
+        h(this, "parameters");
         this.device = r, this.parameters = ua(s), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters)
     }
     destroy() {
         this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0)
     }
     toString() {
         return `Sampler(${this.id},${JSON.stringify(this.props)})`
@@ -17362,123 +17362,123 @@
                 default:
                     this.device.gl.samplerParameteri(this.handle, n, i);
                     break
             }
         }
     }
 };
-var Ze = class extends br {
+var Zt = class extends Tr {
     constructor(r, s) {
         super(r, {
-            ...se.defaultProps,
+            ...st.defaultProps,
             ...s
         });
-        f(this, "device");
-        f(this, "gl");
-        f(this, "handle");
-        f(this, "texture");
+        h(this, "device");
+        h(this, "gl");
+        h(this, "handle");
+        h(this, "texture");
         this.device = r, this.gl = this.device.gl, this.handle = null, this.texture = s.texture
     }
 };
-var JA = {
+var tE = {
         parameters: {},
         pixelStore: {},
         pixels: null,
         border: 0,
         dataFormat: void 0,
         textureUnit: void 0,
         target: void 0
     },
-    qi = class qi extends se {
+    qi = class qi extends st {
         constructor(r, s) {
             super(r, {
-                ...JA,
+                ...tE,
                 format: "rgba8unorm",
                 ...s
             });
-            f(this, "MAX_ATTRIBUTES");
-            f(this, "device");
-            f(this, "gl");
-            f(this, "handle");
-            f(this, "sampler");
-            f(this, "view");
-            f(this, "glFormat");
-            f(this, "type");
-            f(this, "dataFormat");
-            f(this, "mipmaps");
-            f(this, "target");
-            f(this, "textureUnit");
-            f(this, "loaded", !1);
-            f(this, "_video");
+            h(this, "MAX_ATTRIBUTES");
+            h(this, "device");
+            h(this, "gl");
+            h(this, "handle");
+            h(this, "sampler");
+            h(this, "view");
+            h(this, "glFormat");
+            h(this, "type");
+            h(this, "dataFormat");
+            h(this, "mipmaps");
+            h(this, "target");
+            h(this, "textureUnit");
+            h(this, "loaded", !1);
+            h(this, "_video");
             this.device = r, this.gl = this.device.gl, this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, {
                 ...this.props,
                 data: typeof this.props.data
-            }), this.glFormat = 6408, this.target = GA(this.props), this.loaded = !1, typeof this.props?.data == "string" && Object.assign(this.props, {
+            }), this.glFormat = 6408, this.target = eE(this.props), this.loaded = !1, typeof this.props?.data == "string" && Object.assign(this.props, {
                 data: Yc(this.props.data)
             }), this.initialize(this.props), Object.seal(this)
         }
         destroy() {
             this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0)
         }
         toString() {
             return `Texture(${this.id},${this.width}x${this.height})`
         }
         createView(r) {
-            return new Ze(this.device, {
+            return new Zt(this.device, {
                 ...r,
                 texture: this
             })
         }
         initialize(r = {}) {
             if (this.props.dimension === "cube") return this.initializeCube(r);
             let s = r.data;
-            if (s instanceof Promise) return s.then(w => this.initialize(Object.assign({}, r, {
-                pixels: w,
-                data: w
+            if (s instanceof Promise) return s.then(S => this.initialize(Object.assign({}, r, {
+                pixels: S,
+                data: S
             }))), this;
             let i = typeof HTMLVideoElement < "u" && s instanceof HTMLVideoElement;
             if (i && s.readyState < HTMLVideoElement.HAVE_METADATA) return this._video = null, s.addEventListener("loadeddata", () => this.initialize(r)), this;
             let {
                 parameters: n = {}
             } = r, {
                 pixels: o = null,
                 pixelStore: a = {},
                 textureUnit: c = void 0,
                 mipmaps: l = !0
             } = r;
             s || (s = o);
             let {
-                width: h,
+                width: f,
                 height: d,
                 dataFormat: p,
                 type: m,
                 compressed: y = !1
             } = r, {
-                depth: x = 0
-            } = r, b = Fh(r.format);
+                depth: E = 0
+            } = r, T = kf(r.format);
             return {
-                width: h,
+                width: f,
                 height: d,
                 compressed: y,
                 dataFormat: p,
                 type: m
             } = this._deduceParameters({
                 format: r.format,
                 type: m,
                 dataFormat: p,
                 compressed: y,
                 data: s,
-                width: h,
+                width: f,
                 height: d
-            }), this.width = h, this.height = d, this.glFormat = b, this.type = m, this.dataFormat = p, this.textureUnit = c, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = l, this.setImageData({
+            }), this.width = f, this.height = d, this.glFormat = T, this.type = m, this.dataFormat = p, this.textureUnit = c, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = l, this.setImageData({
                 data: s,
-                width: h,
+                width: f,
                 height: d,
-                depth: x,
-                format: b,
+                depth: E,
+                format: T,
                 type: m,
                 dataFormat: p,
                 parameters: a,
                 compressed: y
             }), this.setSampler(r.sampler), this._setSamplerParameters(n), this.view = this.createView({
                 ...this.props,
                 mipLevelCount: 1,
@@ -17496,15 +17496,15 @@
             } = r;
             return this.setCubeMapImageData(r).then(() => {
                 this.loaded = !0, s && this.generateMipmap(r), this.setSampler(r.sampler), this._setSamplerParameters(i)
             }), this
         }
         setSampler(r = {}) {
             let s;
-            r instanceof kr ? (this.sampler = r, s = r.props) : (this.sampler = new kr(this.device, r), s = r);
+            r instanceof Dr ? (this.sampler = r, s = r.props) : (this.sampler = new Dr(this.device, r), s = r);
             let i = ua(s);
             return this._setSamplerParameters(i), this
         }
         resize(r) {
             let {
                 height: s,
                 width: i,
@@ -17530,15 +17530,15 @@
                 this.setSubImageData({
                     data: r,
                     parameters: s
                 }), this.mipmaps && this.generateMipmap(), this._video.lastTime = r.currentTime
             }
         }
         generateMipmap(r = {}) {
-            return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), He(this.gl, r, () => {
+            return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), jt(this.gl, r, () => {
                 this.gl.generateMipmap(this.target)
             }), this.gl.bindTexture(this.target, null), this
         }
         setImageData(r) {
             if (this.props.dimension === "3d" || this.props.dimension === "2d-array") return this.setImageData3D(r);
             this.trackDeallocatedMemory("Texture");
             let {
@@ -17546,88 +17546,88 @@
                 pixels: i = null,
                 level: n = 0,
                 glFormat: o = this.glFormat,
                 offset: a = 0,
                 parameters: c = {}
             } = r, {
                 data: l = null,
-                type: h = this.type,
+                type: f = this.type,
                 width: d = this.width,
                 height: p = this.height,
                 dataFormat: m = this.dataFormat,
                 compressed: y = !1
             } = r;
             l || (l = i), {
-                type: h,
+                type: f,
                 dataFormat: m,
                 compressed: y,
                 width: d,
                 height: p
             } = this._deduceParameters({
                 format: this.props.format,
-                type: h,
+                type: f,
                 dataFormat: m,
                 compressed: y,
                 data: l,
                 width: d,
                 height: p
             });
             let {
-                gl: x
+                gl: E
             } = this;
-            x.bindTexture(this.target, this.handle);
-            let b = null;
+            E.bindTexture(this.target, this.handle);
+            let T = null;
             if ({
                     data: l,
-                    dataType: b
+                    dataType: T
                 } = this._getDataType({
                     data: l,
                     compressed: y
-                }), He(this.gl, c, () => {
-                    switch (b) {
+                }), jt(this.gl, c, () => {
+                    switch (T) {
                         case "null":
-                            x.texImage2D(s, n, o, d, p, 0, m, h, l);
+                            E.texImage2D(s, n, o, d, p, 0, m, f, l);
                             break;
                         case "typed-array":
-                            x.texImage2D(s, n, o, d, p, 0, m, h, l, a);
+                            E.texImage2D(s, n, o, d, p, 0, m, f, l, a);
                             break;
                         case "buffer":
-                            this.device.gl.bindBuffer(35052, l.handle || l), this.device.gl.texImage2D(s, n, o, d, p, 0, m, h, a), this.device.gl.bindBuffer(35052, null);
+                            this.device.gl.bindBuffer(35052, l.handle || l), this.device.gl.texImage2D(s, n, o, d, p, 0, m, f, a), this.device.gl.bindBuffer(35052, null);
                             break;
                         case "browser-object":
-                            x.texImage2D(s, n, o, d, p, 0, m, h, l);
+                            E.texImage2D(s, n, o, d, p, 0, m, f, l);
                             break;
                         case "compressed":
-                            for (let [w, R] of l.entries()) x.compressedTexImage2D(s, w, R.format, R.width, R.height, 0, R.data);
+                            for (let [S, R] of l.entries()) E.compressedTexImage2D(s, S, R.format, R.width, R.height, 0, R.data);
                             break;
                         default:
                             z(!1, "Unknown image data type")
                     }
                 }), l && l.byteLength) this.trackAllocatedMemory(l.byteLength, "Texture");
             else {
-                let w = Dh(this.props.format);
-                this.trackAllocatedMemory(this.width * this.height * w, "Texture")
+                let S = Df(this.props.format);
+                this.trackAllocatedMemory(this.width * this.height * S, "Texture")
             }
             return this.loaded = !0, this
         }
         setSubImageData({
             target: r = this.target,
             pixels: s = null,
             data: i = null,
             x: n = 0,
             y: o = 0,
             width: a = this.width,
             height: c = this.height,
             level: l = 0,
-            glFormat: h = this.glFormat,
+            glFormat: f = this.glFormat,
             type: d = this.type,
             dataFormat: p = this.dataFormat,
             compressed: m = !1,
             offset: y = 0,
-            parameters: x = {}
+            parameters: E = {}
         }) {
             if ({
                     type: d,
                     dataFormat: p,
                     compressed: m,
                     width: a,
                     height: c
@@ -17636,19 +17636,19 @@
                     type: d,
                     dataFormat: p,
                     compressed: m,
                     data: i,
                     width: a,
                     height: c
                 }), z(this.depth === 1, "texSubImage not supported for 3D textures"), i || (i = s), i && i.data) {
-                let b = i;
-                i = b.data, a = b.shape[0], c = b.shape[1]
+                let T = i;
+                i = T.data, a = T.shape[0], c = T.shape[1]
             }
-            i instanceof Ae && (i = i.handle), this.gl.bindTexture(this.target, this.handle), He(this.gl, x, () => {
-                m ? this.gl.compressedTexSubImage2D(r, l, n, o, a, c, h, i) : i === null ? this.gl.texSubImage2D(r, l, n, o, a, c, p, d, null) : ArrayBuffer.isView(i) ? this.gl.texSubImage2D(r, l, n, o, a, c, p, d, i, y) : typeof WebGLBuffer < "u" && i instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, i), this.device.gl.texSubImage2D(r, l, n, o, a, c, p, d, y), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(r, l, n, o, a, c, p, d, i)
+            i instanceof At && (i = i.handle), this.gl.bindTexture(this.target, this.handle), jt(this.gl, E, () => {
+                m ? this.gl.compressedTexSubImage2D(r, l, n, o, a, c, f, i) : i === null ? this.gl.texSubImage2D(r, l, n, o, a, c, p, d, null) : ArrayBuffer.isView(i) ? this.gl.texSubImage2D(r, l, n, o, a, c, p, d, i, y) : typeof WebGLBuffer < "u" && i instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, i), this.device.gl.texSubImage2D(r, l, n, o, a, c, p, d, y), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(r, l, n, o, a, c, p, d, i)
             }), this.gl.bindTexture(this.target, null)
         }
         copyFramebuffer(r = {}) {
             return P.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
         }
         getActiveUnit() {
             return this.gl.getParameter(34016) - 33984
@@ -17674,15 +17674,15 @@
                 dataType: "compressed"
             } : r === null ? {
                 data: r,
                 dataType: "null"
             } : ArrayBuffer.isView(r) ? {
                 data: r,
                 dataType: "typed-array"
-            } : r instanceof Ae ? {
+            } : r instanceof At ? {
                 data: r.handle,
                 dataType: "buffer"
             } : typeof WebGLBuffer < "u" && r instanceof WebGLBuffer ? {
                 data: r,
                 dataType: "buffer"
             } : {
                 data: r,
@@ -17695,16 +17695,16 @@
                 data: i
             } = r, {
                 width: n,
                 height: o,
                 dataFormat: a,
                 type: c,
                 compressed: l
-            } = r, h = Ss(s);
-            return a = a || h.dataFormat, c = c || h.type, l = l || h.compressed, {
+            } = r, f = xs(s);
+            return a = a || f.dataFormat, c = c || f.type, l = l || f.compressed, {
                 width: n,
                 height: o
             } = this._deduceImageSize(i, n, o), {
                 dataFormat: a,
                 type: c,
                 compressed: l,
                 width: n,
@@ -17744,69 +17744,69 @@
             } = this, {
                 width: i,
                 height: n,
                 pixels: o,
                 data: a,
                 format: c = 6408,
                 type: l = 5121
-            } = r, h = o || a, d = await Promise.all(qi.FACES.map(p => {
-                let m = h[p];
+            } = r, f = o || a, d = await Promise.all(qi.FACES.map(p => {
+                let m = f[p];
                 return Promise.all(Array.isArray(m) ? m : [m])
             }));
             this.bind(), qi.FACES.forEach((p, m) => {
-                d[m].length > 1 && this.props.mipmaps !== !1 && P.warn(`${this.id} has mipmap and multiple LODs.`)(), d[m].forEach((y, x) => {
-                    i && n ? s.texImage2D(p, x, c, i, n, 0, c, l, y) : s.texImage2D(p, x, c, c, l, y)
+                d[m].length > 1 && this.props.mipmaps !== !1 && P.warn(`${this.id} has mipmap and multiple LODs.`)(), d[m].forEach((y, E) => {
+                    i && n ? s.texImage2D(p, E, c, i, n, 0, c, l, y) : s.texImage2D(p, E, c, c, l, y)
                 })
             }), this.unbind()
         }
         setImageDataForFace(r) {
             let {
                 face: s,
                 width: i,
                 height: n,
                 pixels: o,
                 data: a,
                 format: c = 6408,
                 type: l = 5121
             } = r, {
-                gl: h
+                gl: f
             } = this, d = o || a;
             return this.bind(), d instanceof Promise ? d.then(p => this.setImageDataForFace(Object.assign({}, r, {
                 face: s,
                 data: p,
                 pixels: p
-            }))) : this.width || this.height ? h.texImage2D(s, 0, c, i, n, 0, c, l, d) : h.texImage2D(s, 0, c, c, l, d), this
+            }))) : this.width || this.height ? f.texImage2D(s, 0, c, i, n, 0, c, l, d) : f.texImage2D(s, 0, c, c, l, d), this
         }
         setImageData3D(r) {
             let {
                 level: s = 0,
                 dataFormat: i,
                 format: n,
                 type: o,
                 width: a,
                 height: c,
                 depth: l = 1,
-                offset: h = 0,
+                offset: f = 0,
                 data: d,
                 parameters: p = {}
             } = r;
             this.trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle);
-            let m = Ss(n);
-            if (He(this.gl, p, () => {
-                    ArrayBuffer.isView(d) && this.gl.texImage3D(this.target, s, m.format, a, c, l, 0, m.dataFormat, m.type, d), d instanceof Ae && (this.gl.bindBuffer(35052, d.handle), this.gl.texImage3D(this.target, s, i, a, c, l, 0, n, o, h))
+            let m = xs(n);
+            if (jt(this.gl, p, () => {
+                    ArrayBuffer.isView(d) && this.gl.texImage3D(this.target, s, m.format, a, c, l, 0, m.dataFormat, m.type, d), d instanceof At && (this.gl.bindBuffer(35052, d.handle), this.gl.texImage3D(this.target, s, i, a, c, l, 0, n, o, f))
                 }), d && d.byteLength) this.trackAllocatedMemory(d.byteLength, "Texture");
             else {
-                let y = Dh(this.props.format);
+                let y = Df(this.props.format);
                 this.trackAllocatedMemory(this.width * this.height * this.depth * y, "Texture")
             }
             return this.loaded = !0, this
         }
         _setSamplerParameters(r) {
-            if (!Vt(r)) {
-                ex(r), this.gl.bindTexture(this.target, this.handle);
+            if (!Ve(r)) {
+                rE(r), this.gl.bindTexture(this.target, this.handle);
                 for (let [s, i] of Object.entries(r)) {
                     let n = Number(s),
                         o = i;
                     switch (n) {
                         case 33082:
                         case 33083:
                             this.gl.texParameterf(this.target, n, o);
@@ -17816,70 +17816,70 @@
                             break
                     }
                 }
                 this.gl.bindTexture(this.target, null)
             }
         }
     };
-f(qi, "FACES", [34069, 34070, 34071, 34072, 34073, 34074]);
-var Re = qi;
+h(qi, "FACES", [34069, 34070, 34071, 34072, 34073, 34074]);
+var Rt = qi;
 
-function GA(t) {
-    switch (t.dimension) {
+function eE(e) {
+    switch (e.dimension) {
         case "2d":
             return 3553;
         case "cube":
             return 34067;
         case "2d-array":
             return 35866;
         case "3d":
             return 32879;
         case "1d":
         case "cube-array":
         default:
-            throw new Error(t.dimension)
+            throw new Error(e.dimension)
     }
 }
 
-function ex(t) {
-    P.log(1, "texture sampler parameters", t)()
+function rE(e) {
+    P.log(1, "texture sampler parameters", e)()
 }
-var _t = class extends xr {
+var ge = class extends Er {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "gl");
-        f(this, "handle");
+        h(this, "device");
+        h(this, "gl");
+        h(this, "handle");
         let i = s.handle === null;
         if (this.device = r, this.gl = r.gl, this.handle = this.props.handle || i ? this.props.handle : this.gl.createFramebuffer(), !i) {
             r.setSpectorMetadata(this.handle, {
                 id: this.props.id,
                 props: this.props
             }), this.autoCreateAttachmentTextures();
             let n = this.gl.bindFramebuffer(36160, this.handle);
             for (let o = 0; o < this.colorAttachments.length; ++o) {
                 let a = this.colorAttachments[o],
                     c = 36064 + o;
                 a && this._attachOne(c, a)
             }
-            if (this.depthStencilAttachment && this._attachOne(Yp(this.depthStencilAttachment.props.format), this.depthStencilAttachment), s.check !== !1) {
+            if (this.depthStencilAttachment && this._attachOne(qp(this.depthStencilAttachment.props.format), this.depthStencilAttachment), s.check !== !1) {
                 let o = this.gl.checkFramebufferStatus(36160);
-                if (o !== 36053) throw new Error(`Framebuffer ${rx(o)}`)
+                if (o !== 36053) throw new Error(`Framebuffer ${iE(o)}`)
             }
             this.gl.bindFramebuffer(36160, n)
         }
     }
     get texture() {
         return this.colorAttachments[0]
     }
     destroy() {
         super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle)
     }
     createDepthStencilTexture(r) {
-        return new Re(this.device, {
+        return new Rt(this.device, {
             id: `${this.id}-depth-stencil`,
             format: r,
             width: this.width,
             height: this.height,
             mipmaps: !1
         })
     }
@@ -17896,16 +17896,16 @@
         }), this
     }
     _attachOne(r, s) {
         if (Array.isArray(s)) {
             let [i, n = 0, o = 0] = s;
             return this._attachTexture(r, i, n, o), i
         }
-        if (s instanceof Re) return this._attachTexture(r, s, 0, 0), s;
-        if (s instanceof Ze) {
+        if (s instanceof Rt) return this._attachTexture(r, s, 0, 0), s;
+        if (s instanceof Zt) {
             let i = s;
             return this._attachTexture(r, i.texture, i.props.baseMipLevel, i.props.baseArrayLayer), s.texture
         }
         throw new Error("attach")
     }
     _attachTexture(r, s, i, n) {
         let {
@@ -17913,59 +17913,59 @@
         } = this.device;
         switch (o.bindTexture(s.target, s.handle), s.target) {
             case 35866:
             case 32879:
                 o.framebufferTextureLayer(36160, r, s.target, n, i);
                 break;
             case 34067:
-                let a = tx(i);
+                let a = sE(i);
                 o.framebufferTexture2D(36160, r, a, s.handle, n);
                 break;
             case 3553:
                 o.framebufferTexture2D(36160, r, 3553, s.handle, n);
                 break;
             default:
                 z(!1, "Illegal texture type")
         }
         o.bindTexture(s.target, null)
     }
 };
 
-function tx(t) {
-    return t < 34069 ? t + 34069 : t
+function sE(e) {
+    return e < 34069 ? e + 34069 : e
 }
 
-function rx(t) {
-    switch (t) {
+function iE(e) {
+    switch (e) {
         case 36053:
             return "success";
         case 36054:
             return "Mismatched attachments";
         case 36055:
             return "No attachments";
         case 36057:
             return "Height/width mismatch";
         case 36061:
             return "Unsupported or split attachments";
         case 36182:
             return "Samples mismatch";
         default:
-            return `${t}`
+            return `${e}`
     }
 }
-var da = class extends Wt {
+var da = class extends We {
     constructor(r, s) {
         super(s);
-        f(this, "device");
-        f(this, "presentationSize");
-        f(this, "_framebuffer", null);
+        h(this, "device");
+        h(this, "presentationSize");
+        h(this, "_framebuffer", null);
         this.device = r, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update()
     }
     getCurrentFramebuffer() {
-        return this.update(), this._framebuffer = this._framebuffer || new _t(this.device, {
+        return this.update(), this._framebuffer = this._framebuffer || new ge(this.device, {
             handle: null
         }), this._framebuffer
     }
     update() {
         let r = this.getPixelSize();
         (r[0] !== this.presentationSize[0] || r[1] !== this.presentationSize[1]) && (this.presentationSize = r, this.resize())
     }
@@ -17974,144 +17974,144 @@
             let s = this.getDevicePixelRatio(r?.useDevicePixels);
             this.setDevicePixelRatio(s, r);
             return
         }
     }
     commit() {}
 };
-var sx = {
+var nE = {
         spector: P.get("spector") || P.get("inspect")
     },
-    ix = "https://spectorcdn.babylonjs.com/spector.bundle.js",
-    nx = 1,
-    ve = null,
-    Jp = !1;
-async function Gp(t) {
+    oE = "https://spectorcdn.babylonjs.com/spector.bundle.js",
+    aE = 1,
+    vt = null,
+    Gp = !1;
+async function t_(e) {
     if (!globalThis.SPECTOR) try {
-        await ui(ix)
-    } catch (e) {
-        P.warn(String(e))
+        await ui(oE)
+    } catch (t) {
+        P.warn(String(t))
     }
 }
 
-function eg(t) {
-    if (t = {
-            ...sx,
-            ...t
-        }, !t?.spector || (!ve && globalThis.SPECTOR && (P.probe(nx, "SPECTOR found and initialized")(), ve = new globalThis.SPECTOR.Spector, globalThis.luma && (globalThis.luma.spector = ve)), !ve)) return null;
-    if (Jp || (Jp = !0, ve.spyCanvases(), ve?.onCaptureStarted.add(e => P.info("Spector capture started:", e)()), ve?.onCapture.add(e => {
-            P.info("Spector capture complete:", e)(), ve?.getResultUI(), ve?.resultView.display(), ve?.resultView.addCapture(e)
-        })), t?.canvas) {
-        if (typeof t.spector == "string" && t.spector !== t.canvas.id) return ve;
-        ve?.startCapture(t?.canvas, 500), new Promise(e => setTimeout(e, 2e3)).then(e => {
-            P.info("Spector capture stopped after 2 seconds")(), ve?.stopCapture()
+function e_(e) {
+    if (e = {
+            ...nE,
+            ...e
+        }, !e?.spector || (!vt && globalThis.SPECTOR && (P.probe(aE, "SPECTOR found and initialized")(), vt = new globalThis.SPECTOR.Spector, globalThis.luma && (globalThis.luma.spector = vt)), !vt)) return null;
+    if (Gp || (Gp = !0, vt.spyCanvases(), vt?.onCaptureStarted.add(t => P.info("Spector capture started:", t)()), vt?.onCapture.add(t => {
+            P.info("Spector capture complete:", t)(), vt?.getResultUI(), vt?.resultView.display(), vt?.resultView.addCapture(t)
+        })), e?.canvas) {
+        if (typeof e.spector == "string" && e.spector !== e.canvas.id) return vt;
+        vt?.startCapture(e?.canvas, 500), new Promise(t => setTimeout(t, 2e3)).then(t => {
+            P.info("Spector capture stopped after 2 seconds")(), vt?.stopCapture()
         })
     }
-    return ve
+    return vt
 }
-var ox = "https://unpkg.com/webgl-debug@2.0.1/index.js";
+var cE = "https://unpkg.com/webgl-debug@2.0.1/index.js";
 
-function tg(t) {
-    return t.luma = t.luma || {}, t.luma
+function r_(e) {
+    return e.luma = e.luma || {}, e.luma
 }
-async function rg() {
-    pe() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await ui(ox))
+async function s_() {
+    pt() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await ui(cE))
 }
 
-function sg(t, e = {}) {
-    return t ? e.debug ? cx(t, e) : ax(t) : null
+function i_(e, t = {}) {
+    return e ? t.debug ? fE(e, t) : lE(e) : null
 }
 
-function ax(t) {
-    let e = tg(t);
-    return e.realContext ? e.realContext : t
+function lE(e) {
+    let t = r_(e);
+    return t.realContext ? t.realContext : e
 }
 
-function cx(t, e) {
-    if (!globalThis.WebGLDebugUtils) return P.warn("webgl-debug not loaded")(), t;
-    let r = tg(t);
+function fE(e, t) {
+    if (!globalThis.WebGLDebugUtils) return P.warn("webgl-debug not loaded")(), e;
+    let r = r_(e);
     if (r.debugContext) return r.debugContext;
     globalThis.WebGLDebugUtils.init({
-        ...tr,
-        ...t
+        ...er,
+        ...e
     });
-    let s = globalThis.WebGLDebugUtils.makeDebugContext(t, lx.bind(null, e), hx.bind(null, e));
-    for (let o in tr) !(o in s) && typeof tr[o] == "number" && (s[o] = tr[o]);
+    let s = globalThis.WebGLDebugUtils.makeDebugContext(e, hE.bind(null, t), uE.bind(null, t));
+    for (let o in er) !(o in s) && typeof er[o] == "number" && (s[o] = er[o]);
     class i {}
-    Object.setPrototypeOf(s, Object.getPrototypeOf(t)), Object.setPrototypeOf(i, s);
+    Object.setPrototypeOf(s, Object.getPrototypeOf(e)), Object.setPrototypeOf(i, s);
     let n = Object.create(i);
-    return r.realContext = t, r.debugContext = n, n.debug = !0, n
+    return r.realContext = e, r.debugContext = n, n.debug = !0, n
 }
 
-function Uh(t, e) {
-    e = Array.from(e).map(s => s === void 0 ? "undefined" : s);
-    let r = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, e);
-    return r = `${r.slice(0,100)}${r.length>100?"...":""}`, `gl.${t}(${r})`
+function Lf(e, t) {
+    t = Array.from(t).map(s => s === void 0 ? "undefined" : s);
+    let r = globalThis.WebGLDebugUtils.glFunctionArgsToString(e, t);
+    return r = `${r.slice(0,100)}${r.length>100?"...":""}`, `gl.${e}(${r})`
 }
 
-function lx(t, e, r, s) {
+function hE(e, t, r, s) {
     s = Array.from(s).map(a => a === void 0 ? "undefined" : a);
-    let i = globalThis.WebGLDebugUtils.glEnumToString(e),
+    let i = globalThis.WebGLDebugUtils.glEnumToString(t),
         n = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, s),
         o = `${i} in gl.${r}(${n})`;
     P.error(o)();
     debugger;
-    if (t.throwOnError) throw new Error(o)
+    if (e.throwOnError) throw new Error(o)
 }
 
-function hx(t, e, r) {
+function uE(e, t, r) {
     let s = "";
-    if (P.level >= 1 && (s = Uh(e, r), P.log(1, s)()), t.break && t.break.length > 0 && (s = s || Uh(e, r), t.break.every(n => s.indexOf(n) !== -1))) debugger;
+    if (P.level >= 1 && (s = Lf(t, r), P.log(1, s)()), e.break && e.break.length > 0 && (s = s || Lf(t, r), e.break.every(n => s.indexOf(n) !== -1))) debugger;
     for (let i of r)
         if (i === void 0) {
-            if (s = s || Uh(e, r), t.throwOnError) throw new Error(`Undefined argument: ${s}`);
+            if (s = s || Lf(t, r), e.throwOnError) throw new Error(`Undefined argument: ${s}`);
             P.error(`Undefined argument: ${s}`)();
             debugger
         }
 }
 
-function ng(t) {
-    let e = t.split(/\r?\n/),
+function o_(e) {
+    let t = e.split(/\r?\n/),
         r = [];
-    for (let s of e) {
+    for (let s of t) {
         if (s.length <= 1) continue;
         let i = s.split(":");
         if (i.length === 2) {
             let [d, p] = i;
             r.push({
                 message: p.trim(),
-                type: ig(d),
+                type: n_(d),
                 lineNum: 0,
                 linePos: 0
             });
             continue
         }
         let [n, o, a, ...c] = i, l = parseInt(a, 10);
         isNaN(l) && (l = 0);
-        let h = parseInt(o, 10);
-        isNaN(h) && (h = 0), r.push({
+        let f = parseInt(o, 10);
+        isNaN(f) && (f = 0), r.push({
             message: c.join(":").trim(),
-            type: ig(n),
+            type: n_(n),
             lineNum: l,
-            linePos: h
+            linePos: f
         })
     }
     return r
 }
 
-function ig(t) {
-    let e = ["warning", "error", "info"],
-        r = t.toLowerCase();
-    return e.includes(r) ? r : "info"
+function n_(e) {
+    let t = ["warning", "error", "info"],
+        r = e.toLowerCase();
+    return t.includes(r) ? r : "info"
 }
-var pa = class extends Er {
+var pa = class extends wr {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "handle");
+        h(this, "device");
+        h(this, "handle");
         switch (this.device = r, this.props.stage) {
             case "vertex":
                 this.handle = this.props.handle || this.device.gl.createShader(35633);
                 break;
             case "fragment":
                 this.handle = this.props.handle || this.device.gl.createShader(35632);
                 break;
@@ -18124,15 +18124,15 @@
         this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0)
     }
     async getCompilationInfo() {
         return await this._waitForCompilationComplete(), this.getCompilationInfoSync()
     }
     getCompilationInfoSync() {
         let r = this.device.gl.getShaderInfoLog(this.handle);
-        return ng(r)
+        return o_(r)
     }
     getTranslatedSource() {
         return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle)
     }
     async _compile(r) {
         r = (n => n.startsWith("#version ") ? n : `#version 100
 ${n}`)(r);
@@ -18163,76 +18163,76 @@
             await r(10)
         }
     }
     _getCompilationStatus() {
         this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error"
     }
 };
-var fx = 256,
-    ux = 1024,
-    dx = 16384,
-    Lh = 6144,
-    px = [1, 2, 4, 8],
-    ga = class extends si {
+var dE = 256,
+    pE = 1024,
+    _E = 16384,
+    Vf = 6144,
+    gE = [1, 2, 4, 8],
+    _a = class extends si {
         constructor(r, s) {
             super(r, s);
-            f(this, "device");
-            f(this, "glParameters");
+            h(this, "device");
+            h(this, "glParameters");
             this.device = r, rr(this.device.gl), this.setParameters(this.props.parameters), this.clear()
         }
         end() {
-            Ot(this.device.gl)
+            Oe(this.device.gl)
         }
         pushDebugGroup(r) {}
         popDebugGroup() {}
         insertDebugMarker(r) {}
         setParameters(r = {}) {
             let s = {
                 ...this.glParameters
             };
-            this.props.framebuffer && (s.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (s.depthMask = !this.props.depthReadOnly), s.stencilMask = this.props.stencilReadOnly ? 0 : 1, s[35977] = this.props.discard, r.viewport && (r.viewport.length >= 6 ? (s.viewport = r.viewport.slice(0, 4), s.depthRange = [r.viewport[4], r.viewport[5]]) : s.viewport = r.viewport), r.scissorRect && (s.scissorTest = !0, s.scissor = r.scissorRect), r.blendConstant && (s.blendColor = r.blendConstant), r.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), r[2967] = r.stencilReference), r.colorMask && (s.colorMask = px.map(i => !!(i & r.colorMask))), this.glParameters = s, Ke(this.device.gl, s)
+            this.props.framebuffer && (s.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (s.depthMask = !this.props.depthReadOnly), s.stencilMask = this.props.stencilReadOnly ? 0 : 1, s[35977] = this.props.discard, r.viewport && (r.viewport.length >= 6 ? (s.viewport = r.viewport.slice(0, 4), s.depthRange = [r.viewport[4], r.viewport[5]]) : s.viewport = r.viewport), r.scissorRect && (s.scissorTest = !0, s.scissor = r.scissorRect), r.blendConstant && (s.blendColor = r.blendConstant), r.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), r[2967] = r.stencilReference), r.colorMask && (s.colorMask = gE.map(i => !!(i & r.colorMask))), this.glParameters = s, Kt(this.device.gl, s)
         }
         beginOcclusionQuery(r) {
             this.props.occlusionQuerySet?.beginOcclusionQuery()
         }
         endOcclusionQuery() {
             this.props.occlusionQuerySet?.endOcclusionQuery()
         }
         clear() {
             let r = {
                     ...this.glParameters
                 },
                 s = 0;
-            this.props.clearColor !== !1 && (s |= dx, r.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (s |= fx, r.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (s |= ux, r.clearStencil = this.props.clearStencil), s !== 0 && He(this.device.gl, r, () => {
+            this.props.clearColor !== !1 && (s |= _E, r.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (s |= dE, r.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (s |= pE, r.clearStencil = this.props.clearStencil), s !== 0 && jt(this.device.gl, r, () => {
                 this.device.gl.clear(s)
             })
         }
         clearColorBuffer(r = 0, s = [0, 0, 0, 0]) {
-            He(this.device.gl, {
+            jt(this.device.gl, {
                 framebuffer: this.props.framebuffer
             }, () => {
                 switch (s.constructor) {
                     case Int32Array:
-                        this.device.gl.clearBufferiv(Lh, r, s);
+                        this.device.gl.clearBufferiv(Vf, r, s);
                         break;
                     case Uint32Array:
-                        this.device.gl.clearBufferuiv(Lh, r, s);
+                        this.device.gl.clearBufferuiv(Vf, r, s);
                         break;
                     case Float32Array:
                     default:
-                        this.device.gl.clearBufferfv(Lh, r, s);
+                        this.device.gl.clearBufferfv(Vf, r, s);
                         break
                 }
             })
         }
     };
-var gx = "Failed to deduce GL constant from typed array";
+var mE = "Failed to deduce GL constant from typed array";
 
-function og(t) {
-    switch (ArrayBuffer.isView(t) ? t.constructor : t) {
+function a_(e) {
+    switch (ArrayBuffer.isView(e) ? e.constructor : e) {
         case Float32Array:
             return 5126;
         case Uint16Array:
             return 5123;
         case Uint32Array:
             return 5125;
         case Uint8Array:
@@ -18242,23 +18242,23 @@
         case Int8Array:
             return 5120;
         case Int16Array:
             return 5122;
         case Int32Array:
             return 5124;
         default:
-            throw new Error(gx)
+            throw new Error(mE)
     }
 }
 
-function Ki(t, e) {
+function Ki(e, t) {
     let {
         clamped: r = !0
-    } = e || {};
-    switch (t) {
+    } = t || {};
+    switch (e) {
         case 5126:
             return Float32Array;
         case 5123:
         case 33635:
         case 32819:
         case 32820:
             return Uint16Array;
@@ -18272,70 +18272,70 @@
             return Int16Array;
         case 5124:
             return Int32Array;
         default:
             throw new Error("Failed to deduce typed array type from GL constant")
     }
 }
-var _x = {
+var bE = {
         offset: 0,
         stride: 0,
         type: 5126,
         size: 1,
         divisor: 0,
         normalized: !1,
         integer: !1
     },
-    mx = {
+    yE = {
         deprecatedProps: {
             instanced: "divisor",
             isInstanced: "divisor"
         }
     },
-    _a = class t {
-        constructor(...e) {
-            f(this, "offset");
-            f(this, "stride");
-            f(this, "type");
-            f(this, "size");
-            f(this, "divisor");
-            f(this, "normalized");
-            f(this, "integer");
-            f(this, "buffer");
-            f(this, "index");
-            e.forEach(r => this._assign(r)), Object.freeze(this)
+    ga = class e {
+        constructor(...t) {
+            h(this, "offset");
+            h(this, "stride");
+            h(this, "type");
+            h(this, "size");
+            h(this, "divisor");
+            h(this, "normalized");
+            h(this, "integer");
+            h(this, "buffer");
+            h(this, "index");
+            t.forEach(r => this._assign(r)), Object.freeze(this)
         }
-        static getBytesPerElement(e) {
-            return Ki(e.type || 5126).BYTES_PER_ELEMENT
+        static getBytesPerElement(t) {
+            return Ki(t.type || 5126).BYTES_PER_ELEMENT
         }
-        static getBytesPerVertex(e) {
-            return z(e.size), Ki(e.type || 5126).BYTES_PER_ELEMENT * e.size
+        static getBytesPerVertex(t) {
+            return z(t.size), Ki(t.type || 5126).BYTES_PER_ELEMENT * t.size
         }
-        static resolve(...e) {
-            return new t(_x, ...e)
+        static resolve(...t) {
+            return new e(bE, ...t)
         }
         toString() {
             return JSON.stringify(this)
         }
         get BYTES_PER_ELEMENT() {
-            return t.getBytesPerElement(this)
+            return e.getBytesPerElement(this)
         }
         get BYTES_PER_VERTEX() {
-            return t.getBytesPerVertex(this)
+            return e.getBytesPerVertex(this)
         }
-        _assign(e = {}) {
-            return e = $c("Accessor", e, mx), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalize !== void 0 && (this.normalized = e.normalize), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this
+        _assign(t = {}) {
+            return t = $c("Accessor", t, yE), t.type !== void 0 && (this.type = t.type, (t.type === 5124 || t.type === 5125) && (this.integer = !0)), t.size !== void 0 && (this.size = t.size), t.offset !== void 0 && (this.offset = t.offset), t.stride !== void 0 && (this.stride = t.stride), t.normalize !== void 0 && (this.normalized = t.normalize), t.normalized !== void 0 && (this.normalized = t.normalized), t.integer !== void 0 && (this.integer = t.integer), t.divisor !== void 0 && (this.divisor = t.divisor), t.buffer !== void 0 && (this.buffer = t.buffer), t.index !== void 0 && (typeof t.index == "boolean" ? this.index = t.index ? 1 : 0 : this.index = t.index), t.instanced !== void 0 && (this.divisor = t.instanced ? 1 : 0), t.isInstanced !== void 0 && (this.divisor = t.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this
         }
     };
 
-function ag(t) {
-    return Tx.includes(t)
+function c_(e) {
+    return TE.includes(e)
 }
-var Tx = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311],
-    cg = {
+var TE = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311],
+    l_ = {
         5126: [5126, 1, "float", "f32", "float32"],
         35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
         35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
         35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
         5124: [5124, 1, "int", "i32", "sint32"],
         35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
         35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
@@ -18355,43 +18355,43 @@
         35675: [5126, 12, "mat3", "mat3x3<f32>"],
         35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
         35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
         35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
         35676: [5126, 16, "mat4", "mat4x4<f32>"]
     };
 
-function Vh(t) {
-    let e = cg[t];
-    if (!e) throw new Error("uniform");
-    let [r, s, , i] = e;
+function Wf(e) {
+    let t = l_[e];
+    if (!t) throw new Error("uniform");
+    let [r, s, , i] = t;
     return {
         format: i,
         components: s,
         glType: r
     }
 }
 
-function lg(t) {
-    let e = cg[t];
-    if (!e) throw new Error("attribute");
-    let [, r, , s, i] = e;
+function f_(e) {
+    let t = l_[e];
+    if (!t) throw new Error("attribute");
+    let [, r, , s, i] = t;
     return {
         attributeType: s,
         vertexFormat: i,
         components: r
     }
 }
 
-function hg(t, e) {
+function h_(e, t) {
     let r = {
         attributes: [],
         bindings: []
     };
-    r.attributes = yx(t, e);
-    let s = Ax(t, e);
+    r.attributes = wE(e, t);
+    let s = xE(e, t);
     for (let a of s) {
         let c = a.uniforms.map(l => ({
             name: l.name,
             format: l.format,
             byteOffset: l.byteOffset,
             byteStride: l.byteStride,
             arrayLength: l.arrayLength
@@ -18401,156 +18401,156 @@
             name: a.name,
             location: a.location,
             visibility: (a.vertex ? 1 : 0) & (a.fragment ? 2 : 0),
             minBindingSize: a.byteLength,
             uniforms: c
         })
     }
-    let i = Ex(t, e),
+    let i = EE(e, t),
         n = 0;
     for (let a of i)
-        if (ag(a.type)) {
+        if (c_(a.type)) {
             let {
                 viewDimension: c,
                 sampleType: l
-            } = Sx(a.type);
+            } = RE(a.type);
             r.bindings.push({
                 type: "texture",
                 name: a.name,
                 location: n,
                 viewDimension: c,
                 sampleType: l
             }), a.textureUnit = n, n += 1
         } i.length && (r.uniforms = i);
-    let o = bx(t, e);
+    let o = AE(e, t);
     return o?.length && (r.varyings = o), r
 }
 
-function yx(t, e) {
+function wE(e, t) {
     let r = [],
-        s = t.getProgramParameter(e, 35721);
+        s = e.getProgramParameter(t, 35721);
     for (let i = 0; i < s; i++) {
-        let n = t.getActiveAttrib(e, i);
+        let n = e.getActiveAttrib(t, i);
         if (!n) throw new Error("activeInfo");
         let {
             name: o,
             type: a
-        } = n, c = t.getAttribLocation(e, o);
+        } = n, c = e.getAttribLocation(t, o);
         if (c >= 0) {
             let {
                 attributeType: l
-            } = lg(a), h = /instance/i.test(o) ? "instance" : "vertex";
+            } = f_(a), f = /instance/i.test(o) ? "instance" : "vertex";
             r.push({
                 name: o,
                 location: c,
-                stepMode: h,
+                stepMode: f,
                 type: l
             })
         }
     }
     return r.sort((i, n) => i.location - n.location), r
 }
 
-function bx(t, e) {
+function AE(e, t) {
     let r = [],
-        s = t.getProgramParameter(e, 35971);
+        s = e.getProgramParameter(t, 35971);
     for (let i = 0; i < s; i++) {
-        let n = t.getTransformFeedbackVarying(e, i);
+        let n = e.getTransformFeedbackVarying(t, i);
         if (!n) throw new Error("activeInfo");
         let {
             name: o,
             type: a,
             size: c
         } = n, {
             glType: l,
-            components: h
-        } = Vh(a), d = new _a({
+            components: f
+        } = Wf(a), d = new ga({
             type: l,
-            size: c * h
+            size: c * f
         }), p = {
             location: i,
             name: o,
             accessor: d
         };
         r.push(p)
     }
     return r.sort((i, n) => i.location - n.location), r
 }
 
-function Ex(t, e) {
+function EE(e, t) {
     let r = [],
-        s = t.getProgramParameter(e, 35718);
+        s = e.getProgramParameter(t, 35718);
     for (let i = 0; i < s; i++) {
-        let n = t.getActiveUniform(e, i);
+        let n = e.getActiveUniform(t, i);
         if (!n) throw new Error("activeInfo");
         let {
             name: o,
             size: a,
             type: c
         } = n, {
             name: l,
-            isArray: h
-        } = wx(o), d = t.getUniformLocation(e, l), p = {
+            isArray: f
+        } = vE(o), d = e.getUniformLocation(t, l), p = {
             location: d,
             name: l,
             size: a,
             type: c,
-            isArray: h
+            isArray: f
         };
         if (r.push(p), p.size > 1)
             for (let m = 0; m < p.size; m++) {
                 let y = `${l}[${m}]`;
-                d = t.getUniformLocation(e, y);
-                let x = {
+                d = e.getUniformLocation(t, y);
+                let E = {
                     ...p,
                     name: y,
                     location: d
                 };
-                r.push(x)
+                r.push(E)
             }
     }
     return r
 }
 
-function Ax(t, e) {
-    let r = (n, o) => t.getActiveUniformBlockParameter(e, n, o),
+function xE(e, t) {
+    let r = (n, o) => e.getActiveUniformBlockParameter(t, n, o),
         s = [],
-        i = t.getProgramParameter(e, 35382);
+        i = e.getProgramParameter(t, 35382);
     for (let n = 0; n < i; n++) {
         let o = {
-                name: t.getActiveUniformBlockName(e, n) || "",
+                name: e.getActiveUniformBlockName(t, n) || "",
                 location: r(n, 35391),
                 byteLength: r(n, 35392),
                 vertex: r(n, 35396),
                 fragment: r(n, 35398),
                 uniformCount: r(n, 35394),
                 uniforms: []
             },
             a = r(n, 35395) || [],
-            c = t.getActiveUniforms(e, a, 35383),
-            l = t.getActiveUniforms(e, a, 35384),
-            h = t.getActiveUniforms(e, a, 35387),
-            d = t.getActiveUniforms(e, a, 35388);
+            c = e.getActiveUniforms(t, a, 35383),
+            l = e.getActiveUniforms(t, a, 35384),
+            f = e.getActiveUniforms(t, a, 35387),
+            d = e.getActiveUniforms(t, a, 35388);
         for (let p = 0; p < o.uniformCount; ++p) {
-            let m = t.getActiveUniform(e, a[p]);
+            let m = e.getActiveUniform(t, a[p]);
             if (!m) throw new Error("activeInfo");
             o.uniforms.push({
                 name: m.name,
-                format: Vh(c[p]).format,
+                format: Wf(c[p]).format,
                 type: c[p],
                 arrayLength: l[p],
-                byteOffset: h[p],
+                byteOffset: f[p],
                 byteStride: d[p]
             })
         }
         s.push(o)
     }
     return s.sort((n, o) => n.location - o.location), s
 }
-var xx = {
+var SE = {
     35678: ["2d", "float"],
     35680: ["cube", "float"],
     35679: ["3d", "float"],
     35682: ["3d", "depth"],
     36289: ["2d-array", "float"],
     36292: ["2d-array", "depth"],
     36293: ["cube", "float"],
@@ -18560,41 +18560,41 @@
     36303: ["2d-array", "uint"],
     36306: ["2d", "uint"],
     36307: ["3d", "uint"],
     36308: ["cube", "uint"],
     36311: ["2d-array", "uint"]
 };
 
-function Sx(t) {
-    let e = xx[t];
-    if (!e) throw new Error("sampler");
-    let [r, s] = e;
+function RE(e) {
+    let t = SE[e];
+    if (!t) throw new Error("sampler");
+    let [r, s] = t;
     return {
         viewDimension: r,
         sampleType: s
     }
 }
 
-function wx(t) {
-    if (t[t.length - 1] !== "]") return {
-        name: t,
+function vE(e) {
+    if (e[e.length - 1] !== "]") return {
+        name: e,
         length: 1,
         isArray: !1
     };
-    let r = /([^[]*)(\[[0-9]+\])?/.exec(t);
-    if (!r || r.length < 2) throw new Error(`Failed to parse GLSL uniform name ${t}`);
+    let r = /([^[]*)(\[[0-9]+\])?/.exec(e);
+    if (!r || r.length < 2) throw new Error(`Failed to parse GLSL uniform name ${e}`);
     return {
         name: r[1],
         length: r[2] ? 1 : 0,
         isArray: !!r[2]
     }
 }
 
-function fg(t, e, r, s) {
-    let i = t,
+function u_(e, t, r, s) {
+    let i = e,
         n = s;
     n === !0 && (n = 1), n === !1 && (n = 0);
     let o = typeof n == "number" ? [n] : n;
     switch (r) {
         case 35678:
         case 35680:
         case 35679:
@@ -18607,71 +18607,71 @@
         case 36300:
         case 36303:
         case 36306:
         case 36307:
         case 36308:
         case 36311:
             if (typeof s != "number") throw new Error("samplers must be set to integers");
-            return t.uniform1i(e, s);
+            return e.uniform1i(t, s);
         case 5126:
-            return t.uniform1fv(e, o);
+            return e.uniform1fv(t, o);
         case 35664:
-            return t.uniform2fv(e, o);
+            return e.uniform2fv(t, o);
         case 35665:
-            return t.uniform3fv(e, o);
+            return e.uniform3fv(t, o);
         case 35666:
-            return t.uniform4fv(e, o);
+            return e.uniform4fv(t, o);
         case 5124:
-            return t.uniform1iv(e, o);
+            return e.uniform1iv(t, o);
         case 35667:
-            return t.uniform2iv(e, o);
+            return e.uniform2iv(t, o);
         case 35668:
-            return t.uniform3iv(e, o);
+            return e.uniform3iv(t, o);
         case 35669:
-            return t.uniform4iv(e, o);
+            return e.uniform4iv(t, o);
         case 35670:
-            return t.uniform1iv(e, o);
+            return e.uniform1iv(t, o);
         case 35671:
-            return t.uniform2iv(e, o);
+            return e.uniform2iv(t, o);
         case 35672:
-            return t.uniform3iv(e, o);
+            return e.uniform3iv(t, o);
         case 35673:
-            return t.uniform4iv(e, o);
+            return e.uniform4iv(t, o);
         case 5125:
-            return i.uniform1uiv(e, o, 1);
+            return i.uniform1uiv(t, o, 1);
         case 36294:
-            return i.uniform2uiv(e, o, 2);
+            return i.uniform2uiv(t, o, 2);
         case 36295:
-            return i.uniform3uiv(e, o, 3);
+            return i.uniform3uiv(t, o, 3);
         case 36296:
-            return i.uniform4uiv(e, o, 4);
+            return i.uniform4uiv(t, o, 4);
         case 35674:
-            return t.uniformMatrix2fv(e, !1, o);
+            return e.uniformMatrix2fv(t, !1, o);
         case 35675:
-            return t.uniformMatrix3fv(e, !1, o);
+            return e.uniformMatrix3fv(t, !1, o);
         case 35676:
-            return t.uniformMatrix4fv(e, !1, o);
+            return e.uniformMatrix4fv(t, !1, o);
         case 35685:
-            return i.uniformMatrix2x3fv(e, !1, o);
+            return i.uniformMatrix2x3fv(t, !1, o);
         case 35686:
-            return i.uniformMatrix2x4fv(e, !1, o);
+            return i.uniformMatrix2x4fv(t, !1, o);
         case 35687:
-            return i.uniformMatrix3x2fv(e, !1, o);
+            return i.uniformMatrix3x2fv(t, !1, o);
         case 35688:
-            return i.uniformMatrix3x4fv(e, !1, o);
+            return i.uniformMatrix3x4fv(t, !1, o);
         case 35689:
-            return i.uniformMatrix4x2fv(e, !1, o);
+            return i.uniformMatrix4x2fv(t, !1, o);
         case 35690:
-            return i.uniformMatrix4x3fv(e, !1, o)
+            return i.uniformMatrix4x3fv(t, !1, o)
     }
     throw new Error("Illegal uniform")
 }
 
-function ug(t) {
-    switch (t) {
+function d_(e) {
+    switch (e) {
         case "point-list":
             return 0;
         case "line-list":
             return 1;
         case "line-strip":
             return 3;
         case "line-loop-webgl":
@@ -18679,20 +18679,20 @@
         case "triangle-list":
             return 4;
         case "triangle-strip":
             return 5;
         case "triangle-fan-webgl":
             return 6;
         default:
-            throw new Error(t)
+            throw new Error(e)
     }
 }
 
-function dg(t) {
-    switch (t) {
+function p_(e) {
+    switch (e) {
         case "point-list":
             return 0;
         case "line-list":
             return 1;
         case "line-strip":
             return 1;
         case "line-loop-webgl":
@@ -18700,39 +18700,39 @@
         case "triangle-list":
             return 4;
         case "triangle-strip":
             return 4;
         case "triangle-fan-webgl":
             return 4;
         default:
-            throw new Error(t)
+            throw new Error(e)
     }
 }
-var pg = 4,
-    ma = class extends at {
+var __ = 4,
+    ma = class extends ae {
         constructor(r, s) {
             super(r, s);
-            f(this, "device");
-            f(this, "handle");
-            f(this, "vs");
-            f(this, "fs");
-            f(this, "introspectedLayout");
-            f(this, "uniforms", {});
-            f(this, "bindings", {});
-            f(this, "varyings", null);
-            f(this, "_uniformCount", 0);
-            f(this, "_uniformSetters", {});
+            h(this, "device");
+            h(this, "handle");
+            h(this, "vs");
+            h(this, "fs");
+            h(this, "introspectedLayout");
+            h(this, "uniforms", {});
+            h(this, "bindings", {});
+            h(this, "varyings", null);
+            h(this, "_uniformCount", 0);
+            h(this, "_uniformSetters", {});
             this.device = r, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, {
                 id: this.props.id
             }), this.vs = s.vs, this.fs = s.fs;
             let {
                 varyings: i,
                 bufferMode: n = 35981
             } = s;
-            switch (i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, n)), this._linkShaders(), P.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = hg(this.device.gl, this.handle), P.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = zc(this.introspectedLayout, s.shaderLayout), this.props.topology) {
+            switch (i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, n)), this._linkShaders(), P.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = h_(this.device.gl, this.handle), P.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = zc(this.introspectedLayout, s.shaderLayout), this.props.topology) {
                 case "triangle-fan-webgl":
                 case "line-loop-webgl":
                     P.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
                     break;
                 default:
             }
         }
@@ -18745,18 +18745,18 @@
                 if (!o) {
                     let a = this.shaderLayout.bindings.map(c => `"${c.name}"`).join(", ");
                     s?.disableWarnings || P.warn(`Unknown binding "${i}" in render pipeline "${this.id}", expected one of ${a}`)();
                     continue
                 }
                 switch (n || P.warn(`Unsetting binding "${i}" in render pipeline "${this.id}"`)(), o.type) {
                     case "uniform":
-                        if (!(n instanceof Ae) && !(n.buffer instanceof Ae)) throw new Error("buffer value");
+                        if (!(n instanceof At) && !(n.buffer instanceof At)) throw new Error("buffer value");
                         break;
                     case "texture":
-                        if (!(n instanceof Ze || n instanceof Re || n instanceof _t)) throw new Error("texture value");
+                        if (!(n instanceof Zt || n instanceof Rt || n instanceof ge)) throw new Error("texture value");
                         break;
                     case "sampler":
                         P.warn(`Ignoring sampler ${i}`)();
                         break;
                     default:
                         throw new Error(o.type)
                 }
@@ -18768,38 +18768,38 @@
                 renderPass: s,
                 parameters: i = this.props.parameters,
                 topology: n = this.props.topology,
                 vertexArray: o,
                 vertexCount: a,
                 instanceCount: c,
                 firstVertex: l = 0,
-                transformFeedback: h
-            } = r, d = ug(n), p = !!o.indexBuffer, m = o.indexBuffer?.glIndexType, y = Number(c) > 0;
+                transformFeedback: f
+            } = r, d = d_(n), p = !!o.indexBuffer, m = o.indexBuffer?.glIndexType, y = Number(c) > 0;
             if (this.linkStatus !== "success") return P.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
             if (!this._areTexturesRenderable() || a === 0) return P.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
             if (a === 0) return P.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)(), !0;
-            this.device.gl.useProgram(this.handle), o.bindBeforeRender(s), h && h.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
-            let x = s;
-            return Zp(this.device, i, x.glParameters, () => {
-                p && y ? this.device.gl.drawElementsInstanced(d, a || 0, m, l, c || 0) : p ? this.device.gl.drawElements(d, a || 0, m, l) : y ? this.device.gl.drawArraysInstanced(d, l, a || 0, c || 0) : this.device.gl.drawArrays(d, l, a || 0), h && h.end()
+            this.device.gl.useProgram(this.handle), o.bindBeforeRender(s), f && f.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
+            let E = s;
+            return Qp(this.device, i, E.glParameters, () => {
+                p && y ? this.device.gl.drawElementsInstanced(d, a || 0, m, l, c || 0) : p ? this.device.gl.drawElements(d, a || 0, m, l) : y ? this.device.gl.drawArraysInstanced(d, l, a || 0, c || 0) : this.device.gl.drawArrays(d, l, a || 0), f && f.end()
             }), o.unbindAfterRender(s), !0
         }
         setUniformsWebGL(r) {
             let {
                 bindings: s
-            } = fi(r);
+            } = hi(r);
             Object.keys(s).forEach(i => {
                 P.warn(`Unsupported value "${JSON.stringify(s[i])}" used in setUniforms() for key ${i}. Use setBindings() instead?`)()
             }), Object.assign(this.uniforms, r)
         }
         async _linkShaders() {
             let {
                 gl: r
             } = this.device;
-            if (r.attachShader(this.handle, this.vs.handle), r.attachShader(this.handle, this.fs.handle), P.time(pg, `linkProgram for ${this.id}`)(), r.linkProgram(this.handle), P.timeEnd(pg, `linkProgram for ${this.id}`)(), P.level, !this.device.features.has("compilation-status-async-webgl")) {
+            if (r.attachShader(this.handle, this.vs.handle), r.attachShader(this.handle, this.fs.handle), P.time(__, `linkProgram for ${this.id}`)(), r.linkProgram(this.handle), P.timeEnd(__, `linkProgram for ${this.id}`)(), P.level, !this.device.features.has("compilation-status-async-webgl")) {
                 let i = this._getLinkStatus();
                 this._reportLinkStatus(i);
                 return
             }
             P.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), P.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
             let s = this._getLinkStatus();
             this._reportLinkStatus(s)
@@ -18830,15 +18830,15 @@
             for (;;) {
                 if (i.getProgramParameter(this.handle, 37297)) return;
                 await r(10)
             }
         }
         _areTexturesRenderable() {
             let r = !0;
-            for (let [, s] of Object.entries(this.bindings)) s instanceof Re && (s.update(), r = r && s.loaded);
+            for (let [, s] of Object.entries(this.bindings)) s instanceof Rt && (s.update(), r = r && s.loaded);
             return r
         }
         _applyBindings() {
             if (this.linkStatus !== "success") return;
             let {
                 gl: r
             } = this.device;
@@ -18850,22 +18850,22 @@
                 if (!o) throw new Error(`No value for binding ${n.name} in ${this.id}`);
                 switch (n.type) {
                     case "uniform":
                         let {
                             name: a
                         } = n, c = r.getUniformBlockIndex(this.handle, a);
                         if (c === 4294967295) throw new Error(`Invalid uniform block name ${a}`);
-                        r.uniformBlockBinding(this.handle, i, c), o instanceof Ae ? r.bindBufferBase(35345, i, o.handle) : r.bindBufferRange(35345, i, o.buffer.handle, o.offset || 0, o.size || o.buffer.byteLength - o.offset), i += 1;
+                        r.uniformBlockBinding(this.handle, i, c), o instanceof At ? r.bindBufferBase(35345, i, o.handle) : r.bindBufferRange(35345, i, o.buffer.handle, o.offset || 0, o.size || o.buffer.byteLength - o.offset), i += 1;
                         break;
                     case "texture":
-                        if (!(o instanceof Ze || o instanceof Re || o instanceof _t)) throw new Error("texture");
+                        if (!(o instanceof Zt || o instanceof Rt || o instanceof ge)) throw new Error("texture");
                         let l;
-                        if (o instanceof Ze) l = o.texture;
-                        else if (o instanceof Re) l = o;
-                        else if (o instanceof _t && o.colorAttachments[0] instanceof Ze) P.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), l = o.colorAttachments[0].texture;
+                        if (o instanceof Zt) l = o.texture;
+                        else if (o instanceof Rt) l = o;
+                        else if (o instanceof ge && o.colorAttachments[0] instanceof Zt) P.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), l = o.colorAttachments[0].texture;
                         else throw new Error("No texture");
                         r.activeTexture(33984 + s), r.bindTexture(l.target, l.handle), s += 1;
                         break;
                     case "sampler":
                         break;
                     case "storage":
                     case "read-only-storage":
@@ -18877,144 +18877,144 @@
             for (let r of this.shaderLayout.uniforms || []) {
                 let {
                     name: s,
                     location: i,
                     type: n,
                     textureUnit: o
                 } = r, a = this.uniforms[s] ?? o;
-                a !== void 0 && fg(this.device.gl, i, n, a)
+                a !== void 0 && u_(this.device.gl, i, n, a)
             }
         }
     };
-var Ta = class extends ni {
+var ba = class extends ni {
     constructor(r) {
         super(r, {});
-        f(this, "device");
-        f(this, "commands", []);
+        h(this, "device");
+        h(this, "commands", []);
         this.device = r
     }
     submitCommands(r = this.commands) {
         for (let s of r) switch (s.name) {
             case "copy-buffer-to-buffer":
-                Rx(this.device, s.options);
+                ME(this.device, s.options);
                 break;
             case "copy-buffer-to-texture":
-                vx(this.device, s.options);
+                PE(this.device, s.options);
                 break;
             case "copy-texture-to-buffer":
-                Mx(this.device, s.options);
+                CE(this.device, s.options);
                 break;
             case "copy-texture-to-texture":
-                Px(this.device, s.options);
+                IE(this.device, s.options);
                 break
         }
     }
 };
 
-function Rx(t, e) {
-    let r = e.source,
-        s = e.destination;
-    t.gl.bindBuffer(36662, r.handle), t.gl.bindBuffer(36663, s.handle), t.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), t.gl.bindBuffer(36662, null), t.gl.bindBuffer(36663, null)
+function ME(e, t) {
+    let r = t.source,
+        s = t.destination;
+    e.gl.bindBuffer(36662, r.handle), e.gl.bindBuffer(36663, s.handle), e.gl.copyBufferSubData(36662, 36663, t.sourceOffset ?? 0, t.destinationOffset ?? 0, t.size), e.gl.bindBuffer(36662, null), e.gl.bindBuffer(36663, null)
 }
 
-function vx(t, e) {
+function PE(e, t) {
     throw new Error("Not implemented")
 }
 
-function Mx(t, e) {
+function CE(e, t) {
     let {
         source: r,
         mipLevel: s = 0,
         aspect: i = "all",
-        width: n = e.source.width,
-        height: o = e.source.height,
+        width: n = t.source.width,
+        height: o = t.source.height,
         depthOrArrayLayers: a = 0,
         origin: c = [0, 0],
         destination: l,
-        byteOffset: h = 0,
+        byteOffset: f = 0,
         bytesPerRow: d,
         rowsPerImage: p
-    } = e;
+    } = t;
     if (i !== "all") throw new Error("not supported");
     if (s !== 0 || a !== 0 || d || p) throw new Error("not implemented");
     let {
         framebuffer: m,
         destroyFramebuffer: y
-    } = gg(r), x;
+    } = g_(r), E;
     try {
-        let b = l,
-            w = n || m.width,
+        let T = l,
+            S = n || m.width,
             R = o || m.height,
-            v = Ss(m.texture.props.format),
+            v = xs(m.texture.props.format),
             C = v.dataFormat,
             O = v.type;
-        t.gl.bindBuffer(35051, b.handle), x = t.gl.bindFramebuffer(36160, m.handle), t.gl.readPixels(c[0], c[1], w, R, C, O, h)
+        e.gl.bindBuffer(35051, T.handle), E = e.gl.bindFramebuffer(36160, m.handle), e.gl.readPixels(c[0], c[1], S, R, C, O, f)
     } finally {
-        t.gl.bindBuffer(35051, null), x !== void 0 && t.gl.bindFramebuffer(36160, x), y && m.destroy()
+        e.gl.bindBuffer(35051, null), E !== void 0 && e.gl.bindFramebuffer(36160, E), y && m.destroy()
     }
 }
 
-function Px(t, e) {
+function IE(e, t) {
     let {
         source: r,
         destinationMipLevel: s = 0,
         origin: i = [0, 0],
         destinationOrigin: n = [0, 0],
         destination: o
-    } = e, {
-        width: a = e.destination.width,
-        height: c = e.destination.height
-    } = e, {
+    } = t, {
+        width: a = t.destination.width,
+        height: c = t.destination.height
+    } = t, {
         framebuffer: l,
-        destroyFramebuffer: h
-    } = gg(r), [d, p] = i, [m, y, x] = n, b = t.gl.bindFramebuffer(36160, l.handle), w = null, R;
-    if (o instanceof Re) w = o, a = Number.isFinite(a) ? a : w.width, c = Number.isFinite(c) ? c : w.height, w.bind(0), R = w.target;
+        destroyFramebuffer: f
+    } = g_(r), [d, p] = i, [m, y, E] = n, T = e.gl.bindFramebuffer(36160, l.handle), S = null, R;
+    if (o instanceof Rt) S = o, a = Number.isFinite(a) ? a : S.width, c = Number.isFinite(c) ? c : S.height, S.bind(0), R = S.target;
     else throw new Error("invalid destination");
     switch (R) {
         case 3553:
         case 34067:
-            t.gl.copyTexSubImage2D(R, s, m, y, d, p, a, c);
+            e.gl.copyTexSubImage2D(R, s, m, y, d, p, a, c);
             break;
         case 35866:
         case 32879:
-            t.gl.copyTexSubImage3D(R, s, m, y, x, d, p, a, c);
+            e.gl.copyTexSubImage3D(R, s, m, y, E, d, p, a, c);
             break;
         default:
     }
-    w && w.unbind(), t.gl.bindFramebuffer(36160, b), h && l.destroy()
+    S && S.unbind(), e.gl.bindFramebuffer(36160, T), f && l.destroy()
 }
 
-function gg(t) {
-    if (t instanceof se) {
+function g_(e) {
+    if (e instanceof st) {
         let {
-            width: e,
+            width: t,
             height: r,
             id: s
-        } = t;
+        } = e;
         return {
-            framebuffer: t.device.createFramebuffer({
+            framebuffer: e.device.createFramebuffer({
                 id: `framebuffer-for-${s}`,
-                width: e,
+                width: t,
                 height: r,
-                colorAttachments: [t]
+                colorAttachments: [e]
             }),
             destroyFramebuffer: !0
         }
     }
     return {
-        framebuffer: t,
+        framebuffer: e,
         destroyFramebuffer: !1
     }
 }
 var ya = class extends ii {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "commandBuffer");
-        this.device = r, this.commandBuffer = new Ta(r)
+        h(this, "device");
+        h(this, "commandBuffer");
+        this.device = r, this.commandBuffer = new ba(r)
     }
     destroy() {}
     finish() {
         this.commandBuffer.submitCommands()
     }
     copyBufferToBuffer(r) {
         this.commandBuffer.commands.push({
@@ -19041,28 +19041,28 @@
         })
     }
     pushDebugGroup(r) {}
     popDebugGroup() {}
     insertDebugMarker(r) {}
     resolveQuerySet(r, s, i) {}
 };
-var ba = class t extends oi {
+var Ta = class e extends oi {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "handle");
-        f(this, "buffer", null);
-        f(this, "bufferValue", null);
+        h(this, "device");
+        h(this, "handle");
+        h(this, "buffer", null);
+        h(this, "bufferValue", null);
         this.device = r, this.handle = this.device.gl.createVertexArray()
     }
     get[Symbol.toStringTag]() {
         return "VertexArray"
     }
     static isConstantAttributeZeroSupported(r) {
-        return fc() === "Chrome"
+        return hc() === "Chrome"
     }
     destroy() {
         super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0)
     }
     setIndexBuffer(r) {
         let s = r;
         if (s && s.glTarget !== 34963) throw new Error("Use .setBuffer()");
@@ -19073,18 +19073,18 @@
         if (i.glTarget === 34963) throw new Error("Use .setIndexBuffer()");
         let {
             size: n,
             type: o,
             stride: a,
             offset: c,
             normalized: l,
-            integer: h,
+            integer: f,
             divisor: d
         } = this._getAccessor(r);
-        this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), h ? this.device.gl.vertexAttribIPointer(r, n, o, a, c) : this.device.gl.vertexAttribPointer(r, n, o, l, a, c), this.device.gl.enableVertexAttribArray(r), this.device.gl.vertexAttribDivisor(r, d || 0), this.attributes[r] = i, this.device.gl.bindVertexArray(null)
+        this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), f ? this.device.gl.vertexAttribIPointer(r, n, o, a, c) : this.device.gl.vertexAttribPointer(r, n, o, l, a, c), this.device.gl.enableVertexAttribArray(r), this.device.gl.vertexAttribDivisor(r, d || 0), this.attributes[r] = i, this.device.gl.bindVertexArray(null)
     }
     setConstantWebGL(r, s) {
         this._enable(r, !1), this.attributes[r] = s
     }
     bindBeforeRender() {
         this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes()
     }
@@ -19108,66 +19108,66 @@
             offset: s.byteOffset,
             normalized: s.normalized,
             integer: s.integer,
             divisor: s.stepMode === "instance" ? 1 : 0
         }
     }
     _enable(r, s = !0) {
-        let n = t.isConstantAttributeZeroSupported(this.device) || r !== 0;
+        let n = e.isConstantAttributeZeroSupported(this.device) || r !== 0;
         (s || n) && (r = Number(r), this.device.gl.bindVertexArray(this.handle), s ? this.device.gl.enableVertexAttribArray(r) : this.device.gl.disableVertexAttribArray(r), this.device.gl.bindVertexArray(null))
     }
     getConstantBuffer(r, s) {
-        let i = Cx(s),
+        let i = OE(s),
             n = i.byteLength * r,
             o = i.length * r;
         if (this.buffer && n !== this.buffer.byteLength) throw new Error(`Buffer size is immutable, byte length ${n} !== ${this.buffer.byteLength}.`);
         let a = !this.buffer;
         if (this.buffer = this.buffer || this.device.createBuffer({
                 byteLength: n
-            }), a = a || !Ix(i, this.bufferValue), a) {
-            let c = Hc(s.constructor, o);
-            jc({
+            }), a = a || !NE(i, this.bufferValue), a) {
+            let c = jc(s.constructor, o);
+            Hc({
                 target: c,
                 source: i,
                 start: 0,
                 count: o
             }), this.buffer.write(c), this.bufferValue = s
         }
         return this.buffer
     }
 };
 
-function Cx(t) {
-    return Array.isArray(t) ? new Float32Array(t) : t
+function OE(e) {
+    return Array.isArray(e) ? new Float32Array(e) : e
 }
 
-function Ix(t, e) {
-    if (!t || !e || t.length !== e.length || t.constructor !== e.constructor) return !1;
-    for (let r = 0; r < t.length; ++r)
-        if (t[r] !== e[r]) return !1;
+function NE(e, t) {
+    if (!e || !t || e.length !== t.length || e.constructor !== t.constructor) return !1;
+    for (let r = 0; r < e.length; ++r)
+        if (e[r] !== t[r]) return !1;
     return !0
 }
-var Ea = class extends ai {
+var wa = class extends ai {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "gl");
-        f(this, "handle");
-        f(this, "layout");
-        f(this, "buffers", {});
-        f(this, "unusedBuffers", {});
-        f(this, "bindOnUse", !0);
-        f(this, "_bound", !1);
+        h(this, "device");
+        h(this, "gl");
+        h(this, "handle");
+        h(this, "layout");
+        h(this, "buffers", {});
+        h(this, "unusedBuffers", {});
+        h(this, "bindOnUse", !0);
+        h(this, "_bound", !1);
         this.device = r, this.gl = r.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, s.buffers && this.setBuffers(s.buffers), Object.seal(this)
     }
     destroy() {
         this.gl.deleteTransformFeedback(this.handle), super.destroy()
     }
     begin(r = "point-list") {
-        this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(dg(r))
+        this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(p_(r))
     }
     end() {
         this.gl.endTransformFeedback(), this.bindOnUse || this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null)
     }
     setBuffers(r) {
         this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
             for (let s in r) this.setBuffer(s, r[s])
@@ -19187,28 +19187,28 @@
         this.buffers[i] = {
             buffer: n,
             byteLength: o,
             byteOffset: a
         }, this.bindOnUse || this._bindBuffer(i, n, a, o)
     }
     getBuffer(r) {
-        if (_g(r)) return this.buffers[r] || null;
+        if (m_(r)) return this.buffers[r] || null;
         let s = this._getVaryingIndex(r);
         return s >= 0 ? this.buffers[s] : null
     }
     bind(r = this.handle) {
         if (typeof r != "function") return this.gl.bindTransformFeedback(36386, r), this;
         let s;
         return this._bound ? s = r() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, s = r(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), s
     }
     unbind() {
         this.bind(null)
     }
     _getBufferRange(r) {
-        if (r instanceof Ae) return {
+        if (r instanceof At) return {
             buffer: r,
             byteOffset: 0,
             byteLength: r.byteLength
         };
         let {
             buffer: s,
             byteOffset: i = 0,
@@ -19217,15 +19217,15 @@
         return {
             buffer: s,
             byteOffset: i,
             byteLength: n
         }
     }
     _getVaryingIndex(r) {
-        if (_g(r)) return Number(r);
+        if (m_(r)) return Number(r);
         for (let s of this.layout.varyings)
             if (r === s.name) return s.location;
         return -1
     }
     _bindBuffers() {
         for (let r in this.buffers) {
             let {
@@ -19241,25 +19241,25 @@
     }
     _bindBuffer(r, s, i = 0, n) {
         let o = s && s.handle;
         !o || n === void 0 ? this.gl.bindBufferBase(35982, r, o) : this.gl.bindBufferRange(35982, r, o, i, n)
     }
 };
 
-function _g(t) {
-    return typeof t == "number" ? Number.isInteger(t) : /^\d+$/.test(t)
+function m_(e) {
+    return typeof e == "number" ? Number.isInteger(e) : /^\d+$/.test(e)
 }
 var Aa = class extends ci {
     constructor(r, s) {
         super(r, s);
-        f(this, "device");
-        f(this, "handle");
-        f(this, "target", null);
-        f(this, "_queryPending", !1);
-        f(this, "_pollingPromise", null);
+        h(this, "device");
+        h(this, "handle");
+        h(this, "target", null);
+        h(this, "_queryPending", !1);
+        h(this, "_pollingPromise", null);
         if (this.device = r, s.count > 1) throw new Error("WebGL QuerySet can only have one value");
         this.handle = this.device.gl.createQuery(), Object.seal(this)
     }
     get[Symbol.toStringTag]() {
         return "Query"
     }
     destroy() {
@@ -19314,16 +19314,16 @@
                 this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : s++ > r ? (n("Timed out"), this._pollingPromise = null) : requestAnimationFrame(o)
             };
             requestAnimationFrame(o)
         }), this._pollingPromise
     }
 };
 
-function Wh(t) {
-    switch (t) {
+function zf(e) {
+    switch (e) {
         case 6406:
         case 33326:
         case 6403:
             return 1;
         case 33328:
         case 33319:
             return 2;
@@ -19334,225 +19334,225 @@
         case 34836:
             return 4;
         default:
             return z(!1), 0
     }
 }
 
-function mg(t) {
-    switch (t) {
+function b_(e) {
+    switch (e) {
         case 5121:
             return 1;
         case 33635:
         case 32819:
         case 32820:
             return 2;
         case 5126:
             return 4;
         default:
             return z(!1), 0
     }
 }
 
-function Tg(t, e) {
+function y_(e, t) {
     let {
         sourceX: r = 0,
         sourceY: s = 0,
         sourceFormat: i = 6408,
         sourceAttachment: n = 36064
-    } = e || {}, {
+    } = t || {}, {
         target: o = null,
         sourceWidth: a,
         sourceHeight: c,
         sourceType: l
-    } = e || {}, {
-        framebuffer: h,
+    } = t || {}, {
+        framebuffer: f,
         deleteFramebuffer: d
-    } = bg(t);
-    z(h);
+    } = w_(e);
+    z(f);
     let {
         gl: p,
         handle: m
-    } = h;
-    a = a || h.width, c = c || h.height;
+    } = f;
+    a = a || f.width, c = c || f.height;
     let y = n - 36064;
-    l = l || h.colorAttachments[y]?.texture?.type || 5121, o = Nx(o, l, i, a, c), l = l || og(o);
-    let x = p.bindFramebuffer(36160, m);
-    return p.readPixels(r, s, a, c, i, l, o), p.bindFramebuffer(36160, x || null), d && h.destroy(), o
+    l = l || f.colorAttachments[y]?.texture?.type || 5121, o = kE(o, l, i, a, c), l = l || a_(o);
+    let E = p.bindFramebuffer(36160, m);
+    return p.readPixels(r, s, a, c, i, l, o), p.bindFramebuffer(36160, E || null), d && f.destroy(), o
 }
 
-function yg(t, e) {
+function T_(e, t) {
     let {
         target: r,
         sourceX: s = 0,
         sourceY: i = 0,
         sourceFormat: n = 6408,
         targetByteOffset: o = 0
-    } = e || {}, {
+    } = t || {}, {
         sourceWidth: a,
         sourceHeight: c,
         sourceType: l
-    } = e || {}, {
-        framebuffer: h,
+    } = t || {}, {
+        framebuffer: f,
         deleteFramebuffer: d
-    } = bg(t);
-    z(h), a = a || h.width, c = c || h.height;
-    let p = h;
+    } = w_(e);
+    z(f), a = a || f.width, c = c || f.height;
+    let p = f;
     l = l || 5121;
     let m = r;
     if (!m) {
-        let x = Wh(n),
-            b = mg(l),
-            w = o + a * c * x * b;
+        let E = zf(n),
+            T = b_(l),
+            S = o + a * c * E * T;
         m = p.device.createBuffer({
-            byteLength: w
+            byteLength: S
         })
     }
-    let y = t.device.createCommandEncoder();
+    let y = e.device.createCommandEncoder();
     return y.copyTextureToBuffer({
-        source: t,
+        source: e,
         width: a,
         height: c,
         origin: [s, i],
         destination: m,
         byteOffset: o
-    }), y.destroy(), d && h.destroy(), m
+    }), y.destroy(), d && f.destroy(), m
 }
 
-function bg(t) {
-    return t instanceof xr ? {
-        framebuffer: t,
+function w_(e) {
+    return e instanceof Er ? {
+        framebuffer: e,
         deleteFramebuffer: !1
     } : {
-        framebuffer: Ox(t),
+        framebuffer: FE(e),
         deleteFramebuffer: !0
     }
 }
 
-function Ox(t, e) {
+function FE(e, t) {
     let {
         device: r,
         width: s,
         height: i,
         id: n
-    } = t;
+    } = e;
     return r.createFramebuffer({
-        ...e,
+        ...t,
         id: `framebuffer-for-${n}`,
         width: s,
         height: i,
-        colorAttachments: [t]
+        colorAttachments: [e]
     })
 }
 
-function Nx(t, e, r, s, i) {
-    if (t) return t;
-    e = e || 5121;
-    let n = Ki(e, {
+function kE(e, t, r, s, i) {
+    if (e) return e;
+    t = t || 5121;
+    let n = Ki(t, {
             clamped: !1
         }),
-        o = Wh(r);
+        o = zf(r);
     return new n(s * i * o)
 }
-var Fx = 256,
-    Dx = 1024,
-    kx = 16384;
-var Bx = "clear: bad arguments";
+var DE = 256,
+    BE = 1024,
+    UE = 16384;
+var LE = "clear: bad arguments";
 
-function Eg(t, e) {
+function A_(e, t) {
     let {
         framebuffer: r = null,
         color: s = null,
         depth: i = null,
         stencil: n = null
-    } = e || {}, o = {};
+    } = t || {}, o = {};
     r && (o.framebuffer = r);
     let a = 0;
-    s && (a |= kx, s !== !0 && (o.clearColor = s)), i && (a |= Fx, i !== !0 && (o.clearDepth = i)), n && (a |= Dx, i !== !0 && (o.clearStencil = i)), z(a !== 0, Bx);
-    let c = t.gl;
-    He(c, o, () => {
+    s && (a |= UE, s !== !0 && (o.clearColor = s)), i && (a |= DE, i !== !0 && (o.clearDepth = i)), n && (a |= BE, i !== !0 && (o.clearStencil = i)), z(a !== 0, LE);
+    let c = e.gl;
+    jt(c, o, () => {
         c.clear(a)
     })
 }
 var Zi = 1,
-    Br = class Br extends ot {
+    Br = class Br extends oe {
         constructor(r) {
             super({
                 ...r,
-                id: r.id || Ee("webgl-device")
+                id: r.id || wt("webgl-device")
             });
-            f(this, "type", "webgl");
-            f(this, "handle");
-            f(this, "features");
-            f(this, "limits");
-            f(this, "info");
-            f(this, "canvasContext");
-            f(this, "lost");
-            f(this, "_resolveContextLost");
-            f(this, "renderPass", null);
-            f(this, "gl");
-            f(this, "debug", !1);
-            f(this, "_canvasSizeInfo", {
+            h(this, "type", "webgl");
+            h(this, "handle");
+            h(this, "features");
+            h(this, "limits");
+            h(this, "info");
+            h(this, "canvasContext");
+            h(this, "lost");
+            h(this, "_resolveContextLost");
+            h(this, "renderPass", null);
+            h(this, "gl");
+            h(this, "debug", !1);
+            h(this, "_canvasSizeInfo", {
                 clientWidth: 0,
                 clientHeight: 0,
                 devicePixelRatio: 1
             });
-            f(this, "_extensions", {});
-            f(this, "_polyfilled", !1);
-            f(this, "spectorJS");
-            f(this, "_constants");
+            h(this, "_extensions", {});
+            h(this, "_polyfilled", !1);
+            h(this, "spectorJS");
+            h(this, "_constants");
             let s = r.gl?.device;
             if (s) throw new Error(`WebGL context already attached to device ${s.id}`);
             let i = r.gl?.canvas || r.canvas;
             this.canvasContext = new da(this, {
                 ...r,
                 canvas: i
             }), this.lost = new Promise(c => {
                 this._resolveContextLost = c
             });
             let n = r.gl || null;
-            if (n || (n = Bp(this.canvasContext.canvas, {
+            if (n || (n = Up(this.canvasContext.canvas, {
                     ...r,
                     onContextLost: c => this._resolveContextLost?.({
                         reason: "destroyed",
                         message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
                     })
                 })), !n) throw new Error("WebGL context creation failed");
-            this.handle = n, this.gl = n, this.gl.device = this, this.gl._version = 2, this.info = Up(this.gl, this._extensions), this.limits = new la(this.gl), this.features = new ca(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
+            this.handle = n, this.gl = n, this.gl.device = this, this.gl._version = 2, this.info = Lp(this.gl, this._extensions), this.limits = new la(this.gl), this.features = new ca(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
             let {
                 enable: o = !0,
                 copyState: a = !1
             } = r;
-            Ph(this.gl, {
+            Cf(this.gl, {
                 enable: o,
                 copyState: a,
                 log: (...c) => P.log(1, ...c)()
-            }), r.debug && (this.gl = sg(this.gl, {
+            }), r.debug && (this.gl = i_(this.gl, {
                 ...r,
                 throwOnError: !0
-            }), this.debug = !0, P.level = Math.max(P.level, 1), P.warn("WebGL debug mode activated. Performance reduced.")()), r.spector && (this.spectorJS = eg({
+            }), this.debug = !0, P.level = Math.max(P.level, 1), P.warn("WebGL debug mode activated. Performance reduced.")()), r.spector && (this.spectorJS = e_({
                 ...this.props,
                 canvas: this.handle.canvas
             }))
         }
         static isSupported() {
             return typeof WebGL2RenderingContext < "u"
         }
         static attach(r) {
             if (r instanceof Br) return r;
-            if (r?.device instanceof ot) return r.device;
-            if (!Ux(r)) throw new Error("Invalid WebGL2RenderingContext");
+            if (r?.device instanceof oe) return r.device;
+            if (!VE(r)) throw new Error("Invalid WebGL2RenderingContext");
             return new Br({
                 gl: r
             })
         }
         static async create(r = {}) {
             P.groupCollapsed(Zi, "WebGLDevice created")();
             let s = [];
-            r.debug && s.push(rg()), r.spector && s.push(Gp()), typeof r.canvas == "string" && s.push(Wt.pageLoaded);
+            r.debug && s.push(s_()), r.spector && s.push(t_()), typeof r.canvas == "string" && s.push(We.pageLoaded);
             let i = await Promise.allSettled(s);
             for (let a of i) a.status === "rejected" && P.error(`Failed to initialize debug libraries ${a.reason}`)();
             if (P.probe(Zi + 1, "DOM is loaded")(), r.gl?.device) return P.warn("reattaching existing device")(), Br.attach(r.gl);
             let n = new Br(r),
                 o = `Created ${n.type}${n.debug?" debug":""} context: ${n.info.vendor}, ${n.info.renderer} for canvas: ${n.canvasContext.id}`;
             return P.probe(Zi, o)(), P.table(Zi, n.info)(), P.groupEnd(Zi)(), n
         }
@@ -19563,102 +19563,102 @@
         getSize() {
             return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight]
         }
         isTextureFormatSupported(r) {
             return aa(this.gl, r, this._extensions)
         }
         isTextureFormatFilterable(r) {
-            return Xp(this.gl, r, this._extensions)
+            return $p(this.gl, r, this._extensions)
         }
         isTextureFormatRenderable(r) {
-            return $p(this.gl, r, this._extensions)
+            return Yp(this.gl, r, this._extensions)
         }
         createCanvasContext(r) {
             throw new Error("WebGL only supports a single canvas")
         }
         createBuffer(r) {
             let s = this._getBufferProps(r);
-            return new Ae(this, s)
+            return new At(this, s)
         }
         _createTexture(r) {
-            return new Re(this, r)
+            return new Rt(this, r)
         }
         createExternalTexture(r) {
             throw new Error("createExternalTexture() not implemented")
         }
         createSampler(r) {
-            return new kr(this, r)
+            return new Dr(this, r)
         }
         createShader(r) {
             return new pa(this, r)
         }
         createFramebuffer(r) {
-            return new _t(this, r)
+            return new ge(this, r)
         }
         createVertexArray(r) {
-            return new ba(this, r)
+            return new Ta(this, r)
         }
         createTransformFeedback(r) {
-            return new Ea(this, r)
+            return new wa(this, r)
         }
         createQuerySet(r) {
             return new Aa(this, r)
         }
         createRenderPipeline(r) {
             return new ma(this, r)
         }
         beginRenderPass(r) {
-            return new ga(this, r)
+            return new _a(this, r)
         }
         createComputePipeline(r) {
             throw new Error("ComputePipeline not supported in WebGL")
         }
         beginComputePass(r) {
             throw new Error("ComputePass not supported in WebGL")
         }
         createCommandEncoder(r) {
             return new ya(this, r)
         }
         submit() {
             this.renderPass?.end(), this.renderPass = null
         }
         readPixelsToArrayWebGL(r, s) {
-            return Tg(r, s)
+            return y_(r, s)
         }
         readPixelsToBufferWebGL(r, s) {
-            return yg(r, s)
+            return T_(r, s)
         }
         setParametersWebGL(r) {
-            Ke(this.gl, r)
+            Kt(this.gl, r)
         }
         getParametersWebGL(r) {
-            return ta(this.gl, r)
+            return ea(this.gl, r)
         }
         withParametersWebGL(r, s) {
-            return He(this.gl, r, s)
+            return jt(this.gl, r, s)
         }
         clearWebGL(r) {
-            Eg(this, r)
+            A_(this, r)
         }
         resetWebGL() {
-            P.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), Fp(this.gl)
+            P.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), kp(this.gl)
         }
         loseDevice() {
             let r = !1,
                 i = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
             return i && (r = !0, i.loseContext()), this._resolveContextLost?.({
                 reason: "destroyed",
                 message: "Application triggered context loss"
             }), r
         }
         pushState() {
             rr(this.gl)
         }
         popState() {
-            Ot(this.gl)
+            Oe(this.gl)
         }
         setSpectorMetadata(r, s) {
             r.__SPECTOR_Metadata = s
         }
         getGLKey(r, s) {
             s = s || this.gl2 || this.gl;
             let i = Number(r);
@@ -19666,180 +19666,180 @@
                 if (s[n] === i) return `GL.${n}`;
             return String(r)
         }
         setConstantAttributeWebGL(r, s) {
             let i = this.limits.maxVertexAttributes;
             this._constants = this._constants || new Array(i).fill(null);
             let n = this._constants[r];
-            switch (n && zx(n, s) && P.info(1, `setConstantAttributeWebGL(${r}) could have been skipped, value unchanged`)(), this._constants[r] = s, s.constructor) {
+            switch (n && HE(n, s) && P.info(1, `setConstantAttributeWebGL(${r}) could have been skipped, value unchanged`)(), this._constants[r] = s, s.constructor) {
                 case Float32Array:
-                    Lx(this, r, s);
+                    WE(this, r, s);
                     break;
                 case Int32Array:
-                    Vx(this, r, s);
+                    zE(this, r, s);
                     break;
                 case Uint32Array:
-                    Wx(this, r, s);
+                    jE(this, r, s);
                     break;
                 default:
                     z(!1)
             }
         }
         getExtension(r) {
-            return ze(this.gl, r, this._extensions), this._extensions
+            return zt(this.gl, r, this._extensions), this._extensions
         }
     };
-f(Br, "type", "webgl");
+h(Br, "type", "webgl");
 var Ur = Br;
 
-function Ux(t) {
-    return typeof WebGL2RenderingContext < "u" && t instanceof WebGL2RenderingContext ? !0 : !!(t && Number.isFinite(t._version))
+function VE(e) {
+    return typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext ? !0 : !!(e && Number.isFinite(e._version))
 }
 
-function Lx(t, e, r) {
+function WE(e, t, r) {
     switch (r.length) {
         case 1:
-            t.gl.vertexAttrib1fv(e, r);
+            e.gl.vertexAttrib1fv(t, r);
             break;
         case 2:
-            t.gl.vertexAttrib2fv(e, r);
+            e.gl.vertexAttrib2fv(t, r);
             break;
         case 3:
-            t.gl.vertexAttrib3fv(e, r);
+            e.gl.vertexAttrib3fv(t, r);
             break;
         case 4:
-            t.gl.vertexAttrib4fv(e, r);
+            e.gl.vertexAttrib4fv(t, r);
             break;
         default:
             z(!1)
     }
 }
 
-function Vx(t, e, r) {
-    t.gl.vertexAttribI4iv(e, r)
+function zE(e, t, r) {
+    e.gl.vertexAttribI4iv(t, r)
 }
 
-function Wx(t, e, r) {
-    t.gl.vertexAttribI4uiv(e, r)
+function jE(e, t, r) {
+    e.gl.vertexAttribI4uiv(t, r)
 }
 
-function zx(t, e) {
-    if (!t || !e || t.length !== e.length || t.constructor !== e.constructor) return !1;
-    for (let r = 0; r < t.length; ++r)
-        if (t[r] !== e[r]) return !1;
+function HE(e, t) {
+    if (!e || !t || e.length !== t.length || e.constructor !== t.constructor) return !1;
+    for (let r = 0; r < e.length; ++r)
+        if (e[r] !== t[r]) return !1;
     return !0
 }
-var Lr = im(Ag());
-var Hx = {
+var Lr = om(E_());
+var XE = {
     mousedown: 1,
     mousemove: 2,
     mouseup: 4
 };
 
-function jx(t, e) {
-    for (let r = 0; r < t.length; r++)
-        if (e(t[r])) return !0;
+function $E(e, t) {
+    for (let r = 0; r < e.length; r++)
+        if (t(e[r])) return !0;
     return !1
 }
 
-function xg(t) {
-    let e = t.prototype.handler;
-    t.prototype.handler = function(s) {
+function x_(e) {
+    let t = e.prototype.handler;
+    e.prototype.handler = function(s) {
         let i = this.store;
-        s.button > 0 && s.type === "pointerdown" && (jx(i, n => n.pointerId === s.pointerId) || i.push(s)), e.call(this, s)
+        s.button > 0 && s.type === "pointerdown" && ($E(i, n => n.pointerId === s.pointerId) || i.push(s)), t.call(this, s)
     }
 }
 
-function Sg(t) {
-    t.prototype.handler = function(r) {
-        let s = Hx[r.type];
+function S_(e) {
+    e.prototype.handler = function(r) {
+        let s = XE[r.type];
         s & 1 && r.button >= 0 && (this.pressed = !0), s & 2 && r.which === 0 && (s = 4), this.pressed && (s & 4 && (this.pressed = !1), this.callback(this.manager, s, {
             pointers: [r],
             changedPointers: [r],
             pointerType: "mouse",
             srcEvent: r
         }))
     }
 }
-xg(Lr.PointerEventInput);
-Sg(Lr.MouseInput);
-var wg = Lr.Manager,
-    Qe = Lr;
-var Je = class {
-    constructor(e, r, s) {
-        this.element = e, this.callback = r, this.options = {
+x_(Lr.PointerEventInput);
+S_(Lr.MouseInput);
+var R_ = Lr.Manager,
+    Qt = Lr;
+var Jt = class {
+    constructor(t, r, s) {
+        this.element = t, this.callback = r, this.options = {
             enable: !0,
             ...s
         }
     }
 };
-var Rg = Qe ? [
-        [Qe.Pan, {
+var v_ = Qt ? [
+        [Qt.Pan, {
             event: "tripan",
             pointers: 3,
             threshold: 0,
             enable: !1
         }],
-        [Qe.Rotate, {
+        [Qt.Rotate, {
             enable: !1
         }],
-        [Qe.Pinch, {
+        [Qt.Pinch, {
             enable: !1
         }],
-        [Qe.Swipe, {
+        [Qt.Swipe, {
             enable: !1
         }],
-        [Qe.Pan, {
+        [Qt.Pan, {
             threshold: 0,
             enable: !1
         }],
-        [Qe.Press, {
+        [Qt.Press, {
             enable: !1
         }],
-        [Qe.Tap, {
+        [Qt.Tap, {
             event: "doubletap",
             taps: 2,
             enable: !1
         }],
-        [Qe.Tap, {
+        [Qt.Tap, {
             event: "anytap",
             enable: !1
         }],
-        [Qe.Tap, {
+        [Qt.Tap, {
             enable: !1
         }]
     ] : null,
-    zh = {
+    jf = {
         tripan: ["rotate", "pinch", "pan"],
         rotate: ["pinch"],
         pinch: ["pan"],
         pan: ["press", "doubletap", "anytap", "tap"],
         doubletap: ["anytap"],
         anytap: ["tap"]
     },
-    vg = {
+    M_ = {
         doubletap: ["tap"]
     },
-    Mg = {
+    P_ = {
         pointerdown: "pointerdown",
         pointermove: "pointermove",
         pointerup: "pointerup",
         touchstart: "pointerdown",
         touchmove: "pointermove",
         touchend: "pointerup",
         mousedown: "pointerdown",
         mousemove: "pointermove",
         mouseup: "pointerup"
     },
-    ws = {
+    Ss = {
         KEY_EVENTS: ["keydown", "keyup"],
         MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
         WHEEL_EVENTS: ["wheel", "mousewheel"]
     },
-    Pg = {
+    C_ = {
         tap: "tap",
         anytap: "anytap",
         doubletap: "doubletap",
         press: "press",
         pinch: "pinch",
         pinchin: "pinch",
         pinchout: "pinch",
@@ -19872,469 +19872,469 @@
         pancancel: "pan",
         swipe: "swipe",
         swipeleft: "swipe",
         swiperight: "swipe",
         swipeup: "swipe",
         swipedown: "swipe"
     },
-    Hh = {
+    Hf = {
         click: "tap",
         anyclick: "anytap",
         dblclick: "doubletap",
         mousedown: "pointerdown",
         mousemove: "pointermove",
         mouseup: "pointerup",
         mouseover: "pointerover",
         mouseout: "pointerout",
         mouseleave: "pointerleave"
     };
-var Cg = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
+var I_ = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
     Vr = typeof window < "u" ? window : global;
-var Sa = !1;
+var xa = !1;
 try {
-    let t = {
+    let e = {
         get passive() {
-            return Sa = !0, !0
+            return xa = !0, !0
         }
     };
-    Vr.addEventListener("test", null, t), Vr.removeEventListener("test", null)
+    Vr.addEventListener("test", null, e), Vr.removeEventListener("test", null)
 } catch {
-    Sa = !1
+    xa = !1
 }
-var Xx = Cg.indexOf("firefox") !== -1,
+var YE = I_.indexOf("firefox") !== -1,
     {
-        WHEEL_EVENTS: $x
-    } = ws,
-    Ig = "wheel",
-    Og = 4.000244140625,
-    Yx = 40,
-    qx = .25,
-    Qi = class extends Je {
-        constructor(e, r, s) {
-            super(e, r, s), this.handleEvent = i => {
+        WHEEL_EVENTS: qE
+    } = Ss,
+    O_ = "wheel",
+    N_ = 4.000244140625,
+    KE = 40,
+    ZE = .25,
+    Qi = class extends Jt {
+        constructor(t, r, s) {
+            super(t, r, s), this.handleEvent = i => {
                 if (!this.options.enable) return;
                 let n = i.deltaY;
-                Vr.WheelEvent && (Xx && i.deltaMode === Vr.WheelEvent.DOM_DELTA_PIXEL && (n /= Vr.devicePixelRatio), i.deltaMode === Vr.WheelEvent.DOM_DELTA_LINE && (n *= Yx)), n !== 0 && n % Og === 0 && (n = Math.floor(n / Og)), i.shiftKey && n && (n = n * qx), this.callback({
-                    type: Ig,
+                Vr.WheelEvent && (YE && i.deltaMode === Vr.WheelEvent.DOM_DELTA_PIXEL && (n /= Vr.devicePixelRatio), i.deltaMode === Vr.WheelEvent.DOM_DELTA_LINE && (n *= KE)), n !== 0 && n % N_ === 0 && (n = Math.floor(n / N_)), i.shiftKey && n && (n = n * ZE), this.callback({
+                    type: O_,
                     center: {
                         x: i.clientX,
                         y: i.clientY
                     },
                     delta: -n,
                     srcEvent: i,
                     pointerType: "mouse",
                     target: i.target
                 })
-            }, this.events = (this.options.events || []).concat($x), this.events.forEach(i => e.addEventListener(i, this.handleEvent, Sa ? {
+            }, this.events = (this.options.events || []).concat(qE), this.events.forEach(i => t.addEventListener(i, this.handleEvent, xa ? {
                 passive: !1
             } : !1))
         }
         destroy() {
-            this.events.forEach(e => this.element.removeEventListener(e, this.handleEvent))
+            this.events.forEach(t => this.element.removeEventListener(t, this.handleEvent))
         }
-        enableEventType(e, r) {
-            e === Ig && (this.options.enable = r)
+        enableEventType(t, r) {
+            t === O_ && (this.options.enable = r)
         }
     };
 var {
-    MOUSE_EVENTS: Kx
-} = ws, Ng = "pointermove", Fg = "pointerover", Dg = "pointerout", kg = "pointerenter", Bg = "pointerleave", Ji = class extends Je {
-    constructor(e, r, s) {
-        super(e, r, s), this.handleEvent = n => {
+    MOUSE_EVENTS: QE
+} = Ss, F_ = "pointermove", k_ = "pointerover", D_ = "pointerout", B_ = "pointerenter", U_ = "pointerleave", Ji = class extends Jt {
+    constructor(t, r, s) {
+        super(t, r, s), this.handleEvent = n => {
             this.handleOverEvent(n), this.handleOutEvent(n), this.handleEnterEvent(n), this.handleLeaveEvent(n), this.handleMoveEvent(n)
         }, this.pressed = !1;
         let {
             enable: i
         } = this.options;
-        this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, this.events = (this.options.events || []).concat(Kx), this.events.forEach(n => e.addEventListener(n, this.handleEvent))
+        this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, this.events = (this.options.events || []).concat(QE), this.events.forEach(n => t.addEventListener(n, this.handleEvent))
     }
     destroy() {
-        this.events.forEach(e => this.element.removeEventListener(e, this.handleEvent))
+        this.events.forEach(t => this.element.removeEventListener(t, this.handleEvent))
     }
-    enableEventType(e, r) {
-        e === Ng && (this.enableMoveEvent = r), e === Fg && (this.enableOverEvent = r), e === Dg && (this.enableOutEvent = r), e === kg && (this.enableEnterEvent = r), e === Bg && (this.enableLeaveEvent = r)
+    enableEventType(t, r) {
+        t === F_ && (this.enableMoveEvent = r), t === k_ && (this.enableOverEvent = r), t === D_ && (this.enableOutEvent = r), t === B_ && (this.enableEnterEvent = r), t === U_ && (this.enableLeaveEvent = r)
     }
-    handleOverEvent(e) {
-        this.enableOverEvent && e.type === "mouseover" && this._emit(Fg, e)
+    handleOverEvent(t) {
+        this.enableOverEvent && t.type === "mouseover" && this._emit(k_, t)
     }
-    handleOutEvent(e) {
-        this.enableOutEvent && e.type === "mouseout" && this._emit(Dg, e)
+    handleOutEvent(t) {
+        this.enableOutEvent && t.type === "mouseout" && this._emit(D_, t)
     }
-    handleEnterEvent(e) {
-        this.enableEnterEvent && e.type === "mouseenter" && this._emit(kg, e)
+    handleEnterEvent(t) {
+        this.enableEnterEvent && t.type === "mouseenter" && this._emit(B_, t)
     }
-    handleLeaveEvent(e) {
-        this.enableLeaveEvent && e.type === "mouseleave" && this._emit(Bg, e)
+    handleLeaveEvent(t) {
+        this.enableLeaveEvent && t.type === "mouseleave" && this._emit(U_, t)
     }
-    handleMoveEvent(e) {
-        if (this.enableMoveEvent) switch (e.type) {
+    handleMoveEvent(t) {
+        if (this.enableMoveEvent) switch (t.type) {
             case "mousedown":
-                e.button >= 0 && (this.pressed = !0);
+                t.button >= 0 && (this.pressed = !0);
                 break;
             case "mousemove":
-                e.which === 0 && (this.pressed = !1), this.pressed || this._emit(Ng, e);
+                t.which === 0 && (this.pressed = !1), this.pressed || this._emit(F_, t);
                 break;
             case "mouseup":
                 this.pressed = !1;
                 break;
             default:
         }
     }
-    _emit(e, r) {
+    _emit(t, r) {
         this.callback({
-            type: e,
+            type: t,
             center: {
                 x: r.clientX,
                 y: r.clientY
             },
             srcEvent: r,
             pointerType: "mouse",
             target: r.target
         })
     }
 };
 var {
-    KEY_EVENTS: Zx
-} = ws, Ug = "keydown", Lg = "keyup", Gi = class extends Je {
-    constructor(e, r, s) {
-        super(e, r, s), this.handleEvent = i => {
+    KEY_EVENTS: JE
+} = Ss, L_ = "keydown", V_ = "keyup", Gi = class extends Jt {
+    constructor(t, r, s) {
+        super(t, r, s), this.handleEvent = i => {
             let n = i.target || i.srcElement;
             n.tagName === "INPUT" && n.type === "text" || n.tagName === "TEXTAREA" || (this.enableDownEvent && i.type === "keydown" && this.callback({
-                type: Ug,
+                type: L_,
                 srcEvent: i,
                 key: i.key,
                 target: i.target
             }), this.enableUpEvent && i.type === "keyup" && this.callback({
-                type: Lg,
+                type: V_,
                 srcEvent: i,
                 key: i.key,
                 target: i.target
             }))
-        }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(Zx), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach(i => e.addEventListener(i, this.handleEvent))
+        }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(JE), t.tabIndex = this.options.tabIndex || 0, t.style.outline = "none", this.events.forEach(i => t.addEventListener(i, this.handleEvent))
     }
     destroy() {
-        this.events.forEach(e => this.element.removeEventListener(e, this.handleEvent))
+        this.events.forEach(t => this.element.removeEventListener(t, this.handleEvent))
     }
-    enableEventType(e, r) {
-        e === Ug && (this.enableDownEvent = r), e === Lg && (this.enableUpEvent = r)
+    enableEventType(t, r) {
+        t === L_ && (this.enableDownEvent = r), t === V_ && (this.enableUpEvent = r)
     }
 };
-var Vg = "contextmenu",
-    en = class extends Je {
-        constructor(e, r, s) {
-            super(e, r, s), this.handleEvent = i => {
+var W_ = "contextmenu",
+    tn = class extends Jt {
+        constructor(t, r, s) {
+            super(t, r, s), this.handleEvent = i => {
                 this.options.enable && this.callback({
-                    type: Vg,
+                    type: W_,
                     center: {
                         x: i.clientX,
                         y: i.clientY
                     },
                     srcEvent: i,
                     pointerType: "mouse",
                     target: i.target
                 })
-            }, e.addEventListener("contextmenu", this.handleEvent)
+            }, t.addEventListener("contextmenu", this.handleEvent)
         }
         destroy() {
             this.element.removeEventListener("contextmenu", this.handleEvent)
         }
-        enableEventType(e, r) {
-            e === Vg && (this.options.enable = r)
+        enableEventType(t, r) {
+            t === W_ && (this.options.enable = r)
         }
     };
-var Qx = {
+var GE = {
         pointerdown: 1,
         pointermove: 2,
         pointerup: 4,
         mousedown: 1,
         mousemove: 2,
         mouseup: 4
     },
-    Jx = 1,
-    Gx = 2,
-    e1 = 3,
-    t1 = 0,
-    r1 = 1,
-    s1 = 2,
+    t1 = 1,
+    e1 = 2,
+    r1 = 3,
+    s1 = 0,
     i1 = 1,
     n1 = 2,
-    o1 = 4;
+    o1 = 1,
+    a1 = 2,
+    c1 = 4;
 
-function Wg(t) {
-    let e = Qx[t.srcEvent.type];
-    if (!e) return null;
+function z_(e) {
+    let t = GE[e.srcEvent.type];
+    if (!t) return null;
     let {
         buttons: r,
         button: s,
         which: i
-    } = t.srcEvent, n = !1, o = !1, a = !1;
-    return e === 4 || e === 2 && !Number.isFinite(r) ? (n = i === Jx, o = i === Gx, a = i === e1) : e === 2 ? (n = !!(r & i1), o = !!(r & o1), a = !!(r & n1)) : e === 1 && (n = s === t1, o = s === r1, a = s === s1), {
+    } = e.srcEvent, n = !1, o = !1, a = !1;
+    return t === 4 || t === 2 && !Number.isFinite(r) ? (n = i === t1, o = i === e1, a = i === r1) : t === 2 ? (n = !!(r & o1), o = !!(r & c1), a = !!(r & a1)) : t === 1 && (n = s === s1, o = s === i1, a = s === n1), {
         leftButton: n,
         middleButton: o,
         rightButton: a
     }
 }
 
-function zg(t, e) {
-    let r = t.center;
+function j_(e, t) {
+    let r = e.center;
     if (!r) return null;
-    let s = e.getBoundingClientRect(),
-        i = s.width / e.offsetWidth || 1,
-        n = s.height / e.offsetHeight || 1,
+    let s = t.getBoundingClientRect(),
+        i = s.width / t.offsetWidth || 1,
+        n = s.height / t.offsetHeight || 1,
         o = {
-            x: (r.x - s.left - e.clientLeft) / i,
-            y: (r.y - s.top - e.clientTop) / n
+            x: (r.x - s.left - t.clientLeft) / i,
+            y: (r.y - s.top - t.clientTop) / n
         };
     return {
         center: r,
         offsetCenter: o
     }
 }
-var jh = {
+var Xf = {
         srcElement: "root",
         priority: 0
     },
-    tn = class {
-        constructor(e) {
+    en = class {
+        constructor(t) {
             this.handleEvent = r => {
                 if (this.isEmpty()) return;
                 let s = this._normalizeEvent(r),
                     i = r.srcEvent.target;
                 for (; i && i !== s.rootElement;) {
                     if (this._emit(s, i), s.handled) return;
                     i = i.parentNode
                 }
                 this._emit(s, "root")
-            }, this.eventManager = e, this.handlers = [], this.handlersByElement = new Map, this._active = !1
+            }, this.eventManager = t, this.handlers = [], this.handlersByElement = new Map, this._active = !1
         }
         isEmpty() {
             return !this._active
         }
-        add(e, r, s, i = !1, n = !1) {
+        add(t, r, s, i = !1, n = !1) {
             let {
                 handlers: o,
                 handlersByElement: a
-            } = this, c = jh;
+            } = this, c = Xf;
             typeof s == "string" || s && s.addEventListener ? c = {
-                ...jh,
+                ...Xf,
                 srcElement: s
             } : s && (c = {
-                ...jh,
+                ...Xf,
                 ...s
             });
             let l = a.get(c.srcElement);
             l || (l = [], a.set(c.srcElement, l));
-            let h = {
-                type: e,
+            let f = {
+                type: t,
                 handler: r,
                 srcElement: c.srcElement,
                 priority: c.priority
             };
-            i && (h.once = !0), n && (h.passive = !0), o.push(h), this._active = this._active || !h.passive;
+            i && (f.once = !0), n && (f.passive = !0), o.push(f), this._active = this._active || !f.passive;
             let d = l.length - 1;
-            for (; d >= 0 && !(l[d].priority >= h.priority);) d--;
-            l.splice(d + 1, 0, h)
+            for (; d >= 0 && !(l[d].priority >= f.priority);) d--;
+            l.splice(d + 1, 0, f)
         }
-        remove(e, r) {
+        remove(t, r) {
             let {
                 handlers: s,
                 handlersByElement: i
             } = this;
             for (let n = s.length - 1; n >= 0; n--) {
                 let o = s[n];
-                if (o.type === e && o.handler === r) {
+                if (o.type === t && o.handler === r) {
                     s.splice(n, 1);
                     let a = i.get(o.srcElement);
                     a.splice(a.indexOf(o), 1), a.length === 0 && i.delete(o.srcElement)
                 }
             }
             this._active = s.some(n => !n.passive)
         }
-        _emit(e, r) {
+        _emit(t, r) {
             let s = this.handlersByElement.get(r);
             if (s) {
                 let i = !1,
                     n = () => {
-                        e.handled = !0
+                        t.handled = !0
                     },
                     o = () => {
-                        e.handled = !0, i = !0
+                        t.handled = !0, i = !0
                     },
                     a = [];
                 for (let c = 0; c < s.length; c++) {
                     let {
                         type: l,
-                        handler: h,
+                        handler: f,
                         once: d
                     } = s[c];
-                    if (h({
-                            ...e,
+                    if (f({
+                            ...t,
                             type: l,
                             stopPropagation: n,
                             stopImmediatePropagation: o
                         }), d && a.push(s[c]), i) break
                 }
                 for (let c = 0; c < a.length; c++) {
                     let {
                         type: l,
-                        handler: h
+                        handler: f
                     } = a[c];
-                    this.remove(l, h)
+                    this.remove(l, f)
                 }
             }
         }
-        _normalizeEvent(e) {
+        _normalizeEvent(t) {
             let r = this.eventManager.getElement();
             return {
-                ...e,
-                ...Wg(e),
-                ...zg(e, r),
+                ...t,
+                ...z_(t),
+                ...j_(t, r),
                 preventDefault: () => {
-                    e.srcEvent.preventDefault()
+                    t.srcEvent.preventDefault()
                 },
                 stopImmediatePropagation: null,
                 stopPropagation: null,
                 handled: !1,
                 rootElement: r
             }
         }
     };
-var a1 = {
+var l1 = {
         events: null,
         recognizers: null,
         recognizerOptions: {},
-        Manager: wg,
+        Manager: R_,
         touchAction: "none",
         tabIndex: 0
     },
     Rs = class {
-        constructor(e = null, r) {
+        constructor(t = null, r) {
             this._onBasicInput = i => {
                 let {
                     srcEvent: n
-                } = i, o = Mg[n.type];
+                } = i, o = P_[n.type];
                 o && this.manager.emit(o, i)
             }, this._onOtherEvent = i => {
                 this.manager.emit(i.type, i)
             }, this.options = {
-                ...a1,
+                ...l1,
                 ...r
-            }, this.events = new Map, this.setElement(e);
+            }, this.events = new Map, this.setElement(t);
             let {
                 events: s
             } = this.options;
             s && this.on(s)
         }
         getElement() {
             return this.element
         }
-        setElement(e) {
-            if (this.element && this.destroy(), this.element = e, !e) return;
+        setElement(t) {
+            if (this.element && this.destroy(), this.element = t, !t) return;
             let {
                 options: r
             } = this, s = r.Manager;
-            this.manager = new s(e, {
+            this.manager = new s(t, {
                 touchAction: r.touchAction,
-                recognizers: r.recognizers || Rg
-            }).on("hammer.input", this._onBasicInput), r.recognizers || Object.keys(zh).forEach(i => {
+                recognizers: r.recognizers || v_
+            }).on("hammer.input", this._onBasicInput), r.recognizers || Object.keys(jf).forEach(i => {
                 let n = this.manager.get(i);
-                n && zh[i].forEach(o => {
+                n && jf[i].forEach(o => {
                     n.recognizeWith(o)
                 })
             });
             for (let i in r.recognizerOptions) {
                 let n = this.manager.get(i);
                 if (n) {
                     let o = r.recognizerOptions[i];
                     delete o.enable, n.set(o)
                 }
             }
-            this.wheelInput = new Qi(e, this._onOtherEvent, {
+            this.wheelInput = new Qi(t, this._onOtherEvent, {
                 enable: !1
-            }), this.moveInput = new Ji(e, this._onOtherEvent, {
+            }), this.moveInput = new Ji(t, this._onOtherEvent, {
                 enable: !1
-            }), this.keyInput = new Gi(e, this._onOtherEvent, {
+            }), this.keyInput = new Gi(t, this._onOtherEvent, {
                 enable: !1,
                 tabIndex: r.tabIndex
-            }), this.contextmenuInput = new en(e, this._onOtherEvent, {
+            }), this.contextmenuInput = new tn(t, this._onOtherEvent, {
                 enable: !1
             });
             for (let [i, n] of this.events) n.isEmpty() || (this._toggleRecognizer(n.recognizerName, !0), this.manager.on(i, n.handleEvent))
         }
         destroy() {
             this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null)
         }
-        on(e, r, s) {
-            this._addEventHandler(e, r, s, !1)
+        on(t, r, s) {
+            this._addEventHandler(t, r, s, !1)
         }
-        once(e, r, s) {
-            this._addEventHandler(e, r, s, !0)
+        once(t, r, s) {
+            this._addEventHandler(t, r, s, !0)
         }
-        watch(e, r, s) {
-            this._addEventHandler(e, r, s, !1, !0)
+        watch(t, r, s) {
+            this._addEventHandler(t, r, s, !1, !0)
         }
-        off(e, r) {
-            this._removeEventHandler(e, r)
+        off(t, r) {
+            this._removeEventHandler(t, r)
         }
-        _toggleRecognizer(e, r) {
+        _toggleRecognizer(t, r) {
             let {
                 manager: s
             } = this;
             if (!s) return;
-            let i = s.get(e);
+            let i = s.get(t);
             if (i && i.options.enable !== r) {
                 i.set({
                     enable: r
                 });
-                let n = vg[e];
+                let n = M_[t];
                 n && !this.options.recognizers && n.forEach(o => {
                     let a = s.get(o);
-                    r ? (a.requireFailure(e), i.dropRequireFailure(o)) : a.dropRequireFailure(e)
+                    r ? (a.requireFailure(t), i.dropRequireFailure(o)) : a.dropRequireFailure(t)
                 })
             }
-            this.wheelInput.enableEventType(e, r), this.moveInput.enableEventType(e, r), this.keyInput.enableEventType(e, r), this.contextmenuInput.enableEventType(e, r)
+            this.wheelInput.enableEventType(t, r), this.moveInput.enableEventType(t, r), this.keyInput.enableEventType(t, r), this.contextmenuInput.enableEventType(t, r)
         }
-        _addEventHandler(e, r, s, i, n) {
-            if (typeof e != "string") {
+        _addEventHandler(t, r, s, i, n) {
+            if (typeof t != "string") {
                 s = r;
-                for (let h in e) this._addEventHandler(h, e[h], s, i, n);
+                for (let f in t) this._addEventHandler(f, t[f], s, i, n);
                 return
             }
             let {
                 manager: o,
                 events: a
-            } = this, c = Hh[e] || e, l = a.get(c);
-            l || (l = new tn(this), a.set(c, l), l.recognizerName = Pg[c] || c, o && o.on(c, l.handleEvent)), l.add(e, r, s, i, n), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0)
+            } = this, c = Hf[t] || t, l = a.get(c);
+            l || (l = new en(this), a.set(c, l), l.recognizerName = C_[c] || c, o && o.on(c, l.handleEvent)), l.add(t, r, s, i, n), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0)
         }
-        _removeEventHandler(e, r) {
-            if (typeof e != "string") {
-                for (let o in e) this._removeEventHandler(o, e[o]);
+        _removeEventHandler(t, r) {
+            if (typeof t != "string") {
+                for (let o in t) this._removeEventHandler(o, t[o]);
                 return
             }
             let {
                 events: s
-            } = this, i = Hh[e] || e, n = s.get(i);
-            if (n && (n.remove(e, r), n.isEmpty())) {
+            } = this, i = Hf[t] || t, n = s.get(i);
+            if (n && (n.remove(t, r), n.isEmpty())) {
                 let {
                     recognizerName: o
                 } = n, a = !1;
                 for (let c of s.values())
                     if (c.recognizerName === o && !c.isEmpty()) {
                         a = !0;
                         break
                     } a || this._toggleRecognizer(o, !1)
             }
         }
     };
 
 function sr() {}
-var c1 = ({
-        isDragging: t
-    }) => t ? "grabbing" : "grab",
-    Hg = {
+var f1 = ({
+        isDragging: e
+    }) => e ? "grabbing" : "grab",
+    H_ = {
         id: "",
         width: "100%",
         height: "100%",
         style: null,
         viewState: null,
         initialViewState: null,
         pickingRadius: 0,
@@ -20365,32 +20365,32 @@
         onWebGLInitialized: sr,
         onResize: sr,
         onViewStateChange: sr,
         onInteractionStateChange: sr,
         onBeforeRender: sr,
         onAfterRender: sr,
         onLoad: sr,
-        onError: t => W.error(t.message, t.cause)(),
+        onError: e => W.error(e.message, e.cause)(),
         onHover: null,
         onClick: null,
         onDragStart: null,
         onDrag: null,
         onDragEnd: null,
         _onMetrics: null,
-        getCursor: c1,
+        getCursor: f1,
         getTooltip: null,
         debug: !1,
         drawPickingColors: !1
     },
-    wa = class wa {
-        constructor(e) {
+    Sa = class Sa {
+        constructor(t) {
             this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
                 isHovering: !1,
                 isDragging: !1
-            }, this.stats = new Ne({
+            }, this.stats = new Nt({
                 id: "deck.gl"
             }), this.metrics = {
                 fps: 0,
                 setPropsTime: 0,
                 updateAttributesTime: 0,
                 framesRedrawn: 0,
                 pickTime: 0,
@@ -20423,230 +20423,230 @@
                     }
                 }
                 this.layerManager && (this.layerManager.context.mousePosition = {
                     x: i.x,
                     y: i.y
                 }), i.event = s
             }, this._onEvent = s => {
-                let i = Ti[s.type],
+                let i = bi[s.type],
                     n = s.offsetCenter;
                 if (!i || !n || !this.layerManager) return;
                 let o = this.layerManager.getLayers(),
                     a = this.deckPicker.getLastPickedObject({
                         x: n.x,
                         y: n.y,
                         layers: o,
                         viewports: this.getViewports(n)
                     }, this._lastPointerDownInfo),
                     {
                         layer: c
                     } = a,
                     l = c && (c[i.handler] || c.props[i.handler]),
-                    h = this.props[i.handler],
+                    f = this.props[i.handler],
                     d = !1;
-                l && (d = l.call(c, a, s)), d || (h?.(a, s), this.widgetManager.onEvent(a, s))
+                l && (d = l.call(c, a, s)), d || (f?.(a, s), this.widgetManager.onEvent(a, s))
             }, this._onPointerDown = s => {
                 let i = s.offsetCenter,
                     n = this._pick("pickObject", "pickObject Time", {
                         x: i.x,
                         y: i.y,
                         radius: this.props.pickingRadius
                     });
                 this._lastPointerDownInfo = n.result[0] || n.emptyInfo
             }, this.props = {
-                ...Hg,
-                ...e
-            }, e = this.props, e.viewState && e.initialViewState && W.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device ? this.device = e.device : e.gl && (e.gl instanceof WebGLRenderingContext && W.error("WebGL1 context not supported.")(), this.device = Ur.attach(e.gl));
+                ...H_,
+                ...t
+            }, t = this.props, t.viewState && t.initialViewState && W.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, t.device ? this.device = t.device : t.gl && (t.gl instanceof WebGLRenderingContext && W.error("WebGL1 context not supported.")(), this.device = Ur.attach(t.gl));
             let r = this.device;
-            r || (ke.registerDevices([Ur]), r = ke.createDevice({
-                ...e.deviceProps,
-                canvas: this._createCanvas(e)
+            r || (Dt.registerDevices([Ur]), r = Dt.createDevice({
+                ...t.deviceProps,
+                canvas: this._createCanvas(t)
             }), r.then(s => {
                 this.device = s
-            })), this.animationLoop = this._createAnimationLoop(r, e), this.setProps(e), e._typedArrayManagerProps && Mt.setOptions(e._typedArrayManagerProps), this.animationLoop.start()
+            })), this.animationLoop = this._createAnimationLoop(r, t), this.setProps(t), t._typedArrayManagerProps && Me.setOptions(t._typedArrayManagerProps), this.animationLoop.start()
         }
         finalize() {
             this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null)
         }
-        setProps(e) {
-            this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && W.removed("onLayerHover", "onHover")(), "onLayerClick" in e && W.removed("onLayerClick", "onClick")(), e.initialViewState && !ue(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
+        setProps(t) {
+            this.stats.get("setProps Time").timeStart(), "onLayerHover" in t && W.removed("onLayerHover", "onHover")(), "onLayerClick" in t && W.removed("onLayerClick", "onClick")(), t.initialViewState && !ut(this.props.initialViewState, t.initialViewState, 3) && (this.viewState = t.initialViewState), Object.assign(this.props, t), this._setCanvasSize(this.props);
             let r = Object.create(this.props);
             Object.assign(r, {
                 views: this._getViews(),
                 width: this.width,
                 height: this.height,
                 viewState: this._getViewState()
             }), this.animationLoop?.setProps(r), this.layerManager && (this.viewManager.setProps(r), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(r), this.effectManager.setProps(r), this.deckRenderer.setProps(r), this.deckPicker.setProps(r), this.widgetManager.setProps(r)), this.stats.get("setProps Time").timeEnd()
         }
-        needsRedraw(e = {
+        needsRedraw(t = {
             clearRedrawFlags: !1
         }) {
             if (!this.layerManager) return !1;
             if (this.props._animate) return "Deck._animate";
             let r = this._needsRedraw;
-            e.clearRedrawFlags && (this._needsRedraw = !1);
-            let s = this.viewManager.needsRedraw(e),
-                i = this.layerManager.needsRedraw(e),
-                n = this.effectManager.needsRedraw(e),
-                o = this.deckRenderer.needsRedraw(e);
+            t.clearRedrawFlags && (this._needsRedraw = !1);
+            let s = this.viewManager.needsRedraw(t),
+                i = this.layerManager.needsRedraw(t),
+                n = this.effectManager.needsRedraw(t),
+                o = this.deckRenderer.needsRedraw(t);
             return r = r || s || i || n || o, r
         }
-        redraw(e) {
+        redraw(t) {
             if (!this.layerManager) return;
             let r = this.needsRedraw({
                 clearRedrawFlags: !0
             });
-            r = e || r, r && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(r) : this._drawLayers(r))
+            r = t || r, r && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(r) : this._drawLayers(r))
         }
         get isInitialized() {
             return this.viewManager !== null
         }
         getViews() {
             return J(this.viewManager), this.viewManager.views
         }
-        getViewports(e) {
-            return J(this.viewManager), this.viewManager.getViewports(e)
+        getViewports(t) {
+            return J(this.viewManager), this.viewManager.getViewports(t)
         }
         getCanvas() {
             return this.canvas
         }
-        pickObject(e) {
-            let r = this._pick("pickObject", "pickObject Time", e).result;
+        pickObject(t) {
+            let r = this._pick("pickObject", "pickObject Time", t).result;
             return r.length ? r[0] : null
         }
-        pickMultipleObjects(e) {
-            return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result
+        pickMultipleObjects(t) {
+            return t.depth = t.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", t).result
         }
-        pickObjects(e) {
-            return this._pick("pickObjects", "pickObjects Time", e)
+        pickObjects(t) {
+            return this._pick("pickObjects", "pickObjects Time", t)
         }
-        _addResources(e, r = !1) {
-            for (let s in e) this.layerManager.resourceManager.add({
+        _addResources(t, r = !1) {
+            for (let s in t) this.layerManager.resourceManager.add({
                 resourceId: s,
-                data: e[s],
+                data: t[s],
                 forceUpdate: r
             })
         }
-        _removeResources(e) {
-            for (let r of e) this.layerManager.resourceManager.remove(r)
+        _removeResources(t) {
+            for (let r of t) this.layerManager.resourceManager.remove(r)
         }
-        _addDefaultEffect(e) {
-            this.effectManager.addDefaultEffect(e)
+        _addDefaultEffect(t) {
+            this.effectManager.addDefaultEffect(t)
         }
-        _addDefaultShaderModule(e) {
-            this.layerManager.addDefaultShaderModule(e)
+        _addDefaultShaderModule(t) {
+            this.layerManager.addDefaultShaderModule(t)
         }
-        _removeDefaultShaderModule(e) {
-            this.layerManager?.removeDefaultShaderModule(e)
+        _removeDefaultShaderModule(t) {
+            this.layerManager?.removeDefaultShaderModule(t)
         }
-        _pick(e, r, s) {
+        _pick(t, r, s) {
             J(this.deckPicker);
             let {
                 stats: i
             } = this;
             i.get("Pick Count").incrementCount(), i.get(r).timeStart();
-            let n = this.deckPicker[e]({
+            let n = this.deckPicker[t]({
                 layers: this.layerManager.getLayers(s),
                 views: this.viewManager.getViews(),
                 viewports: this.getViewports(s),
                 onViewportActive: this.layerManager.activateViewport,
                 effects: this.effectManager.getEffects(),
                 ...s
             });
             return i.get(r).timeEnd(), n
         }
-        _createCanvas(e) {
-            let r = e.canvas;
-            return typeof r == "string" && (r = document.getElementById(r), J(r)), r || (r = document.createElement("canvas"), r.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(r)), Object.assign(r.style, e.style), r
+        _createCanvas(t) {
+            let r = t.canvas;
+            return typeof r == "string" && (r = document.getElementById(r), J(r)), r || (r = document.createElement("canvas"), r.id = t.id || "deckgl-overlay", (t.parent || document.body).appendChild(r)), Object.assign(r.style, t.style), r
         }
-        _setCanvasSize(e) {
+        _setCanvasSize(t) {
             if (!this.canvas) return;
             let {
                 width: r,
                 height: s
-            } = e;
+            } = t;
             if (r || r === 0) {
                 let i = Number.isFinite(r) ? `${r}px` : r;
                 this.canvas.style.width = i
             }
             if (s || s === 0) {
                 let i = Number.isFinite(s) ? `${s}px` : s;
-                this.canvas.style.position = e.style?.position || "absolute", this.canvas.style.height = i
+                this.canvas.style.position = t.style?.position || "absolute", this.canvas.style.height = i
             }
         }
         _updateCanvasSize() {
             let {
-                canvas: e
+                canvas: t
             } = this;
-            if (!e) return;
-            let r = e.clientWidth ?? e.width,
-                s = e.clientHeight ?? e.height;
+            if (!t) return;
+            let r = t.clientWidth ?? t.width,
+                s = t.clientHeight ?? t.height;
             (r !== this.width || s !== this.height) && (this.width = r, this.height = s, this.viewManager?.setProps({
                 width: r,
                 height: s
             }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({
                 width: r,
                 height: s
             }))
         }
-        _createAnimationLoop(e, r) {
+        _createAnimationLoop(t, r) {
             let {
                 gl: s,
                 onError: i,
                 useDevicePixels: n
             } = r;
             return new Ii({
-                device: e,
+                device: t,
                 useDevicePixels: n,
                 autoResizeDrawingBuffer: !s,
                 autoResizeViewport: !1,
                 onInitialize: o => this._setDevice(o.device),
                 onRender: this._onRenderFrame.bind(this),
                 onError: i
             })
         }
         _getViewState() {
             return this.props.viewState || this.viewState || {}
         }
         _getViews() {
             let {
-                views: e
-            } = this.props, r = Array.isArray(e) ? e : e ? [e] : [new bs({
+                views: t
+            } = this.props, r = Array.isArray(t) ? t : t ? [t] : [new Ts({
                 id: "default-view"
             })];
             return r.length && this.props.controller && (r[0].props.controller = this.props.controller), r
         }
         _onContextLost() {
             let {
-                onError: e
+                onError: t
             } = this.props;
-            this.animationLoop && e && e(new Error("WebGL context is lost"))
+            this.animationLoop && t && t(new Error("WebGL context is lost"))
         }
         _pickAndCallback() {
             let {
-                _pickRequest: e
+                _pickRequest: t
             } = this;
-            if (e.event) {
+            if (t.event) {
                 let {
                     result: r,
                     emptyInfo: s
-                } = this._pick("pickObject", "pickObject Time", e);
+                } = this._pick("pickObject", "pickObject Time", t);
                 this.cursorState.isHovering = r.length > 0;
                 let i = s,
                     n = !1;
-                for (let o of r) i = o, n = o.layer?.onHover(o, e.event) || n;
-                n || (this.props.onHover?.(i, e.event), this.widgetManager.onHover(i, e.event)), e.event = null
+                for (let o of r) i = o, n = o.layer?.onHover(o, t.event) || n;
+                n || (this.props.onHover?.(i, t.event), this.widgetManager.onHover(i, t.event)), t.event = null
             }
         }
         _updateCursor() {
-            let e = this.props.parent || this.canvas;
-            e && (e.style.cursor = this.props.getCursor(this.cursorState))
+            let t = this.props.parent || this.canvas;
+            t && (t.style.cursor = this.props.getCursor(this.cursorState))
         }
-        _setDevice(e) {
-            if (this.device = e, !this.animationLoop) return;
+        _setDevice(t) {
+            if (this.device = t, !this.animationLoop) return;
             this.canvas || (this.canvas = this.device.canvasContext?.canvas), this.device.setParametersWebGL({
                 blend: !0,
                 blendFunc: [770, 771, 1, 771],
                 polygonOffsetFill: !0,
                 depthTest: !0,
                 depthFunc: 515
             }), this.props.onDeviceInitialized(this.device), this.device instanceof Ur && this.props.onWebGLInitialized(this.device.gl);
@@ -20656,16 +20656,16 @@
                 recognizerOptions: this.props.eventRecognizerOptions,
                 events: {
                     pointerdown: this._onPointerDown,
                     pointermove: this._onPointerMove,
                     pointerleave: this._onPointerMove
                 }
             });
-            for (let i in Ti) this.eventManager.on(i, this._onEvent);
-            this.viewManager = new Di({
+            for (let i in bi) this.eventManager.on(i, this._onEvent);
+            this.viewManager = new ki({
                 timeline: r,
                 eventManager: this.eventManager,
                 onViewStateChange: this._onViewStateChange.bind(this),
                 onInteractionStateChange: this._onInteractionStateChange.bind(this),
                 views: this._getViews(),
                 viewState: this._getViewState(),
                 width: this.width,
@@ -20676,20 +20676,20 @@
                 deck: this,
                 stats: this.stats,
                 viewport: s,
                 timeline: r
             }), this.effectManager = new Ui({
                 deck: this,
                 device: this.device
-            }), this.deckRenderer = new Es(this.device), this.deckPicker = new Vi(this.device), this.widgetManager = new ea({
+            }), this.deckRenderer = new ws(this.device), this.deckPicker = new Vi(this.device), this.widgetManager = new ta({
                 deck: this,
                 parentElement: this.canvas?.parentElement
             }), this.widgetManager.addDefault(new Wi), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad()
         }
-        _drawLayers(e, r) {
+        _drawLayers(t, r) {
             let {
                 device: s,
                 gl: i
             } = this.layerManager.context;
             this.props.onBeforeRender({
                 device: s,
                 gl: i
@@ -20711,111 +20711,111 @@
                 device: s,
                 gl: i
             })
         }
         _onRenderFrame() {
             this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), W.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates()
         }
-        _onViewStateChange(e) {
-            let r = this.props.onViewStateChange(e) || e.viewState;
+        _onViewStateChange(t) {
+            let r = this.props.onViewStateChange(t) || t.viewState;
             this.viewState && (this.viewState = {
                 ...this.viewState,
-                [e.viewId]: r
+                [t.viewId]: r
             }, this.props.viewState || this.viewManager && this.viewManager.setProps({
                 viewState: this.viewState
             }))
         }
-        _onInteractionStateChange(e) {
-            this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e)
+        _onInteractionStateChange(t) {
+            this.cursorState.isDragging = t.isDragging || !1, this.props.onInteractionStateChange(t)
         }
         _getFrameStats() {
             let {
-                stats: e
+                stats: t
             } = this;
-            e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
+            t.get("frameRate").timeEnd(), t.get("frameRate").timeStart();
             let r = this.animationLoop.stats;
-            e.get("GPU Time").addTime(r.get("GPU Time").lastTiming), e.get("CPU Time").addTime(r.get("CPU Time").lastTiming)
+            t.get("GPU Time").addTime(r.get("GPU Time").lastTiming), t.get("CPU Time").addTime(r.get("CPU Time").lastTiming)
         }
         _getMetrics() {
             let {
-                metrics: e,
+                metrics: t,
                 stats: r
             } = this;
-            e.fps = r.get("frameRate").getHz(), e.setPropsTime = r.get("setProps Time").time, e.updateAttributesTime = r.get("Update Attributes").time, e.framesRedrawn = r.get("Redraw Count").count, e.pickTime = r.get("pickObject Time").time + r.get("pickMultipleObjects Time").time + r.get("pickObjects Time").time, e.pickCount = r.get("Pick Count").count, e.gpuTime = r.get("GPU Time").time, e.cpuTime = r.get("CPU Time").time, e.gpuTimePerFrame = r.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = r.get("CPU Time").getAverageTime();
-            let s = ke.stats.get("Memory Usage");
-            e.bufferMemory = s.get("Buffer Memory").count, e.textureMemory = s.get("Texture Memory").count, e.renderbufferMemory = s.get("Renderbuffer Memory").count, e.gpuMemory = s.get("GPU Memory").count
+            t.fps = r.get("frameRate").getHz(), t.setPropsTime = r.get("setProps Time").time, t.updateAttributesTime = r.get("Update Attributes").time, t.framesRedrawn = r.get("Redraw Count").count, t.pickTime = r.get("pickObject Time").time + r.get("pickMultipleObjects Time").time + r.get("pickObjects Time").time, t.pickCount = r.get("Pick Count").count, t.gpuTime = r.get("GPU Time").time, t.cpuTime = r.get("CPU Time").time, t.gpuTimePerFrame = r.get("GPU Time").getAverageTime(), t.cpuTimePerFrame = r.get("CPU Time").getAverageTime();
+            let s = Dt.stats.get("Memory Usage");
+            t.bufferMemory = s.get("Buffer Memory").count, t.textureMemory = s.get("Texture Memory").count, t.renderbufferMemory = s.get("Renderbuffer Memory").count, t.gpuMemory = s.get("GPU Memory").count
         }
     };
-wa.defaultProps = Hg, wa.VERSION = Mc;
-var ir = wa;
+Sa.defaultProps = H_, Sa.VERSION = Mc;
+var ir = Sa;
 
-function jg(t) {
-    switch (t) {
+function X_(e) {
+    switch (e) {
         case "float64":
             return Float64Array;
         case "uint8":
         case "unorm8":
             return Uint8ClampedArray;
         default:
-            return hi(t)
+            return fi(e)
     }
 }
-var Xg = co;
+var $_ = co;
 
-function rn(t, e) {
+function rn(e, t) {
     return {
-        attribute: t,
-        format: e.size > 1 ? `${e.type}x${e.size}` : e.type,
-        byteOffset: e.offset || 0
+        attribute: e,
+        format: t.size > 1 ? `${t.type}x${t.size}` : t.type,
+        byteOffset: t.offset || 0
     }
 }
 
-function nr(t) {
-    return t.stride || t.size * t.bytesPerElement
+function nr(e) {
+    return e.stride || e.size * e.bytesPerElement
 }
 
-function $g(t, e) {
-    return t.type === e.type && t.size === e.size && nr(t) === nr(e) && (t.offset || 0) === (e.offset || 0)
+function Y_(e, t) {
+    return e.type === t.type && e.size === t.size && nr(e) === nr(t) && (e.offset || 0) === (t.offset || 0)
 }
 
-function Xh(t, e) {
-    e.offset && W.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
-    let r = nr(t),
-        s = e.vertexOffset !== void 0 ? e.vertexOffset : t.vertexOffset || 0,
-        i = e.elementOffset || 0,
-        n = s * r + i * t.bytesPerElement + (t.offset || 0);
+function $f(e, t) {
+    t.offset && W.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
+    let r = nr(e),
+        s = t.vertexOffset !== void 0 ? t.vertexOffset : e.vertexOffset || 0,
+        i = t.elementOffset || 0,
+        n = s * r + i * e.bytesPerElement + (e.offset || 0);
     return {
-        ...e,
+        ...t,
         offset: n,
         stride: r
     }
 }
 
-function l1(t, e) {
-    let r = Xh(t, e);
+function h1(e, t) {
+    let r = $f(e, t);
     return {
         high: r,
         low: {
             ...r,
-            offset: r.offset + t.size * 4
+            offset: r.offset + e.size * 4
         }
     }
 }
 var sn = class {
-    constructor(e, r, s) {
-        this._buffer = null, this.device = e, this.id = r.id || "", this.size = r.size || 1;
+    constructor(t, r, s) {
+        this._buffer = null, this.device = t, this.id = r.id || "", this.size = r.size || 1;
         let i = r.logicalType || r.type,
             n = i === "float64",
             {
                 defaultValue: o
             } = r;
         o = Number.isFinite(o) ? [o] : o || new Array(this.size).fill(0);
         let a;
         n ? a = "float32" : !i && r.isIndexed ? a = "uint32" : a = i || "float32";
-        let c = jg(i || a);
+        let c = X_(i || a);
         this.doublePrecision = n, n && r.fp64 === !1 && (c = Float32Array), this.value = null, this.settings = {
             ...r,
             defaultType: c,
             defaultValue: o,
             logicalType: i,
             type: a,
             normalized: a.includes("norm"),
@@ -20834,117 +20834,117 @@
     get isConstant() {
         return this.state.constant
     }
     get buffer() {
         return this._buffer
     }
     get byteOffset() {
-        let e = this.getAccessor();
-        return e.vertexOffset ? e.vertexOffset * nr(e) : 0
+        let t = this.getAccessor();
+        return t.vertexOffset ? t.vertexOffset * nr(t) : 0
     }
     get numInstances() {
         return this.state.numInstances
     }
-    set numInstances(e) {
-        this.state.numInstances = e
+    set numInstances(t) {
+        this.state.numInstances = t
     }
     delete() {
-        this._buffer && (this._buffer.delete(), this._buffer = null), Mt.release(this.state.allocatedValue)
+        this._buffer && (this._buffer.delete(), this._buffer = null), Me.release(this.state.allocatedValue)
     }
     getBuffer() {
         return this.state.constant ? null : this.state.externalBuffer || this._buffer
     }
-    getValue(e = this.id, r = null) {
+    getValue(t = this.id, r = null) {
         let s = {};
         if (this.state.constant) {
             let i = this.value;
             if (r) {
-                let n = Xh(this.getAccessor(), r),
+                let n = $f(this.getAccessor(), r),
                     o = n.offset / i.BYTES_PER_ELEMENT,
                     a = n.size || this.size;
-                s[e] = i.subarray(o, o + a)
-            } else s[e] = i
-        } else s[e] = this.getBuffer();
-        return this.doublePrecision && (this.value instanceof Float64Array ? s[`${e}64Low`] = s[e] : s[`${e}64Low`] = new Float32Array(this.size)), s
+                s[t] = i.subarray(o, o + a)
+            } else s[t] = i
+        } else s[t] = this.getBuffer();
+        return this.doublePrecision && (this.value instanceof Float64Array ? s[`${t}64Low`] = s[t] : s[`${t}64Low`] = new Float32Array(this.size)), s
     }
-    getBufferLayout(e = this.id, r = null) {
+    getBufferLayout(t = this.id, r = null) {
         let s = this.getAccessor(),
             i = [],
             n = {
                 name: this.id,
                 byteStride: nr(s),
                 attributes: i
             };
         if (this.doublePrecision) {
-            let o = l1(s, r || {});
-            i.push(rn(e, {
+            let o = h1(s, r || {});
+            i.push(rn(t, {
                 ...s,
                 ...o.high
-            }), rn(`${e}64Low`, {
+            }), rn(`${t}64Low`, {
                 ...s,
                 ...o.low
             }))
         } else if (r) {
-            let o = Xh(s, r);
-            i.push(rn(e, {
+            let o = $f(s, r);
+            i.push(rn(t, {
                 ...s,
                 ...o
             }))
-        } else i.push(rn(e, s));
+        } else i.push(rn(t, s));
         return n
     }
-    setAccessor(e) {
-        this.state.bufferAccessor = e
+    setAccessor(t) {
+        this.state.bufferAccessor = t
     }
     getAccessor() {
         return this.state.bufferAccessor
     }
     getBounds() {
         if (this.state.bounds) return this.state.bounds;
-        let e = null;
+        let t = null;
         if (this.state.constant && this.value) {
             let r = Array.from(this.value);
-            e = [r, r]
+            t = [r, r]
         } else {
             let {
                 value: r,
                 numInstances: s,
                 size: i
             } = this, n = s * i;
             if (r && n && r.length >= n) {
                 let o = new Array(i).fill(1 / 0),
                     a = new Array(i).fill(-1 / 0);
                 for (let c = 0; c < n;)
                     for (let l = 0; l < i; l++) {
-                        let h = r[c++];
-                        h < o[l] && (o[l] = h), h > a[l] && (a[l] = h)
+                        let f = r[c++];
+                        f < o[l] && (o[l] = f), f > a[l] && (a[l] = f)
                     }
-                e = [o, a]
+                t = [o, a]
             }
         }
-        return this.state.bounds = e, e
+        return this.state.bounds = t, t
     }
-    setData(e) {
+    setData(t) {
         let {
             state: r
         } = this, s;
-        ArrayBuffer.isView(e) ? s = {
-            value: e
-        } : e instanceof K ? s = {
-            buffer: e
-        } : s = e;
+        ArrayBuffer.isView(t) ? s = {
+            value: t
+        } : t instanceof K ? s = {
+            buffer: t
+        } : s = t;
         let i = {
             ...this.settings,
             ...s
         };
         if (ArrayBuffer.isView(s.value)) {
             if (!s.type)
                 if (this.doublePrecision && s.value instanceof Float64Array) i.type = "float32";
                 else {
-                    let o = Xg(s.value);
+                    let o = $_(s.value);
                     i.type = i.normalized ? o.replace("int", "norm") : o
                 } i.bytesPerElement = s.value.BYTES_PER_ELEMENT, i.stride = nr(i)
         }
         if (r.bounds = null, s.constant) {
             let n = s.value;
             if (n = this._normalizeValue(n, [], 0), this.settings.normalized && (n = this.normalizeConstant(n)), !(!r.constant || !this._areValuesEqual(n, this.value))) return !1;
             r.externalBuffer = null, r.constant = !0, this.value = ArrayBuffer.isView(n) ? n : new Float32Array(n)
@@ -20955,302 +20955,302 @@
             this._checkExternalBuffer(s);
             let n = s.value;
             r.externalBuffer = null, r.constant = !1, this.value = n;
             let {
                 buffer: o
             } = this, a = nr(i), c = (i.vertexOffset || 0) * a;
             if (this.doublePrecision && n instanceof Float64Array && (n = Wo(n, i)), this.settings.isIndexed) {
-                let h = this.settings.defaultType;
-                n.constructor !== h && (n = new h(n))
+                let f = this.settings.defaultType;
+                n.constructor !== f && (n = new f(n))
             }
             let l = n.byteLength + c + a * 2;
             (!o || o.byteLength < l) && (o = this._createBuffer(l)), o.write(n, c)
         }
         return this.setAccessor(i), !0
     }
-    updateSubBuffer(e = {}) {
+    updateSubBuffer(t = {}) {
         this.state.bounds = null;
         let r = this.value,
             {
                 startOffset: s = 0,
                 endOffset: i
-            } = e;
+            } = t;
         this.buffer.write(this.doublePrecision && r instanceof Float64Array ? Wo(r, {
             size: this.size,
             startIndex: s,
             endIndex: i
         }) : r.subarray(s, i), s * r.BYTES_PER_ELEMENT + this.byteOffset)
     }
-    allocate(e, r = !1) {
+    allocate(t, r = !1) {
         let {
             state: s
-        } = this, i = s.allocatedValue, n = Mt.allocate(i, e + 1, {
+        } = this, i = s.allocatedValue, n = Me.allocate(i, t + 1, {
             size: this.size,
             type: this.settings.defaultType,
             copy: r
         });
         this.value = n;
         let {
             byteOffset: o
         } = this, {
             buffer: a
         } = this;
         return (!a || a.byteLength < n.byteLength + o) && (a = this._createBuffer(n.byteLength + o), r && i && a.write(i instanceof Float64Array ? Wo(i, this) : i, o)), s.allocatedValue = n, s.constant = !1, s.externalBuffer = null, this.setAccessor(this.settings), !0
     }
-    _checkExternalBuffer(e) {
+    _checkExternalBuffer(t) {
         let {
             value: r
-        } = e;
+        } = t;
         if (!ArrayBuffer.isView(r)) throw new Error(`Attribute ${this.id} value is not TypedArray`);
         let s = this.settings.defaultType,
             i = !1;
         if (this.doublePrecision && (i = r.BYTES_PER_ELEMENT < 4), i) throw new Error(`Attribute ${this.id} does not support ${r.constructor.name}`);
-        !(r instanceof s) && this.settings.normalized && !("normalized" in e) && W.warn(`Attribute ${this.id} is normalized`)()
+        !(r instanceof s) && this.settings.normalized && !("normalized" in t) && W.warn(`Attribute ${this.id} is normalized`)()
     }
-    normalizeConstant(e) {
+    normalizeConstant(t) {
         switch (this.settings.type) {
             case "snorm8":
-                return new Float32Array(e).map(r => (r + 128) / 255 * 2 - 1);
+                return new Float32Array(t).map(r => (r + 128) / 255 * 2 - 1);
             case "snorm16":
-                return new Float32Array(e).map(r => (r + 32768) / 65535 * 2 - 1);
+                return new Float32Array(t).map(r => (r + 32768) / 65535 * 2 - 1);
             case "unorm8":
-                return new Float32Array(e).map(r => r / 255);
+                return new Float32Array(t).map(r => r / 255);
             case "unorm16":
-                return new Float32Array(e).map(r => r / 65535);
+                return new Float32Array(t).map(r => r / 65535);
             default:
-                return e
+                return t
         }
     }
-    _normalizeValue(e, r, s) {
+    _normalizeValue(t, r, s) {
         let {
             defaultValue: i,
             size: n
         } = this.settings;
-        if (Number.isFinite(e)) return r[s] = e, r;
-        if (!e) {
+        if (Number.isFinite(t)) return r[s] = t, r;
+        if (!t) {
             let o = n;
             for (; --o >= 0;) r[s + o] = i[o];
             return r
         }
         switch (n) {
             case 4:
-                r[s + 3] = Number.isFinite(e[3]) ? e[3] : i[3];
+                r[s + 3] = Number.isFinite(t[3]) ? t[3] : i[3];
             case 3:
-                r[s + 2] = Number.isFinite(e[2]) ? e[2] : i[2];
+                r[s + 2] = Number.isFinite(t[2]) ? t[2] : i[2];
             case 2:
-                r[s + 1] = Number.isFinite(e[1]) ? e[1] : i[1];
+                r[s + 1] = Number.isFinite(t[1]) ? t[1] : i[1];
             case 1:
-                r[s + 0] = Number.isFinite(e[0]) ? e[0] : i[0];
+                r[s + 0] = Number.isFinite(t[0]) ? t[0] : i[0];
                 break;
             default:
                 let o = n;
-                for (; --o >= 0;) r[s + o] = Number.isFinite(e[o]) ? e[o] : i[o]
+                for (; --o >= 0;) r[s + o] = Number.isFinite(t[o]) ? t[o] : i[o]
         }
         return r
     }
-    _areValuesEqual(e, r) {
-        if (!e || !r) return !1;
+    _areValuesEqual(t, r) {
+        if (!t || !r) return !1;
         let {
             size: s
         } = this;
         for (let i = 0; i < s; i++)
-            if (e[i] !== r[i]) return !1;
+            if (t[i] !== r[i]) return !1;
         return !0
     }
-    _createBuffer(e) {
+    _createBuffer(t) {
         this._buffer && this._buffer.destroy();
         let {
             isIndexed: r,
             type: s
         } = this.settings;
         return this._buffer = this.device.createBuffer({
             ...this._buffer?.props,
             id: this.id,
             usage: r ? K.INDEX : K.VERTEX,
             indexType: r ? s : void 0,
-            byteLength: e
+            byteLength: t
         }), this._buffer
     }
 };
-var Yg = [],
-    qg = [];
+var q_ = [],
+    K_ = [];
 
-function $h(t, e = 0, r = 1 / 0) {
-    let s = Yg,
+function Yf(e, t = 0, r = 1 / 0) {
+    let s = q_,
         i = {
             index: -1,
-            data: t,
+            data: e,
             target: []
         };
-    return t ? typeof t[Symbol.iterator] == "function" ? s = t : t.length > 0 && (qg.length = t.length, s = qg) : s = Yg, (e > 0 || Number.isFinite(r)) && (s = (Array.isArray(s) ? s : Array.from(s)).slice(e, r), i.index = e - 1), {
+    return e ? typeof e[Symbol.iterator] == "function" ? s = e : e.length > 0 && (K_.length = e.length, s = K_) : s = q_, (t > 0 || Number.isFinite(r)) && (s = (Array.isArray(s) ? s : Array.from(s)).slice(t, r), i.index = t - 1), {
         iterable: s,
         objectInfo: i
     }
 }
 
-function Ra(t) {
-    return t && t[Symbol.asyncIterator]
+function Ra(e) {
+    return e && e[Symbol.asyncIterator]
 }
 
-function Kg(t, e) {
+function Z_(e, t) {
     let {
         size: r,
         stride: s,
         offset: i,
         startIndices: n,
         nested: o
-    } = e, a = t.BYTES_PER_ELEMENT, c = s ? s / a : r, l = i ? i / a : 0, h = Math.floor((t.length - l) / c);
+    } = t, a = e.BYTES_PER_ELEMENT, c = s ? s / a : r, l = i ? i / a : 0, f = Math.floor((e.length - l) / c);
     return (d, {
         index: p,
         target: m
     }) => {
         if (!n) {
-            let w = p * c + l;
-            for (let R = 0; R < r; R++) m[R] = t[w + R];
+            let S = p * c + l;
+            for (let R = 0; R < r; R++) m[R] = e[S + R];
             return m
         }
         let y = n[p],
-            x = n[p + 1] || h,
-            b;
+            E = n[p + 1] || f,
+            T;
         if (o) {
-            b = new Array(x - y);
-            for (let w = y; w < x; w++) {
-                let R = w * c + l;
+            T = new Array(E - y);
+            for (let S = y; S < E; S++) {
+                let R = S * c + l;
                 m = new Array(r);
-                for (let v = 0; v < r; v++) m[v] = t[R + v];
-                b[w - y] = m
+                for (let v = 0; v < r; v++) m[v] = e[R + v];
+                T[S - y] = m
             }
-        } else if (c === r) b = t.subarray(y * r + l, x * r + l);
+        } else if (c === r) T = e.subarray(y * r + l, E * r + l);
         else {
-            b = new t.constructor((x - y) * r);
-            let w = 0;
-            for (let R = y; R < x; R++) {
+            T = new e.constructor((E - y) * r);
+            let S = 0;
+            for (let R = y; R < E; R++) {
                 let v = R * c + l;
-                for (let C = 0; C < r; C++) b[w++] = t[v + C]
+                for (let C = 0; C < r; C++) T[S++] = e[v + C]
             }
         }
-        return b
+        return T
     }
 }
-var Zg = [],
+var Q_ = [],
     nn = [
         [0, 1 / 0]
     ];
 
-function Qg(t, e) {
-    if (t === nn || (e[0] < 0 && (e[0] = 0), e[0] >= e[1])) return t;
+function J_(e, t) {
+    if (e === nn || (t[0] < 0 && (t[0] = 0), t[0] >= t[1])) return e;
     let r = [],
-        s = t.length,
+        s = e.length,
         i = 0;
     for (let n = 0; n < s; n++) {
-        let o = t[n];
-        o[1] < e[0] ? (r.push(o), i = n + 1) : o[0] > e[1] ? r.push(o) : e = [Math.min(o[0], e[0]), Math.max(o[1], e[1])]
+        let o = e[n];
+        o[1] < t[0] ? (r.push(o), i = n + 1) : o[0] > t[1] ? r.push(o) : t = [Math.min(o[0], t[0]), Math.max(o[1], t[1])]
     }
-    return r.splice(i, 0, e), r
+    return r.splice(i, 0, t), r
 }
-var f1 = {
+var d1 = {
     interpolation: {
         duration: 0,
-        easing: t => t
+        easing: e => e
     },
     spring: {
         stiffness: .05,
         damping: .5
     }
 };
 
-function va(t, e) {
-    if (!t) return null;
-    Number.isFinite(t) && (t = {
+function va(e, t) {
+    if (!e) return null;
+    Number.isFinite(e) && (e = {
         type: "interpolation",
-        duration: t
+        duration: e
     });
-    let r = t.type || "interpolation";
+    let r = e.type || "interpolation";
     return {
-        ...f1[r],
-        ...e,
+        ...d1[r],
         ...t,
+        ...e,
         type: r
     }
 }
 var or = class extends sn {
-    constructor(e, r) {
-        super(e, r, {
+    constructor(t, r) {
+        super(t, r, {
             startIndices: null,
             lastExternalBuffer: null,
             binaryValue: null,
             binaryAccessor: null,
             needsUpdate: !0,
             needsRedraw: !1,
             layoutChanged: !1,
             updateRanges: nn
         }), this.constant = !1, this.settings.update = r.update || (r.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters()
     }
     get startIndices() {
         return this.state.startIndices
     }
-    set startIndices(e) {
-        this.state.startIndices = e
+    set startIndices(t) {
+        this.state.startIndices = t
     }
     needsUpdate() {
         return this.state.needsUpdate
     }
     needsRedraw({
-        clearChangedFlags: e = !1
+        clearChangedFlags: t = !1
     } = {}) {
         let r = this.state.needsRedraw;
-        return this.state.needsRedraw = r && !e, r
+        return this.state.needsRedraw = r && !t, r
     }
     layoutChanged() {
         return this.state.layoutChanged
     }
-    setAccessor(e) {
+    setAccessor(t) {
         var r;
-        (r = this.state).layoutChanged || (r.layoutChanged = !$g(e, this.getAccessor())), super.setAccessor(e)
+        (r = this.state).layoutChanged || (r.layoutChanged = !Y_(t, this.getAccessor())), super.setAccessor(t)
     }
     getUpdateTriggers() {
         let {
-            accessor: e
+            accessor: t
         } = this.settings;
-        return [this.id].concat(typeof e != "function" && e || [])
+        return [this.id].concat(typeof t != "function" && t || [])
     }
     supportsTransition() {
         return !!this.settings.transition
     }
-    getTransitionSetting(e) {
-        if (!e || !this.supportsTransition()) return null;
+    getTransitionSetting(t) {
+        if (!t || !this.supportsTransition()) return null;
         let {
             accessor: r
-        } = this.settings, s = this.settings.transition, i = Array.isArray(r) ? e[r.find(n => e[n])] : e[r];
+        } = this.settings, s = this.settings.transition, i = Array.isArray(r) ? t[r.find(n => t[n])] : t[r];
         return va(i, s)
     }
-    setNeedsUpdate(e = this.id, r) {
-        if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), r) {
+    setNeedsUpdate(t = this.id, r) {
+        if (this.state.needsUpdate = this.state.needsUpdate || t, this.setNeedsRedraw(t), r) {
             let {
                 startRow: s = 0,
                 endRow: i = 1 / 0
             } = r;
-            this.state.updateRanges = Qg(this.state.updateRanges, [s, i])
+            this.state.updateRanges = J_(this.state.updateRanges, [s, i])
         } else this.state.updateRanges = nn
     }
     clearNeedsUpdate() {
-        this.state.needsUpdate = !1, this.state.updateRanges = Zg
+        this.state.needsUpdate = !1, this.state.updateRanges = Q_
     }
-    setNeedsRedraw(e = this.id) {
-        this.state.needsRedraw = this.state.needsRedraw || e
+    setNeedsRedraw(t = this.id) {
+        this.state.needsRedraw = this.state.needsRedraw || t
     }
-    allocate(e) {
+    allocate(t) {
         let {
             state: r,
             settings: s
         } = this;
-        return s.noAlloc ? !1 : s.update ? (super.allocate(e, r.updateRanges !== nn), !0) : !1
+        return s.noAlloc ? !1 : s.update ? (super.allocate(t, r.updateRanges !== nn), !0) : !1
     }
     updateBuffer({
-        numInstances: e,
+        numInstances: t,
         data: r,
         props: s,
         context: i
     }) {
         if (!this.needsUpdate()) return !1;
         let {
             state: {
@@ -21258,408 +21258,408 @@
             },
             settings: {
                 update: o,
                 noAlloc: a
             }
         } = this, c = !0;
         if (o) {
-            for (let [l, h] of n) o.call(i, this, {
+            for (let [l, f] of n) o.call(i, this, {
                 data: r,
                 startRow: l,
-                endRow: h,
+                endRow: f,
                 props: s,
-                numInstances: e
+                numInstances: t
             });
             if (this.value)
                 if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) this.setData({
                     value: this.value,
                     constant: this.constant
                 }), this.constant = !1;
                 else
-                    for (let [l, h] of n) {
+                    for (let [l, f] of n) {
                         let d = Number.isFinite(l) ? this.getVertexOffset(l) : 0,
-                            p = Number.isFinite(h) ? this.getVertexOffset(h) : a || !Number.isFinite(e) ? this.value.length : e * this.size;
+                            p = Number.isFinite(f) ? this.getVertexOffset(f) : a || !Number.isFinite(t) ? this.value.length : t * this.size;
                         super.updateSubBuffer({
                             startOffset: d,
                             endOffset: p
                         })
                     }
             this._checkAttributeArray()
         } else c = !1;
         return this.clearNeedsUpdate(), this.setNeedsRedraw(), c
     }
-    setConstantValue(e) {
-        return e === void 0 || typeof e == "function" ? !1 : (this.setData({
+    setConstantValue(t) {
+        return t === void 0 || typeof t == "function" ? !1 : (this.setData({
             constant: !0,
-            value: e
+            value: t
         }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0)
     }
-    setExternalBuffer(e) {
+    setExternalBuffer(t) {
         let {
             state: r
         } = this;
-        return e ? (this.clearNeedsUpdate(), r.lastExternalBuffer === e || (r.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (r.lastExternalBuffer = null, !1)
+        return t ? (this.clearNeedsUpdate(), r.lastExternalBuffer === t || (r.lastExternalBuffer = t, this.setNeedsRedraw(), this.setData(t)), !0) : (r.lastExternalBuffer = null, !1)
     }
-    setBinaryValue(e, r = null) {
+    setBinaryValue(t, r = null) {
         let {
             state: s,
             settings: i
         } = this;
-        if (!e) return s.binaryValue = null, s.binaryAccessor = null, !1;
+        if (!t) return s.binaryValue = null, s.binaryAccessor = null, !1;
         if (i.noAlloc) return !1;
-        if (s.binaryValue === e) return this.clearNeedsUpdate(), !0;
-        if (s.binaryValue = e, this.setNeedsRedraw(), i.transform || r !== this.startIndices) {
-            ArrayBuffer.isView(e) && (e = {
-                value: e
+        if (s.binaryValue === t) return this.clearNeedsUpdate(), !0;
+        if (s.binaryValue = t, this.setNeedsRedraw(), i.transform || r !== this.startIndices) {
+            ArrayBuffer.isView(t) && (t = {
+                value: t
             });
-            let o = e;
+            let o = t;
             J(ArrayBuffer.isView(o.value), `invalid ${i.accessor}`);
             let a = !!o.size && o.size !== this.size;
-            return s.binaryAccessor = Kg(o.value, {
+            return s.binaryAccessor = Z_(o.value, {
                 size: o.size || this.size,
                 stride: o.stride,
                 offset: o.offset,
                 startIndices: r,
                 nested: a
             }), !1
         }
-        return this.clearNeedsUpdate(), this.setData(e), !0
+        return this.clearNeedsUpdate(), this.setData(t), !0
     }
-    getVertexOffset(e) {
+    getVertexOffset(t) {
         let {
             startIndices: r
         } = this;
-        return (r ? e < r.length ? r[e] : this.numInstances : e) * this.size
+        return (r ? t < r.length ? r[t] : this.numInstances : t) * this.size
     }
     getValue() {
-        let e = this.settings.shaderAttributes,
+        let t = this.settings.shaderAttributes,
             r = super.getValue();
-        if (!e) return r;
-        for (let s in e) Object.assign(r, super.getValue(s, e[s]));
+        if (!t) return r;
+        for (let s in t) Object.assign(r, super.getValue(s, t[s]));
         return r
     }
     getBufferLayout() {
         this.state.layoutChanged = !1;
-        let e = this.settings.shaderAttributes,
+        let t = this.settings.shaderAttributes,
             r = super.getBufferLayout();
-        if (!e) return r;
-        for (let s in e) {
-            let i = super.getBufferLayout(s, e[s]);
+        if (!t) return r;
+        for (let s in t) {
+            let i = super.getBufferLayout(s, t[s]);
             r.attributes.push(...i.attributes)
         }
         return r
     }
-    _autoUpdater(e, {
+    _autoUpdater(t, {
         data: r,
         startRow: s,
         endRow: i,
         props: n,
         numInstances: o
     }) {
-        if (e.constant) return;
+        if (t.constant) return;
         let {
             settings: a,
             state: c,
             value: l,
-            size: h,
+            size: f,
             startIndices: d
-        } = e, {
+        } = t, {
             accessor: p,
             transform: m
         } = a, y = c.binaryAccessor || (typeof p == "function" ? p : n[p]);
         J(typeof y == "function", `accessor "${p}" is not a function`);
-        let x = e.getVertexOffset(s),
+        let E = t.getVertexOffset(s),
             {
-                iterable: b,
-                objectInfo: w
-            } = $h(r, s, i);
-        for (let R of b) {
-            w.index++;
-            let v = y(R, w);
+                iterable: T,
+                objectInfo: S
+            } = Yf(r, s, i);
+        for (let R of T) {
+            S.index++;
+            let v = y(R, S);
             if (m && (v = m.call(this, v)), d) {
-                let C = (w.index < d.length - 1 ? d[w.index + 1] : o) - d[w.index];
+                let C = (S.index < d.length - 1 ? d[S.index + 1] : o) - d[S.index];
                 if (v && Array.isArray(v[0])) {
-                    let O = x;
-                    for (let N of v) e._normalizeValue(N, l, O), O += h
-                } else v && v.length > h ? l.set(v, x) : (e._normalizeValue(v, w.target, 0), Ap({
+                    let O = E;
+                    for (let N of v) t._normalizeValue(N, l, O), O += f
+                } else v && v.length > f ? l.set(v, E) : (t._normalizeValue(v, S.target, 0), Ep({
                     target: l,
-                    source: w.target,
-                    start: x,
+                    source: S.target,
+                    start: E,
                     count: C
                 }));
-                x += C * h
-            } else e._normalizeValue(v, l, x), x += h
+                E += C * f
+            } else t._normalizeValue(v, l, E), E += f
         }
     }
     _validateAttributeUpdaters() {
         let {
-            settings: e
+            settings: t
         } = this;
-        if (!(e.noAlloc || typeof e.update == "function")) throw new Error(`Attribute ${this.id} missing update or accessor`)
+        if (!(t.noAlloc || typeof t.update == "function")) throw new Error(`Attribute ${this.id} missing update or accessor`)
     }
     _checkAttributeArray() {
         let {
-            value: e
+            value: t
         } = this, r = Math.min(4, this.size);
-        if (e && e.length >= r) {
+        if (t && t.length >= r) {
             let s = !0;
             switch (r) {
                 case 4:
-                    s = s && Number.isFinite(e[3]);
+                    s = s && Number.isFinite(t[3]);
                 case 3:
-                    s = s && Number.isFinite(e[2]);
+                    s = s && Number.isFinite(t[2]);
                 case 2:
-                    s = s && Number.isFinite(e[1]);
+                    s = s && Number.isFinite(t[1]);
                 case 1:
-                    s = s && Number.isFinite(e[0]);
+                    s = s && Number.isFinite(t[0]);
                     break;
                 default:
                     s = !1
             }
             if (!s) throw new Error(`Illegal attribute generated for ${this.id}`)
         }
     }
 };
 
-function Yh(t) {
+function qf(e) {
     let {
-        source: e,
+        source: t,
         target: r,
         start: s = 0,
         size: i,
         getData: n
-    } = t, o = t.end || r.length, a = e.length, c = o - s;
+    } = e, o = e.end || r.length, a = t.length, c = o - s;
     if (a > c) {
-        r.set(e.subarray(0, c), s);
+        r.set(t.subarray(0, c), s);
         return
     }
-    if (r.set(e, s), !n) return;
+    if (r.set(t, s), !n) return;
     let l = a;
     for (; l < c;) {
-        let h = n(l, e);
-        for (let d = 0; d < i; d++) r[s + l] = h[d] || 0, l++
+        let f = n(l, t);
+        for (let d = 0; d < i; d++) r[s + l] = f[d] || 0, l++
     }
 }
 
-function Jg({
-    source: t,
-    target: e,
+function G_({
+    source: e,
+    target: t,
     size: r,
     getData: s,
     sourceStartIndices: i,
     targetStartIndices: n
 }) {
-    if (!i || !n) return Yh({
-        source: t,
-        target: e,
+    if (!i || !n) return qf({
+        source: e,
+        target: t,
         size: r,
         getData: s
-    }), e;
+    }), t;
     let o = 0,
         a = 0,
-        c = s && ((h, d) => s(h + a, d)),
+        c = s && ((f, d) => s(f + a, d)),
         l = Math.min(i.length, n.length);
-    for (let h = 1; h < l; h++) {
-        let d = i[h] * r,
-            p = n[h] * r;
-        Yh({
-            source: t.subarray(o, d),
-            target: e,
+    for (let f = 1; f < l; f++) {
+        let d = i[f] * r,
+            p = n[f] * r;
+        qf({
+            source: e.subarray(o, d),
+            target: t,
             start: a,
             end: p,
             size: r,
             getData: c
         }), o = d, a = p
     }
-    return a < e.length && Yh({
+    return a < t.length && qf({
         source: [],
-        target: e,
+        target: t,
         start: a,
         size: r,
         getData: c
-    }), e
+    }), t
 }
 
-function Gg(t) {
+function tg(e) {
     let {
-        device: e,
+        device: t,
         settings: r,
         value: s
-    } = t, i = new or(e, r);
+    } = e, i = new or(t, r);
     return i.setData({
         value: s instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
         normalized: r.normalized
     }), i
 }
 
-function Ma(t) {
-    switch (t) {
+function Ma(e) {
+    switch (e) {
         case 1:
             return "float";
         case 2:
             return "vec2";
         case 3:
             return "vec3";
         case 4:
             return "vec4";
         default:
-            throw new Error(`No defined attribute type for size "${t}"`)
+            throw new Error(`No defined attribute type for size "${e}"`)
     }
 }
 
-function Pa(t) {
-    switch (t) {
+function Pa(e) {
+    switch (e) {
         case 1:
             return "float32";
         case 2:
             return "float32x2";
         case 3:
             return "float32x3";
         case 4:
             return "float32x4";
         default:
             throw new Error("invalid type size")
     }
 }
 
-function Ca(t) {
-    t.push(t.shift())
+function Ca(e) {
+    e.push(e.shift())
 }
 
-function e_(t, e) {
+function eg(e, t) {
     let {
         doublePrecision: r,
         settings: s,
         value: i,
         size: n
-    } = t, o = r && i instanceof Float64Array ? 2 : 1, a = 0, {
+    } = e, o = r && i instanceof Float64Array ? 2 : 1, a = 0, {
         shaderAttributes: c
-    } = t.settings;
+    } = e.settings;
     if (c)
         for (let l of Object.values(c)) a = Math.max(a, l.vertexOffset ?? 0);
-    return (s.noAlloc ? i.length : (e + a) * n) * o
+    return (s.noAlloc ? i.length : (t + a) * n) * o
 }
 
 function Ia({
-    device: t,
-    source: e,
+    device: e,
+    source: t,
     target: r
 }) {
-    return (!r || r.byteLength < e.byteLength) && (r?.destroy(), r = t.createBuffer({
-        byteLength: e.byteLength,
-        usage: e.usage
+    return (!r || r.byteLength < t.byteLength) && (r?.destroy(), r = e.createBuffer({
+        byteLength: t.byteLength,
+        usage: t.usage
     })), r
 }
 
 function Oa({
-    device: t,
-    buffer: e,
+    device: e,
+    buffer: t,
     attribute: r,
     fromLength: s,
     toLength: i,
     fromStartIndices: n,
     getData: o = a => a
 }) {
     let a = r.doublePrecision && r.value instanceof Float64Array ? 2 : 1,
         c = r.size * a,
         l = r.byteOffset,
-        h = r.settings.bytesPerElement < 4 ? l / r.settings.bytesPerElement * 4 : l,
+        f = r.settings.bytesPerElement < 4 ? l / r.settings.bytesPerElement * 4 : l,
         d = r.startIndices,
         p = n && d,
         m = r.isConstant;
-    if (!p && e && s >= i) return e;
+    if (!p && t && s >= i) return t;
     let y = r.value instanceof Float64Array ? Float32Array : r.value.constructor,
-        x = m ? r.value : new y(r.getBuffer().readSyncWebGL(l, i * y.BYTES_PER_ELEMENT).buffer);
+        E = m ? r.value : new y(r.getBuffer().readSyncWebGL(l, i * y.BYTES_PER_ELEMENT).buffer);
     if (r.settings.normalized && !m) {
         let v = o;
         o = (C, O) => r.normalizeConstant(v(C, O))
     }
-    let b = m ? (v, C) => o(x, C) : (v, C) => o(x.subarray(v + l, v + l + c), C),
-        w = e ? new Float32Array(e.readSyncWebGL(h, s * 4).buffer) : new Float32Array(0),
+    let T = m ? (v, C) => o(E, C) : (v, C) => o(E.subarray(v + l, v + l + c), C),
+        S = t ? new Float32Array(t.readSyncWebGL(f, s * 4).buffer) : new Float32Array(0),
         R = new Float32Array(i);
-    return Jg({
-        source: w,
+    return G_({
+        source: S,
         target: R,
         sourceStartIndices: n,
         targetStartIndices: d,
         size: c,
-        getData: b
-    }), (!e || e.byteLength < R.byteLength + h) && (e?.destroy(), e = t.createBuffer({
-        byteLength: R.byteLength + h,
+        getData: T
+    }), (!t || t.byteLength < R.byteLength + f) && (t?.destroy(), t = e.createBuffer({
+        byteLength: R.byteLength + f,
         usage: 35050
-    })), e.write(R, h), e
+    })), t.write(R, f), t
 }
 var vs = class {
     constructor({
-        device: e,
+        device: t,
         attribute: r,
         timeline: s
     }) {
-        this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new qe(s), this.attribute = r, this.attributeInTransition = Gg(r), this.currentStartIndices = r.startIndices
+        this.buffers = [], this.currentLength = 0, this.device = t, this.transition = new qt(s), this.attribute = r, this.attributeInTransition = tg(r), this.currentStartIndices = r.startIndices
     }
     get inProgress() {
         return this.transition.inProgress
     }
-    start(e, r, s = 1 / 0) {
-        this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = e_(this.attribute, r), this.transition.start({
-            ...e,
+    start(t, r, s = 1 / 0) {
+        this.settings = t, this.currentStartIndices = this.attribute.startIndices, this.currentLength = eg(this.attribute, r), this.transition.start({
+            ...t,
             duration: s
         })
     }
     update() {
-        let e = this.transition.update();
-        return e && this.onUpdate(), e
+        let t = this.transition.update();
+        return t && this.onUpdate(), t
     }
-    setBuffer(e) {
+    setBuffer(t) {
         this.attributeInTransition.setData({
-            buffer: e,
+            buffer: t,
             normalized: this.attribute.settings.normalized,
             value: this.attributeInTransition.value
         })
     }
     cancel() {
         this.transition.cancel()
     }
     delete() {
         this.cancel();
-        for (let e of this.buffers) e.destroy();
+        for (let t of this.buffers) t.destroy();
         this.buffers.length = 0
     }
 };
 var on = class extends vs {
         constructor({
-            device: e,
+            device: t,
             attribute: r,
             timeline: s
         }) {
             super({
-                device: e,
+                device: t,
                 attribute: r,
                 timeline: s
-            }), this.type = "interpolation", this.transform = d1(e, r)
+            }), this.type = "interpolation", this.transform = _1(t, r)
         }
-        start(e, r) {
+        start(t, r) {
             let s = this.currentLength,
                 i = this.currentStartIndices;
-            if (super.start(e, r, e.duration), e.duration <= 0) {
+            if (super.start(t, r, t.duration), t.duration <= 0) {
                 this.transition.cancel();
                 return
             }
             let {
                 buffers: n,
                 attribute: o
             } = this;
             Ca(n), n[0] = Oa({
                 device: this.device,
                 buffer: n[0],
                 attribute: o,
                 fromLength: s,
                 toLength: this.currentLength,
                 fromStartIndices: i,
-                getData: e.enter
+                getData: t.enter
             }), n[1] = Ia({
                 device: this.device,
                 source: n[0],
                 target: n[1]
             }), this.setBuffer(n[1]);
             let {
                 transform: a
@@ -21673,92 +21673,92 @@
                 aTo: o.getBuffer()
             }), a.transformFeedback.setBuffers({
                 vCurrent: n[1]
             })
         }
         onUpdate() {
             let {
-                duration: e,
+                duration: t,
                 easing: r
             } = this.settings, {
                 time: s
-            } = this.transition, i = s / e;
+            } = this.transition, i = s / t;
             r && (i = r(i));
             let {
                 model: n
             } = this.transform;
             n.setUniforms({
                 time: i
             }), n.device.gl.bindBuffer(34962, null), this.transform.run({
                 discard: !0
             })
         }
         delete() {
             super.delete(), this.transform.destroy()
         }
     },
-    u1 = `#version 300 es
+    p1 = `#version 300 es
 #define SHADER_NAME interpolation-transition-vertex-shader
 
 uniform float time;
 in ATTRIBUTE_TYPE aFrom;
 in ATTRIBUTE_TYPE aTo;
 out ATTRIBUTE_TYPE vCurrent;
 
 void main(void) {
   vCurrent = mix(aFrom, aTo, time);
   gl_Position = vec4(0.0);
 }
 `;
 
-function d1(t, e) {
-    let r = Ma(e.size);
-    return new Ir(t, {
-        vs: u1,
+function _1(e, t) {
+    let r = Ma(t.size);
+    return new Ir(e, {
+        vs: p1,
         bufferLayout: [{
             name: "aFrom",
-            format: Pa(e.size)
+            format: Pa(t.size)
         }, {
             name: "aTo",
-            format: e.getBufferLayout().attributes[0].format
+            format: t.getBufferLayout().attributes[0].format
         }],
         defines: {
             ATTRIBUTE_TYPE: r
         },
         varyings: ["vCurrent"]
     })
 }
 var an = class extends vs {
         constructor({
-            device: e,
+            device: t,
             attribute: r,
             timeline: s
         }) {
             super({
-                device: e,
+                device: t,
                 attribute: r,
                 timeline: s
-            }), this.type = "spring", this.texture = m1(e), this.framebuffer = T1(e, this.texture), this.transform = _1(e, r)
+            }), this.type = "spring", this.texture = y1(t), this.framebuffer = T1(t, this.texture), this.transform = b1(t, r)
         }
-        start(e, r) {
+        start(t, r) {
             let s = this.currentLength,
                 i = this.currentStartIndices;
-            super.start(e, r);
+            super.start(t, r);
             let {
                 buffers: n,
                 attribute: o
             } = this;
             for (let c = 0; c < 2; c++) n[c] = Oa({
                 device: this.device,
                 buffer: n[c],
                 attribute: o,
                 fromLength: s,
                 toLength: this.currentLength,
                 fromStartIndices: i,
-                getData: e.enter
+                getData: t.enter
             });
             n[2] = Ia({
                 device: this.device,
                 source: n[0],
                 target: n[2]
             }), this.setBuffer(n[1]);
             let {
@@ -21768,41 +21768,41 @@
                 aTo: o.value
             }) : a.setAttributes({
                 aTo: o.getBuffer()
             })
         }
         onUpdate() {
             let {
-                buffers: e,
+                buffers: t,
                 transform: r,
                 framebuffer: s,
                 transition: i
             } = this, n = this.settings;
             r.model.setAttributes({
-                aPrev: e[0],
-                aCur: e[1]
+                aPrev: t[0],
+                aCur: t[1]
             }), r.transformFeedback.setBuffers({
-                vNext: e[2]
+                vNext: t[2]
             }), r.model.setUniforms({
                 stiffness: n.stiffness,
                 damping: n.damping
             }), r.run({
                 framebuffer: s,
                 discard: !1,
                 parameters: {
                     viewport: [0, 0, 1, 1]
                 },
                 clearColor: [0, 0, 0, 0]
-            }), Ca(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(s)[0] > 0 || i.end()
+            }), Ca(t), this.setBuffer(t[1]), this.device.readPixelsToArrayWebGL(s)[0] > 0 || i.end()
         }
         delete() {
             super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy()
         }
     },
-    p1 = `#version 300 es
+    g1 = `#version 300 es
 #define SHADER_NAME spring-transition-vertex-shader
 
 #define EPSILON 0.00001
 
 uniform float stiffness;
 uniform float damping;
 in ATTRIBUTE_TYPE aPrev;
@@ -21824,43 +21824,43 @@
   vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;
 
   vNext = getNextValue(aCur, aPrev, aTo);
   gl_Position = vec4(0, 0, 0, 1);
   gl_PointSize = 100.0;
 }
 `,
-    g1 = `#version 300 es
+    m1 = `#version 300 es
 #define SHADER_NAME spring-transition-is-transitioning-fragment-shader
 
 in float vIsTransitioningFlag;
 
 out vec4 fragColor;
 
 void main(void) {
   if (vIsTransitioningFlag == 0.0) {
     discard;
   }
   fragColor = vec4(1.0);
 }`;
 
-function _1(t, e) {
-    let r = Ma(e.size),
-        s = Pa(e.size);
-    return new Ir(t, {
-        vs: p1,
-        fs: g1,
+function b1(e, t) {
+    let r = Ma(t.size),
+        s = Pa(t.size);
+    return new Ir(e, {
+        vs: g1,
+        fs: m1,
         bufferLayout: [{
             name: "aPrev",
             format: s
         }, {
             name: "aCur",
             format: s
         }, {
             name: "aTo",
-            format: e.getBufferLayout().attributes[0].format
+            format: t.getBufferLayout().attributes[0].format
         }],
         varyings: ["vNext"],
         defines: {
             ATTRIBUTE_TYPE: r
         },
         parameters: {
             depthCompare: "always",
@@ -21870,966 +21870,966 @@
             blendAlphaOperation: "max",
             blendAlphaSrcFactor: "one",
             blendAlphaDstFactor: "one"
         }
     })
 }
 
-function m1(t) {
-    return t.createTexture({
+function y1(e) {
+    return e.createTexture({
         data: new Uint8Array(4),
         format: "rgba8unorm",
         mipmaps: !1,
         width: 1,
         height: 1
     })
 }
 
-function T1(t, e) {
-    return t.createFramebuffer({
+function T1(e, t) {
+    return e.createFramebuffer({
         id: "spring-transition-is-transitioning-framebuffer",
         width: 1,
         height: 1,
-        colorAttachments: [e]
+        colorAttachments: [t]
     })
 }
-var y1 = {
+var w1 = {
         interpolation: on,
         spring: an
     },
     cn = class {
-        constructor(e, {
+        constructor(t, {
             id: r,
             timeline: s
         }) {
-            if (!e) throw new Error("AttributeTransitionManager is constructed without device");
-            this.id = r, this.device = e, this.timeline = s, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1
+            if (!t) throw new Error("AttributeTransitionManager is constructed without device");
+            this.id = r, this.device = t, this.timeline = s, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1
         }
         finalize() {
-            for (let e in this.transitions) this._removeTransition(e)
+            for (let t in this.transitions) this._removeTransition(t)
         }
         update({
-            attributes: e,
+            attributes: t,
             transitions: r,
             numInstances: s
         }) {
             this.numInstances = s || 1;
-            for (let i in e) {
-                let n = e[i],
+            for (let i in t) {
+                let n = t[i],
                     o = n.getTransitionSetting(r);
                 o && this._updateAttribute(i, n, o)
             }
             for (let i in this.transitions) {
-                let n = e[i];
+                let n = t[i];
                 (!n || !n.getTransitionSetting(r)) && this._removeTransition(i)
             }
         }
-        hasAttribute(e) {
-            let r = this.transitions[e];
+        hasAttribute(t) {
+            let r = this.transitions[t];
             return r && r.inProgress
         }
         getAttributes() {
-            let e = {};
+            let t = {};
             for (let r in this.transitions) {
                 let s = this.transitions[r];
-                s.inProgress && (e[r] = s.attributeInTransition)
+                s.inProgress && (t[r] = s.attributeInTransition)
             }
-            return e
+            return t
         }
         run() {
             if (this.numInstances === 0) return !1;
             for (let r in this.transitions) this.transitions[r].update() && (this.needsRedraw = !0);
-            let e = this.needsRedraw;
-            return this.needsRedraw = !1, e
+            let t = this.needsRedraw;
+            return this.needsRedraw = !1, t
         }
-        _removeTransition(e) {
-            this.transitions[e].delete(), delete this.transitions[e]
+        _removeTransition(t) {
+            this.transitions[t].delete(), delete this.transitions[t]
         }
-        _updateAttribute(e, r, s) {
-            let i = this.transitions[e],
+        _updateAttribute(t, r, s) {
+            let i = this.transitions[t],
                 n = !i || i.type !== s.type;
             if (n) {
-                i && this._removeTransition(e);
-                let o = y1[s.type];
-                o ? this.transitions[e] = new o({
+                i && this._removeTransition(t);
+                let o = w1[s.type];
+                o ? this.transitions[t] = new o({
                     attribute: r,
                     timeline: this.timeline,
                     device: this.device
                 }) : (W.error(`unsupported transition type '${s.type}'`)(), n = !1)
-            }(n || r.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(s, this.numInstances))
+            }(n || r.needsRedraw()) && (this.needsRedraw = !0, this.transitions[t].start(s, this.numInstances))
         }
     };
-var t_ = "attributeManager.invalidate",
-    b1 = "attributeManager.updateStart",
+var rg = "attributeManager.invalidate",
+    A1 = "attributeManager.updateStart",
     E1 = "attributeManager.updateEnd",
-    A1 = "attribute.updateStart",
-    x1 = "attribute.allocate",
-    S1 = "attribute.updateEnd",
+    x1 = "attribute.updateStart",
+    S1 = "attribute.allocate",
+    R1 = "attribute.updateEnd",
     Ms = class {
-        constructor(e, {
+        constructor(t, {
             id: r = "attribute-manager",
             stats: s,
             timeline: i
         } = {}) {
-            this.mergeBoundsMemoized = ft(up), this.id = r, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = s, this.attributeTransitionManager = new cn(e, {
+            this.mergeBoundsMemoized = he(dp), this.id = r, this.device = t, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = s, this.attributeTransitionManager = new cn(t, {
                 id: `${r}-transitions`,
                 timeline: i
             }), Object.seal(this)
         }
         finalize() {
-            for (let e in this.attributes) this.attributes[e].delete();
+            for (let t in this.attributes) this.attributes[t].delete();
             this.attributeTransitionManager.finalize()
         }
-        getNeedsRedraw(e = {
+        getNeedsRedraw(t = {
             clearRedrawFlags: !1
         }) {
             let r = this.needsRedraw;
-            return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, r && this.id
+            return this.needsRedraw = this.needsRedraw && !t.clearRedrawFlags, r && this.id
         }
         setNeedsRedraw() {
             this.needsRedraw = !0
         }
-        add(e) {
-            this._add(e)
+        add(t) {
+            this._add(t)
         }
-        addInstanced(e) {
-            this._add(e, {
+        addInstanced(t) {
+            this._add(t, {
                 instanced: 1
             })
         }
-        remove(e) {
-            for (let r of e) this.attributes[r] !== void 0 && (this.attributes[r].delete(), delete this.attributes[r])
+        remove(t) {
+            for (let r of t) this.attributes[r] !== void 0 && (this.attributes[r].delete(), delete this.attributes[r])
         }
-        invalidate(e, r) {
-            let s = this._invalidateTrigger(e, r);
-            re(t_, this, e, s)
-        }
-        invalidateAll(e) {
-            for (let r in this.attributes) this.attributes[r].setNeedsUpdate(r, e);
-            re(t_, this, "all")
+        invalidate(t, r) {
+            let s = this._invalidateTrigger(t, r);
+            rt(rg, this, t, s)
+        }
+        invalidateAll(t) {
+            for (let r in this.attributes) this.attributes[r].setNeedsUpdate(r, t);
+            rt(rg, this, "all")
         }
         update({
-            data: e,
+            data: t,
             numInstances: r,
             startIndices: s = null,
             transitions: i,
             props: n = {},
             buffers: o = {},
             context: a = {}
         }) {
             let c = !1;
-            re(b1, this), this.stats && this.stats.get("Update Attributes").timeStart();
+            rt(A1, this), this.stats && this.stats.get("Update Attributes").timeStart();
             for (let l in this.attributes) {
-                let h = this.attributes[l],
-                    d = h.settings.accessor;
-                h.startIndices = s, h.numInstances = r, n[l] && W.removed(`props.${l}`, `data.attributes.${l}`)(), h.setExternalBuffer(o[l]) || h.setBinaryValue(typeof d == "string" ? o[d] : void 0, e.startIndices) || typeof d == "string" && !o[d] && h.setConstantValue(n[d]) || h.needsUpdate() && (c = !0, this._updateAttribute({
-                    attribute: h,
+                let f = this.attributes[l],
+                    d = f.settings.accessor;
+                f.startIndices = s, f.numInstances = r, n[l] && W.removed(`props.${l}`, `data.attributes.${l}`)(), f.setExternalBuffer(o[l]) || f.setBinaryValue(typeof d == "string" ? o[d] : void 0, t.startIndices) || typeof d == "string" && !o[d] && f.setConstantValue(n[d]) || f.needsUpdate() && (c = !0, this._updateAttribute({
+                    attribute: f,
                     numInstances: r,
-                    data: e,
+                    data: t,
                     props: n,
                     context: a
-                })), this.needsRedraw = this.needsRedraw || h.needsRedraw()
+                })), this.needsRedraw = this.needsRedraw || f.needsRedraw()
             }
-            c && re(E1, this, r), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
+            c && rt(E1, this, r), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
                 attributes: this.attributes,
                 numInstances: r,
                 transitions: i
             })
         }
         updateTransition() {
             let {
-                attributeTransitionManager: e
-            } = this, r = e.run();
+                attributeTransitionManager: t
+            } = this, r = t.run();
             return this.needsRedraw = this.needsRedraw || r, r
         }
         getAttributes() {
             return {
                 ...this.attributes,
                 ...this.attributeTransitionManager.getAttributes()
             }
         }
-        getBounds(e) {
-            let r = e.map(s => this.attributes[s]?.getBounds());
+        getBounds(t) {
+            let r = t.map(s => this.attributes[s]?.getBounds());
             return this.mergeBoundsMemoized(r)
         }
-        getChangedAttributes(e = {
+        getChangedAttributes(t = {
             clearChangedFlags: !1
         }) {
             let {
                 attributes: r,
                 attributeTransitionManager: s
             } = this, i = {
                 ...s.getAttributes()
             };
             for (let n in r) {
                 let o = r[n];
-                o.needsRedraw(e) && !s.hasAttribute(n) && (i[n] = o)
+                o.needsRedraw(t) && !s.hasAttribute(n) && (i[n] = o)
             }
             return i
         }
-        getBufferLayouts(e, r = {}) {
-            e || (e = this.getAttributes());
+        getBufferLayouts(t, r = {}) {
+            t || (t = this.getAttributes());
             let s = [];
-            for (let i in e) r[i] || s.push(e[i].getBufferLayout());
+            for (let i in t) r[i] || s.push(t[i].getBufferLayout());
             return s
         }
-        _add(e, r = {}) {
-            for (let s in e) {
-                let i = e[s];
+        _add(t, r = {}) {
+            for (let s in t) {
+                let i = t[s];
                 this.attributes[s] = this._createAttribute(s, i, r)
             }
             this._mapUpdateTriggersToAttributes()
         }
-        _createAttribute(e, r, s) {
+        _createAttribute(t, r, s) {
             let i = {
                 ...r,
-                id: e,
+                id: t,
                 size: r.isIndexed && 1 || r.size || 1,
                 divisor: s.instanced ? 1 : r.divisor || 0
             };
             return new or(this.device, i)
         }
         _mapUpdateTriggersToAttributes() {
-            let e = {};
+            let t = {};
             for (let r in this.attributes) this.attributes[r].getUpdateTriggers().forEach(i => {
-                e[i] || (e[i] = []), e[i].push(r)
+                t[i] || (t[i] = []), t[i].push(r)
             });
-            this.updateTriggers = e
+            this.updateTriggers = t
         }
-        _invalidateTrigger(e, r) {
+        _invalidateTrigger(t, r) {
             let {
                 attributes: s,
                 updateTriggers: i
-            } = this, n = i[e];
+            } = this, n = i[t];
             return n && n.forEach(o => {
                 let a = s[o];
                 a && a.setNeedsUpdate(a.id, r)
             }), n
         }
-        _updateAttribute(e) {
+        _updateAttribute(t) {
             let {
                 attribute: r,
                 numInstances: s
-            } = e;
-            if (re(A1, r), r.constant) {
+            } = t;
+            if (rt(x1, r), r.constant) {
                 r.setConstantValue(r.value);
                 return
             }
-            r.allocate(s) && re(x1, r, s), r.updateBuffer(e) && (this.needsRedraw = !0, re(S1, r, s))
+            r.allocate(s) && rt(S1, r, s), r.updateBuffer(t) && (this.needsRedraw = !0, rt(R1, r, s))
         }
     };
-var ln = class extends qe {
+var ln = class extends qt {
     get value() {
         return this._value
     }
     _onUpdate() {
         let {
-            time: e,
+            time: t,
             settings: {
                 fromValue: r,
                 toValue: s,
                 duration: i,
                 easing: n
             }
-        } = this, o = n(e / i);
+        } = this, o = n(t / i);
         this._value = vr(r, s, o)
     }
 };
-var r_ = 1e-5;
+var sg = 1e-5;
 
-function s_(t, e, r, s, i) {
-    let n = e - t,
-        a = (r - e) * i,
+function ig(e, t, r, s, i) {
+    let n = t - e,
+        a = (r - t) * i,
         c = -n * s;
-    return a + c + n + e
+    return a + c + n + t
 }
 
-function w1(t, e, r, s, i) {
+function v1(e, t, r, s, i) {
     if (Array.isArray(r)) {
         let n = [];
-        for (let o = 0; o < r.length; o++) n[o] = s_(t[o], e[o], r[o], s, i);
+        for (let o = 0; o < r.length; o++) n[o] = ig(e[o], t[o], r[o], s, i);
         return n
     }
-    return s_(t, e, r, s, i)
+    return ig(e, t, r, s, i)
 }
 
-function i_(t, e) {
-    if (Array.isArray(t)) {
+function ng(e, t) {
+    if (Array.isArray(e)) {
         let r = 0;
-        for (let s = 0; s < t.length; s++) {
-            let i = t[s] - e[s];
+        for (let s = 0; s < e.length; s++) {
+            let i = e[s] - t[s];
             r += i * i
         }
         return Math.sqrt(r)
     }
-    return Math.abs(t - e)
+    return Math.abs(e - t)
 }
-var hn = class extends qe {
+var fn = class extends qt {
     get value() {
         return this._currValue
     }
     _onUpdate() {
         let {
-            fromValue: e,
+            fromValue: t,
             toValue: r,
             damping: s,
             stiffness: i
         } = this.settings, {
-            _prevValue: n = e,
-            _currValue: o = e
-        } = this, a = w1(n, o, r, s, i), c = i_(a, r), l = i_(a, o);
-        c < r_ && l < r_ && (a = r, this.end()), this._prevValue = o, this._currValue = a
+            _prevValue: n = t,
+            _currValue: o = t
+        } = this, a = v1(n, o, r, s, i), c = ng(a, r), l = ng(a, o);
+        c < sg && l < sg && (a = r, this.end()), this._prevValue = o, this._currValue = a
     }
 };
-var R1 = {
+var M1 = {
         interpolation: ln,
-        spring: hn
+        spring: fn
     },
-    fn = class {
-        constructor(e) {
-            this.transitions = new Map, this.timeline = e
+    hn = class {
+        constructor(t) {
+            this.transitions = new Map, this.timeline = t
         }
         get active() {
             return this.transitions.size > 0
         }
-        add(e, r, s, i) {
+        add(t, r, s, i) {
             let {
                 transitions: n
             } = this;
-            if (n.has(e)) {
-                let c = n.get(e),
+            if (n.has(t)) {
+                let c = n.get(t),
                     {
                         value: l = c.settings.fromValue
                     } = c;
-                r = l, this.remove(e)
+                r = l, this.remove(t)
             }
             if (i = va(i), !i) return;
-            let o = R1[i.type];
+            let o = M1[i.type];
             if (!o) {
                 W.error(`unsupported transition type '${i.type}'`)();
                 return
             }
             let a = new o(this.timeline);
             a.start({
                 ...i,
                 fromValue: r,
                 toValue: s
-            }), n.set(e, a)
+            }), n.set(t, a)
         }
-        remove(e) {
+        remove(t) {
             let {
                 transitions: r
             } = this;
-            r.has(e) && (r.get(e).cancel(), r.delete(e))
+            r.has(t) && (r.get(t).cancel(), r.delete(t))
         }
         update() {
-            let e = {};
-            for (let [r, s] of this.transitions) s.update(), e[r] = s.value, s.inProgress || this.remove(r);
-            return e
+            let t = {};
+            for (let [r, s] of this.transitions) s.update(), t[r] = s.value, s.inProgress || this.remove(r);
+            return t
         }
         clear() {
-            for (let e of this.transitions.keys()) this.remove(e)
+            for (let t of this.transitions.keys()) this.remove(t)
         }
     };
 
-function o_(t) {
-    let e = t[ut];
-    for (let r in e) {
-        let s = e[r],
+function ag(e) {
+    let t = e[ue];
+    for (let r in t) {
+        let s = t[r],
             {
                 validate: i
             } = s;
-        if (i && !i(t[r], s)) throw new Error(`Invalid prop ${r}: ${t[r]}`)
+        if (i && !i(e[r], s)) throw new Error(`Invalid prop ${r}: ${e[r]}`)
     }
 }
 
-function a_(t, e) {
-    let r = c_({
-            newProps: t,
-            oldProps: e,
-            propTypes: t[ut],
+function cg(e, t) {
+    let r = lg({
+            newProps: e,
+            oldProps: t,
+            propTypes: e[ue],
             ignoreProps: {
                 data: null,
                 updateTriggers: null,
                 extensions: null,
                 transitions: null
             }
         }),
-        s = M1(t, e),
+        s = C1(e, t),
         i = !1;
-    return s || (i = P1(t, e)), {
+    return s || (i = I1(e, t)), {
         dataChanged: s,
         propsChanged: r,
         updateTriggersChanged: i,
-        extensionsChanged: C1(t, e),
-        transitionsChanged: v1(t, e)
+        extensionsChanged: O1(e, t),
+        transitionsChanged: P1(e, t)
     }
 }
 
-function v1(t, e) {
-    if (!t.transitions) return !1;
+function P1(e, t) {
+    if (!e.transitions) return !1;
     let r = {},
-        s = t[ut],
+        s = e[ue],
         i = !1;
-    for (let n in t.transitions) {
+    for (let n in e.transitions) {
         let o = s[n],
             a = o && o.type;
-        (a === "number" || a === "color" || a === "array") && qh(t[n], e[n], o) && (r[n] = !0, i = !0)
+        (a === "number" || a === "color" || a === "array") && Kf(e[n], t[n], o) && (r[n] = !0, i = !0)
     }
     return i ? r : !1
 }
 
-function c_({
-    newProps: t,
-    oldProps: e,
+function lg({
+    newProps: e,
+    oldProps: t,
     ignoreProps: r = {},
     propTypes: s = {},
     triggerName: i = "props"
 }) {
-    if (e === t) return !1;
-    if (typeof t != "object" || t === null) return `${i} changed shallowly`;
+    if (t === e) return !1;
     if (typeof e != "object" || e === null) return `${i} changed shallowly`;
-    for (let n of Object.keys(t))
+    if (typeof t != "object" || t === null) return `${i} changed shallowly`;
+    for (let n of Object.keys(e))
         if (!(n in r)) {
-            if (!(n in e)) return `${i}.${n} added`;
-            let o = qh(t[n], e[n], s[n]);
+            if (!(n in t)) return `${i}.${n} added`;
+            let o = Kf(e[n], t[n], s[n]);
             if (o) return `${i}.${n} ${o}`
-        } for (let n of Object.keys(e))
+        } for (let n of Object.keys(t))
         if (!(n in r)) {
-            if (!(n in t)) return `${i}.${n} dropped`;
-            if (!Object.hasOwnProperty.call(t, n)) {
-                let o = qh(t[n], e[n], s[n]);
+            if (!(n in e)) return `${i}.${n} dropped`;
+            if (!Object.hasOwnProperty.call(e, n)) {
+                let o = Kf(e[n], t[n], s[n]);
                 if (o) return `${i}.${n} ${o}`
             }
         } return !1
 }
 
-function qh(t, e, r) {
+function Kf(e, t, r) {
     let s = r && r.equal;
-    return s && !s(t, e, r) || !s && (s = t && e && t.equals, s && !s.call(t, e)) ? "changed deeply" : !s && e !== t ? "changed shallowly" : null
+    return s && !s(e, t, r) || !s && (s = e && t && e.equals, s && !s.call(e, t)) ? "changed deeply" : !s && t !== e ? "changed shallowly" : null
 }
 
-function M1(t, e) {
-    if (e === null) return "oldProps is null, initial diff";
+function C1(e, t) {
+    if (t === null) return "oldProps is null, initial diff";
     let r = !1,
         {
             dataComparator: s,
             _dataDiff: i
-        } = t;
-    return s ? s(t.data, e.data) || (r = "Data comparator detected a change") : t.data !== e.data && (r = "A new data container was supplied"), r && i && (r = i(t.data, e.data) || r), r
+        } = e;
+    return s ? s(e.data, t.data) || (r = "Data comparator detected a change") : e.data !== t.data && (r = "A new data container was supplied"), r && i && (r = i(e.data, t.data) || r), r
 }
 
-function P1(t, e) {
-    if (e === null) return {
+function I1(e, t) {
+    if (t === null) return {
         all: !0
     };
-    if ("all" in t.updateTriggers && n_(t, e, "all")) return {
+    if ("all" in e.updateTriggers && og(e, t, "all")) return {
         all: !0
     };
     let r = {},
         s = !1;
-    for (let i in t.updateTriggers) i !== "all" && n_(t, e, i) && (r[i] = !0, s = !0);
+    for (let i in e.updateTriggers) i !== "all" && og(e, t, i) && (r[i] = !0, s = !0);
     return s ? r : !1
 }
 
-function C1(t, e) {
-    if (e === null) return !0;
-    let r = e.extensions,
+function O1(e, t) {
+    if (t === null) return !0;
+    let r = t.extensions,
         {
             extensions: s
-        } = t;
+        } = e;
     if (s === r) return !1;
     if (!r || !s || s.length !== r.length) return !0;
     for (let i = 0; i < s.length; i++)
         if (!s[i].equals(r[i])) return !0;
     return !1
 }
 
-function n_(t, e, r) {
-    let s = t.updateTriggers[r];
+function og(e, t, r) {
+    let s = e.updateTriggers[r];
     s = s ?? {};
-    let i = e.updateTriggers[r];
-    return i = i ?? {}, c_({
+    let i = t.updateTriggers[r];
+    return i = i ?? {}, lg({
         oldProps: i,
         newProps: s,
         triggerName: r
     })
 }
-var I1 = "count(): argument not an object",
-    O1 = "count(): argument not a container";
+var N1 = "count(): argument not an object",
+    F1 = "count(): argument not a container";
 
-function l_(t) {
-    if (!F1(t)) throw new Error(I1);
-    if (typeof t.count == "function") return t.count();
-    if (Number.isFinite(t.size)) return t.size;
-    if (Number.isFinite(t.length)) return t.length;
-    if (N1(t)) return Object.keys(t).length;
-    throw new Error(O1)
+function fg(e) {
+    if (!D1(e)) throw new Error(N1);
+    if (typeof e.count == "function") return e.count();
+    if (Number.isFinite(e.size)) return e.size;
+    if (Number.isFinite(e.length)) return e.length;
+    if (k1(e)) return Object.keys(e).length;
+    throw new Error(F1)
 }
 
-function N1(t) {
-    return t !== null && typeof t == "object" && t.constructor === Object
+function k1(e) {
+    return e !== null && typeof e == "object" && e.constructor === Object
 }
 
-function F1(t) {
-    return t !== null && typeof t == "object"
+function D1(e) {
+    return e !== null && typeof e == "object"
 }
 
-function Kh(t, e) {
-    if (!e) return t;
+function Zf(e, t) {
+    if (!t) return e;
     let r = {
-        ...t,
-        ...e
+        ...e,
+        ...t
     };
-    if ("defines" in e && (r.defines = {
-            ...t.defines,
-            ...e.defines
-        }), "modules" in e && (r.modules = (t.modules || []).concat(e.modules), e.modules.some(s => s.name === "project64"))) {
+    if ("defines" in t && (r.defines = {
+            ...e.defines,
+            ...t.defines
+        }), "modules" in t && (r.modules = (e.modules || []).concat(t.modules), t.modules.some(s => s.name === "project64"))) {
         let s = r.modules.findIndex(i => i.name === "project32");
         s >= 0 && r.modules.splice(s, 1)
     }
-    if ("inject" in e)
-        if (!t.inject) r.inject = e.inject;
+    if ("inject" in t)
+        if (!e.inject) r.inject = t.inject;
         else {
             let s = {
-                ...t.inject
+                ...e.inject
             };
-            for (let i in e.inject) s[i] = (s[i] || "") + e.inject[i];
+            for (let i in t.inject) s[i] = (s[i] || "") + t.inject[i];
             r.inject = s
         } return r
 }
-var D1 = {
+var B1 = {
         minFilter: "linear",
         mipmapFilter: "linear",
         magFilter: "linear",
         addressModeU: "clamp-to-edge",
         addressModeV: "clamp-to-edge"
     },
-    Zh = {};
+    Qf = {};
 
-function h_(t, e, r, s) {
-    if (r instanceof se) return r;
+function hg(e, t, r, s) {
+    if (r instanceof st) return r;
     r.constructor && r.constructor.name !== "Object" && (r = {
         data: r
     });
     let i = null;
     r.compressed && (i = {
         minFilter: "linear",
         mipmapFilter: r.data.length > 1 ? "nearest" : "linear"
     });
-    let n = e.createTexture({
+    let n = t.createTexture({
         ...r,
         sampler: {
-            ...D1,
+            ...B1,
             ...i,
             ...s
         }
     });
-    return Zh[n.id] = t, n
+    return Qf[n.id] = e, n
 }
 
-function f_(t, e) {
-    !e || !(e instanceof se) || Zh[e.id] === t && (e.delete(), delete Zh[e.id])
+function ug(e, t) {
+    !t || !(t instanceof st) || Qf[t.id] === e && (t.delete(), delete Qf[t.id])
 }
-var k1 = {
+var U1 = {
     boolean: {
-        validate(t, e) {
+        validate(e, t) {
             return !0
         },
-        equal(t, e, r) {
-            return !!t == !!e
+        equal(e, t, r) {
+            return !!e == !!t
         }
     },
     number: {
-        validate(t, e) {
-            return Number.isFinite(t) && (!("max" in e) || t <= e.max) && (!("min" in e) || t >= e.min)
+        validate(e, t) {
+            return Number.isFinite(e) && (!("max" in t) || e <= t.max) && (!("min" in t) || e >= t.min)
         }
     },
     color: {
-        validate(t, e) {
-            return e.optional && !t || Qh(t) && (t.length === 3 || t.length === 4)
+        validate(e, t) {
+            return t.optional && !e || Jf(e) && (e.length === 3 || e.length === 4)
         },
-        equal(t, e, r) {
-            return ue(t, e, 1)
+        equal(e, t, r) {
+            return ut(e, t, 1)
         }
     },
     accessor: {
-        validate(t, e) {
-            let r = Na(t);
-            return r === "function" || r === Na(e.value)
+        validate(e, t) {
+            let r = Na(e);
+            return r === "function" || r === Na(t.value)
         },
-        equal(t, e, r) {
-            return typeof e == "function" ? !0 : ue(t, e, 1)
+        equal(e, t, r) {
+            return typeof t == "function" ? !0 : ut(e, t, 1)
         }
     },
     array: {
-        validate(t, e) {
-            return e.optional && !t || Qh(t)
+        validate(e, t) {
+            return t.optional && !e || Jf(e)
         },
-        equal(t, e, r) {
+        equal(e, t, r) {
             let {
                 compare: s
             } = r, i = Number.isInteger(s) ? s : s ? 1 : 0;
-            return s ? ue(t, e, i) : t === e
+            return s ? ut(e, t, i) : e === t
         }
     },
     object: {
-        equal(t, e, r) {
+        equal(e, t, r) {
             if (r.ignore) return !0;
             let {
                 compare: s
             } = r, i = Number.isInteger(s) ? s : s ? 1 : 0;
-            return s ? ue(t, e, i) : t === e
+            return s ? ut(e, t, i) : e === t
         }
     },
     function: {
-        validate(t, e) {
-            return e.optional && !t || typeof t == "function"
+        validate(e, t) {
+            return t.optional && !e || typeof e == "function"
         },
-        equal(t, e, r) {
-            return !r.compare && r.ignore !== !1 || t === e
+        equal(e, t, r) {
+            return !r.compare && r.ignore !== !1 || e === t
         }
     },
     data: {
-        transform: (t, e, r) => {
-            if (!t) return t;
+        transform: (e, t, r) => {
+            if (!e) return e;
             let {
                 dataTransform: s
             } = r.props;
-            return s ? s(t) : typeof t.shape == "string" && t.shape.endsWith("-table") && Array.isArray(t.data) ? t.data : t
+            return s ? s(e) : typeof e.shape == "string" && e.shape.endsWith("-table") && Array.isArray(e.data) ? e.data : e
         }
     },
     image: {
-        transform: (t, e, r) => {
+        transform: (e, t, r) => {
             let s = r.context;
-            return !s || !s.device ? null : h_(r.id, s.device, t, {
-                ...e.parameters,
+            return !s || !s.device ? null : hg(r.id, s.device, e, {
+                ...t.parameters,
                 ...r.props.textureParameters
             })
         },
-        release: (t, e, r) => {
-            f_(r.id, t)
+        release: (e, t, r) => {
+            ug(r.id, e)
         }
     }
 };
 
-function u_(t) {
-    let e = {},
+function dg(e) {
+    let t = {},
         r = {},
         s = {};
-    for (let [i, n] of Object.entries(t)) {
+    for (let [i, n] of Object.entries(e)) {
         let o = n?.deprecatedFor;
         if (o) s[i] = Array.isArray(o) ? o : [o];
         else {
-            let a = B1(i, n);
-            e[i] = a, r[i] = a.value
+            let a = L1(i, n);
+            t[i] = a, r[i] = a.value
         }
     }
     return {
-        propTypes: e,
+        propTypes: t,
         defaultProps: r,
         deprecatedProps: s
     }
 }
 
-function B1(t, e) {
-    switch (Na(e)) {
+function L1(e, t) {
+    switch (Na(t)) {
         case "object":
-            return un(t, e);
+            return un(e, t);
         case "array":
-            return un(t, {
+            return un(e, {
                 type: "array",
-                value: e,
+                value: t,
                 compare: !1
             });
         case "boolean":
-            return un(t, {
+            return un(e, {
                 type: "boolean",
-                value: e
+                value: t
             });
         case "number":
-            return un(t, {
+            return un(e, {
                 type: "number",
-                value: e
+                value: t
             });
         case "function":
-            return un(t, {
+            return un(e, {
                 type: "function",
-                value: e,
+                value: t,
                 compare: !0
             });
         default:
             return {
-                name: t, type: "unknown", value: e
+                name: e, type: "unknown", value: t
             }
     }
 }
 
-function un(t, e) {
-    return "type" in e ? {
-        name: t,
-        ...k1[e.type],
-        ...e
-    } : "value" in e ? {
-        name: t,
-        type: Na(e.value),
-        ...e
+function un(e, t) {
+    return "type" in t ? {
+        name: e,
+        ...U1[t.type],
+        ...t
+    } : "value" in t ? {
+        name: e,
+        type: Na(t.value),
+        ...t
     } : {
-        name: t,
+        name: e,
         type: "object",
-        value: e
+        value: t
     }
 }
 
-function Qh(t) {
-    return Array.isArray(t) || ArrayBuffer.isView(t)
+function Jf(e) {
+    return Array.isArray(e) || ArrayBuffer.isView(e)
 }
 
-function Na(t) {
-    return Qh(t) ? "array" : t === null ? "null" : typeof t
+function Na(e) {
+    return Jf(e) ? "array" : e === null ? "null" : typeof e
 }
 
-function d_(t, e) {
+function pg(e, t) {
     let r;
-    for (let n = e.length - 1; n >= 0; n--) {
-        let o = e[n];
+    for (let n = t.length - 1; n >= 0; n--) {
+        let o = t[n];
         "extensions" in o && (r = o.extensions)
     }
-    let s = Jh(t.constructor, r),
+    let s = Gf(e.constructor, r),
         i = Object.create(s);
-    i[ds] = t, i[dt] = {}, i[Ye] = {};
-    for (let n = 0; n < e.length; ++n) {
-        let o = e[n];
+    i[ds] = e, i[de] = {}, i[Yt] = {};
+    for (let n = 0; n < t.length; ++n) {
+        let o = t[n];
         for (let a in o) i[a] = o[a]
     }
     return Object.freeze(i), i
 }
-var U1 = "_mergedDefaultProps";
+var V1 = "_mergedDefaultProps";
 
-function Jh(t, e) {
-    let r = U1;
-    if (e)
-        for (let i of e) {
+function Gf(e, t) {
+    let r = V1;
+    if (t)
+        for (let i of t) {
             let n = i.constructor;
             n && (r += `:${n.extensionName||n.name}`)
         }
-    let s = p_(t, r);
-    return s || (t[r] = L1(t, e || []))
+    let s = _g(e, r);
+    return s || (e[r] = W1(e, t || []))
 }
 
-function L1(t, e) {
-    if (!t.prototype) return null;
-    let s = Object.getPrototypeOf(t),
-        i = Jh(s),
-        n = p_(t, "defaultProps") || {},
-        o = u_(n),
+function W1(e, t) {
+    if (!e.prototype) return null;
+    let s = Object.getPrototypeOf(e),
+        i = Gf(s),
+        n = _g(e, "defaultProps") || {},
+        o = dg(n),
         a = Object.assign(Object.create(null), i, o.defaultProps),
-        c = Object.assign(Object.create(null), i?.[ut], o.propTypes),
+        c = Object.assign(Object.create(null), i?.[ue], o.propTypes),
         l = Object.assign(Object.create(null), i?.[Zo], o.deprecatedProps);
-    for (let h of e) {
-        let d = Jh(h.constructor);
-        d && (Object.assign(a, d), Object.assign(c, d[ut]), Object.assign(l, d[Zo]))
+    for (let f of t) {
+        let d = Gf(f.constructor);
+        d && (Object.assign(a, d), Object.assign(c, d[ue]), Object.assign(l, d[Zo]))
     }
-    return V1(a, t), z1(a, c), W1(a, l), a[ut] = c, a[Zo] = l, e.length === 0 && !Gh(t, "_propTypes") && (t._propTypes = c), a
+    return z1(a, e), H1(a, c), j1(a, l), a[ue] = c, a[Zo] = l, t.length === 0 && !th(e, "_propTypes") && (e._propTypes = c), a
 }
 
-function V1(t, e) {
-    let r = j1(e);
-    Object.defineProperties(t, {
+function z1(e, t) {
+    let r = $1(t);
+    Object.defineProperties(e, {
         id: {
             writable: !0,
             value: r
         }
     })
 }
 
-function W1(t, e) {
-    for (let r in e) Object.defineProperty(t, r, {
+function j1(e, t) {
+    for (let r in t) Object.defineProperty(e, r, {
         enumerable: !1,
         set(s) {
             let i = `${this.id}: ${r}`;
-            for (let n of e[r]) Gh(this, n) || (this[n] = s);
-            W.deprecated(i, e[r].join("/"))()
+            for (let n of t[r]) th(this, n) || (this[n] = s);
+            W.deprecated(i, t[r].join("/"))()
         }
     })
 }
 
-function z1(t, e) {
+function H1(e, t) {
     let r = {},
         s = {};
-    for (let i in e) {
-        let n = e[i],
+    for (let i in t) {
+        let n = t[i],
             {
                 name: o,
                 value: a
             } = n;
-        n.async && (r[o] = a, s[o] = H1(o))
+        n.async && (r[o] = a, s[o] = X1(o))
     }
-    t[Pt] = r, t[dt] = {}, Object.defineProperties(t, s)
+    e[Pe] = r, e[de] = {}, Object.defineProperties(e, s)
 }
 
-function H1(t) {
+function X1(e) {
     return {
         enumerable: !0,
-        set(e) {
-            typeof e == "string" || e instanceof Promise || Ra(e) ? this[dt][t] = e : this[Ye][t] = e
+        set(t) {
+            typeof t == "string" || t instanceof Promise || Ra(t) ? this[de][e] = t : this[Yt][e] = t
         },
         get() {
-            if (this[Ye]) {
-                if (t in this[Ye]) return this[Ye][t] || this[Pt][t];
-                if (t in this[dt]) {
-                    let e = this[ds] && this[ds].internalState;
-                    if (e && e.hasAsyncProp(t)) return e.getAsyncProp(t) || this[Pt][t]
+            if (this[Yt]) {
+                if (e in this[Yt]) return this[Yt][e] || this[Pe][e];
+                if (e in this[de]) {
+                    let t = this[ds] && this[ds].internalState;
+                    if (t && t.hasAsyncProp(e)) return t.getAsyncProp(e) || this[Pe][e]
                 }
             }
-            return this[Pt][t]
+            return this[Pe][e]
         }
     }
 }
 
-function Gh(t, e) {
-    return Object.prototype.hasOwnProperty.call(t, e)
+function th(e, t) {
+    return Object.prototype.hasOwnProperty.call(e, t)
 }
 
-function p_(t, e) {
-    return Gh(t, e) && t[e]
+function _g(e, t) {
+    return th(e, t) && e[t]
 }
 
-function j1(t) {
-    let e = t.componentName;
-    return e || W.warn(`${t.name}.componentName not specified`)(), e || t.name
+function $1(e) {
+    let t = e.componentName;
+    return t || W.warn(`${e.name}.componentName not specified`)(), t || e.name
 }
-var X1 = 0,
+var Y1 = 0,
     Fa = class Fa {
-        constructor(...e) {
-            this.props = d_(this, e), this.id = this.props.id, this.count = X1++
+        constructor(...t) {
+            this.props = pg(this, t), this.id = this.props.id, this.count = Y1++
         }
-        clone(e) {
+        clone(t) {
             let {
                 props: r
             } = this, s = {};
-            for (let i in r[Pt]) i in r[Ye] ? s[i] = r[Ye][i] : i in r[dt] && (s[i] = r[dt][i]);
+            for (let i in r[Pe]) i in r[Yt] ? s[i] = r[Yt][i] : i in r[de] && (s[i] = r[de][i]);
             return new this.constructor({
                 ...r,
                 ...s,
-                ...e
+                ...t
             })
         }
     };
 Fa.componentName = "Component", Fa.defaultProps = {};
 var dn = Fa;
-var $1 = Object.freeze({}),
+var q1 = Object.freeze({}),
     pn = class {
-        constructor(e) {
-            this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {}, this.oldProps = null, this.oldAsyncProps = null
+        constructor(t) {
+            this.component = t, this.asyncProps = {}, this.onAsyncPropUpdated = () => {}, this.oldProps = null, this.oldAsyncProps = null
         }
         finalize() {
-            for (let e in this.asyncProps) {
-                let r = this.asyncProps[e];
+            for (let t in this.asyncProps) {
+                let r = this.asyncProps[t];
                 r && r.type && r.type.release && r.type.release(r.resolvedValue, r.type, this.component)
             }
             this.asyncProps = {}, this.component = null, this.resetOldProps()
         }
         getOldProps() {
-            return this.oldAsyncProps || this.oldProps || $1
+            return this.oldAsyncProps || this.oldProps || q1
         }
         resetOldProps() {
             this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null
         }
-        hasAsyncProp(e) {
-            return e in this.asyncProps
+        hasAsyncProp(t) {
+            return t in this.asyncProps
         }
-        getAsyncProp(e) {
-            let r = this.asyncProps[e];
+        getAsyncProp(t) {
+            let r = this.asyncProps[t];
             return r && r.resolvedValue
         }
-        isAsyncPropLoading(e) {
-            if (e) {
-                let r = this.asyncProps[e];
+        isAsyncPropLoading(t) {
+            if (t) {
+                let r = this.asyncProps[t];
                 return !!(r && r.pendingLoadCount > 0 && r.pendingLoadCount !== r.resolvedLoadCount)
             }
             for (let r in this.asyncProps)
                 if (this.isAsyncPropLoading(r)) return !0;
             return !1
         }
-        reloadAsyncProp(e, r) {
-            this._watchPromise(e, Promise.resolve(r))
+        reloadAsyncProp(t, r) {
+            this._watchPromise(t, Promise.resolve(r))
         }
-        setAsyncProps(e) {
-            this.component = e[ds] || this.component;
-            let r = e[Ye] || {},
-                s = e[dt] || e,
-                i = e[Pt] || {};
+        setAsyncProps(t) {
+            this.component = t[ds] || this.component;
+            let r = t[Yt] || {},
+                s = t[de] || t,
+                i = t[Pe] || {};
             for (let n in r) {
                 let o = r[n];
                 this._createAsyncPropData(n, i[n]), this._updateAsyncProp(n, o), r[n] = this.getAsyncProp(n)
             }
             for (let n in s) {
                 let o = s[n];
                 this._createAsyncPropData(n, i[n]), this._updateAsyncProp(n, o)
             }
         }
-        _fetch(e, r) {
+        _fetch(t, r) {
             return null
         }
-        _onResolve(e, r) {}
-        _onError(e, r) {}
-        _updateAsyncProp(e, r) {
-            if (this._didAsyncInputValueChange(e, r)) {
-                if (typeof r == "string" && (r = this._fetch(e, r)), r instanceof Promise) {
-                    this._watchPromise(e, r);
+        _onResolve(t, r) {}
+        _onError(t, r) {}
+        _updateAsyncProp(t, r) {
+            if (this._didAsyncInputValueChange(t, r)) {
+                if (typeof r == "string" && (r = this._fetch(t, r)), r instanceof Promise) {
+                    this._watchPromise(t, r);
                     return
                 }
                 if (Ra(r)) {
-                    this._resolveAsyncIterable(e, r);
+                    this._resolveAsyncIterable(t, r);
                     return
                 }
-                this._setPropValue(e, r)
+                this._setPropValue(t, r)
             }
         }
         _freezeAsyncOldProps() {
             if (!this.oldAsyncProps && this.oldProps) {
                 this.oldAsyncProps = Object.create(this.oldProps);
-                for (let e in this.asyncProps) Object.defineProperty(this.oldAsyncProps, e, {
+                for (let t in this.asyncProps) Object.defineProperty(this.oldAsyncProps, t, {
                     enumerable: !0,
-                    value: this.oldProps[e]
+                    value: this.oldProps[t]
                 })
             }
         }
-        _didAsyncInputValueChange(e, r) {
-            let s = this.asyncProps[e];
+        _didAsyncInputValueChange(t, r) {
+            let s = this.asyncProps[t];
             return r === s.resolvedValue || r === s.lastValue ? !1 : (s.lastValue = r, !0)
         }
-        _setPropValue(e, r) {
+        _setPropValue(t, r) {
             this._freezeAsyncOldProps();
-            let s = this.asyncProps[e];
+            let s = this.asyncProps[t];
             s && (r = this._postProcessValue(s, r), s.resolvedValue = r, s.pendingLoadCount++, s.resolvedLoadCount = s.pendingLoadCount)
         }
-        _setAsyncPropValue(e, r, s) {
-            let i = this.asyncProps[e];
-            i && s >= i.resolvedLoadCount && r !== void 0 && (this._freezeAsyncOldProps(), i.resolvedValue = r, i.resolvedLoadCount = s, this.onAsyncPropUpdated(e, r))
+        _setAsyncPropValue(t, r, s) {
+            let i = this.asyncProps[t];
+            i && s >= i.resolvedLoadCount && r !== void 0 && (this._freezeAsyncOldProps(), i.resolvedValue = r, i.resolvedLoadCount = s, this.onAsyncPropUpdated(t, r))
         }
-        _watchPromise(e, r) {
-            let s = this.asyncProps[e];
+        _watchPromise(t, r) {
+            let s = this.asyncProps[t];
             if (s) {
                 s.pendingLoadCount++;
                 let i = s.pendingLoadCount;
                 r.then(n => {
-                    this.component && (n = this._postProcessValue(s, n), this._setAsyncPropValue(e, n, i), this._onResolve(e, n))
+                    this.component && (n = this._postProcessValue(s, n), this._setAsyncPropValue(t, n, i), this._onResolve(t, n))
                 }).catch(n => {
-                    this._onError(e, n)
+                    this._onError(t, n)
                 })
             }
         }
-        async _resolveAsyncIterable(e, r) {
-            if (e !== "data") {
-                this._setPropValue(e, r);
+        async _resolveAsyncIterable(t, r) {
+            if (t !== "data") {
+                this._setPropValue(t, r);
                 return
             }
-            let s = this.asyncProps[e];
+            let s = this.asyncProps[t];
             if (!s) return;
             s.pendingLoadCount++;
             let i = s.pendingLoadCount,
                 n = [],
                 o = 0;
             for await (let a of r) {
                 if (!this.component) return;
@@ -22838,94 +22838,94 @@
                 } = this.component.props;
                 c ? n = c(a, n) : n = n.concat(a), Object.defineProperty(n, "__diff", {
                     enumerable: !1,
                     value: [{
                         startRow: o,
                         endRow: n.length
                     }]
-                }), o = n.length, this._setAsyncPropValue(e, n, i)
+                }), o = n.length, this._setAsyncPropValue(t, n, i)
             }
-            this._onResolve(e, n)
+            this._onResolve(t, n)
         }
-        _postProcessValue(e, r) {
-            let s = e.type;
-            return s && this.component && (s.release && s.release(e.resolvedValue, s, this.component), s.transform) ? s.transform(r, s, this.component) : r
-        }
-        _createAsyncPropData(e, r) {
-            if (!this.asyncProps[e]) {
-                let i = this.component && this.component.props[ut];
-                this.asyncProps[e] = {
-                    type: i && i[e],
+        _postProcessValue(t, r) {
+            let s = t.type;
+            return s && this.component && (s.release && s.release(t.resolvedValue, s, this.component), s.transform) ? s.transform(r, s, this.component) : r
+        }
+        _createAsyncPropData(t, r) {
+            if (!this.asyncProps[t]) {
+                let i = this.component && this.component.props[ue];
+                this.asyncProps[t] = {
+                    type: i && i[t],
                     lastValue: null,
                     resolvedValue: r,
                     pendingLoadCount: 0,
                     resolvedLoadCount: 0
                 }
             }
         }
     };
-var gn = class extends pn {
+var _n = class extends pn {
     constructor({
-        attributeManager: e,
+        attributeManager: t,
         layer: r
     }) {
-        super(r), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1
+        super(r), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1
     }
     get layer() {
         return this.component
     }
-    _fetch(e, r) {
+    _fetch(t, r) {
         let s = this.layer,
             i = s?.props.fetch;
         return i ? i(r, {
-            propName: e,
+            propName: t,
             layer: s
-        }) : super._fetch(e, r)
+        }) : super._fetch(t, r)
     }
-    _onResolve(e, r) {
+    _onResolve(t, r) {
         let s = this.layer;
         if (s) {
             let i = s.props.onDataLoad;
-            e === "data" && i && i(r, {
-                propName: e,
+            t === "data" && i && i(r, {
+                propName: t,
                 layer: s
             })
         }
     }
-    _onError(e, r) {
+    _onError(t, r) {
         let s = this.layer;
-        s && s.raiseError(r, `loading ${e} of ${this.layer}`)
+        s && s.raiseError(r, `loading ${t} of ${this.layer}`)
     }
 };
-var Y1 = "layer.changeFlag",
-    q1 = "layer.initialize",
-    K1 = "layer.update",
-    Z1 = "layer.finalize",
-    Q1 = "layer.matched",
-    g_ = 2 ** 24 - 1,
-    J1 = Object.freeze([]),
-    G1 = ft(({
-        oldViewport: t,
-        viewport: e
-    }) => t.equals(e)),
-    mt = new Uint8ClampedArray(0),
-    eS = {
+var K1 = "layer.changeFlag",
+    Z1 = "layer.initialize",
+    Q1 = "layer.update",
+    J1 = "layer.finalize",
+    G1 = "layer.matched",
+    gg = 2 ** 24 - 1,
+    tx = Object.freeze([]),
+    ex = he(({
+        oldViewport: e,
+        viewport: t
+    }) => e.equals(t)),
+    me = new Uint8ClampedArray(0),
+    rx = {
         data: {
             type: "data",
-            value: J1,
+            value: tx,
             async: !0
         },
         dataComparator: {
             type: "function",
             value: null,
             optional: !0
         },
         _dataDiff: {
             type: "function",
-            value: t => t && t.__diff,
+            value: e => e && e.__diff,
             optional: !0
         },
         dataTransform: {
             type: "function",
             value: null,
             optional: !0
         },
@@ -22937,16 +22937,16 @@
         onError: {
             type: "function",
             value: null,
             optional: !0
         },
         fetch: {
             type: "function",
-            value: (t, {
-                propName: e,
+            value: (e, {
+                propName: t,
                 layer: r,
                 loaders: s,
                 loadOptions: i,
                 signal: n
             }) => {
                 let {
                     resourceManager: o
@@ -22954,25 +22954,25 @@
                 i = i || r.getLoadOptions(), s = s || r.props.loaders, n && (i = {
                     ...i,
                     fetch: {
                         ...i?.fetch,
                         signal: n
                     }
                 });
-                let a = o.contains(t);
+                let a = o.contains(e);
                 return !a && !i && (o.add({
-                    resourceId: t,
-                    data: qr(t, s),
+                    resourceId: e,
+                    data: qr(e, s),
                     persistent: !1
                 }), a = !0), a ? o.subscribe({
-                    resourceId: t,
-                    onChange: c => r.internalState?.reloadAsyncProp(e, c),
+                    resourceId: e,
+                    onChange: c => r.internalState?.reloadAsyncProp(t, c),
                     consumerId: r.id,
-                    requestId: e
-                }) : qr(t, s, i)
+                    requestId: t
+                }) : qr(e, s, i)
             }
         },
         updateTriggers: {},
         visible: !0,
         pickable: !1,
         opacity: {
             type: "number",
@@ -23040,72 +23040,72 @@
             value: [],
             optional: !0,
             ignore: !0
         },
         getPolygonOffset: {
             type: "function",
             value: ({
-                layerIndex: t
-            }) => [0, -t * 100]
+                layerIndex: e
+            }) => [0, -e * 100]
         },
         highlightedObjectIndex: null,
         autoHighlight: !1,
         highlightColor: {
             type: "accessor",
             value: [0, 0, 128, 128]
         }
     },
-    Da = class Da extends dn {
+    ka = class ka extends dn {
         constructor() {
-            super(...arguments), this.internalState = null, this.lifecycle = Jt.NO_STATE, this.parent = null
+            super(...arguments), this.internalState = null, this.lifecycle = Je.NO_STATE, this.parent = null
         }
         static get componentName() {
             return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : ""
         }
         get root() {
-            let e = this;
-            for (; e.parent;) e = e.parent;
-            return e
+            let t = this;
+            for (; t.parent;) t = t.parent;
+            return t
         }
         toString() {
             return `${this.constructor.layerName||this.constructor.name}({id: '${this.props.id}'})`
         }
-        project(e) {
+        project(t) {
             J(this.internalState);
             let r = this.internalState.viewport || this.context.viewport,
-                s = yh(e, {
+                s = Tf(t, {
                     viewport: r,
                     modelMatrix: this.props.modelMatrix,
                     coordinateOrigin: this.props.coordinateOrigin,
                     coordinateSystem: this.props.coordinateSystem
                 }),
                 [i, n, o] = cs(s, r.pixelProjectionMatrix);
-            return e.length === 2 ? [i, n] : [i, n, o]
+            return t.length === 2 ? [i, n] : [i, n, o]
         }
-        unproject(e) {
-            return J(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e)
+        unproject(t) {
+            return J(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(t)
         }
-        projectPosition(e, r) {
+        projectPosition(t, r) {
             J(this.internalState);
             let s = this.internalState.viewport || this.context.viewport;
-            return gp(e, {
+            return gp(t, {
                 viewport: s,
                 modelMatrix: this.props.modelMatrix,
                 coordinateOrigin: this.props.coordinateOrigin,
                 coordinateSystem: this.props.coordinateSystem,
                 ...r
             })
         }
         get isComposite() {
             return !1
         }
-        setState(e) {
+        setState(t) {
             this.setChangeFlags({
                 stateChanged: !0
-            }), Object.assign(this.state, e), this.setNeedsRedraw()
+            }), Object.assign(this.state, t), this.setNeedsRedraw()
         }
         setNeedsRedraw() {
             this.internalState && (this.internalState.needsRedraw = !0)
         }
         setNeedsUpdate() {
             this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0)
         }
@@ -23115,391 +23115,391 @@
         get wrapLongitude() {
             return this.props.wrapLongitude
         }
         isPickable() {
             return this.props.pickable && this.props.visible
         }
         getModels() {
-            let e = this.state;
-            return e && (e.models || e.model && [e.model]) || []
+            let t = this.state;
+            return t && (t.models || t.model && [t.model]) || []
         }
-        setModuleParameters(e) {
-            for (let r of this.getModels()) r.updateModuleSettings(e)
+        setModuleParameters(t) {
+            for (let r of this.getModels()) r.updateModuleSettings(t)
         }
-        setShaderModuleProps(...e) {
-            for (let r of this.getModels()) r.shaderInputs.setProps(...e)
+        setShaderModuleProps(...t) {
+            for (let r of this.getModels()) r.shaderInputs.setProps(...t)
         }
         getAttributeManager() {
             return this.internalState && this.internalState.attributeManager
         }
         getCurrentLayer() {
             return this.internalState && this.internalState.layer
         }
         getLoadOptions() {
             return this.props.loadOptions
         }
         use64bitPositions() {
             let {
-                coordinateSystem: e
+                coordinateSystem: t
             } = this.props;
-            return e === X.DEFAULT || e === X.LNGLAT || e === X.CARTESIAN
+            return t === X.DEFAULT || t === X.LNGLAT || t === X.CARTESIAN
         }
-        onHover(e, r) {
-            return this.props.onHover && this.props.onHover(e, r) || !1
+        onHover(t, r) {
+            return this.props.onHover && this.props.onHover(t, r) || !1
         }
-        onClick(e, r) {
-            return this.props.onClick && this.props.onClick(e, r) || !1
+        onClick(t, r) {
+            return this.props.onClick && this.props.onClick(t, r) || !1
         }
         nullPickingColor() {
             return [0, 0, 0]
         }
-        encodePickingColor(e, r = []) {
-            return r[0] = e + 1 & 255, r[1] = e + 1 >> 8 & 255, r[2] = e + 1 >> 8 >> 8 & 255, r
+        encodePickingColor(t, r = []) {
+            return r[0] = t + 1 & 255, r[1] = t + 1 >> 8 & 255, r[2] = t + 1 >> 8 >> 8 & 255, r
         }
-        decodePickingColor(e) {
-            J(e instanceof Uint8Array);
-            let [r, s, i] = e;
+        decodePickingColor(t) {
+            J(t instanceof Uint8Array);
+            let [r, s, i] = t;
             return r + s * 256 + i * 65536 - 1
         }
         getNumInstances() {
-            return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : l_(this.props.data)
+            return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : fg(this.props.data)
         }
         getStartIndices() {
             return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null
         }
         getBounds() {
             return this.getAttributeManager()?.getBounds(["positions", "instancePositions"])
         }
-        getShaders(e) {
-            e = Kh(e, {
+        getShaders(t) {
+            t = Zf(t, {
                 disableWarnings: !0,
                 modules: this.context.defaultShaderModules
             });
-            for (let r of this.props.extensions) e = Kh(e, r.getShaders.call(this, r));
-            return e
+            for (let r of this.props.extensions) t = Zf(t, r.getShaders.call(this, r));
+            return t
         }
-        shouldUpdateState(e) {
-            return e.changeFlags.propsOrDataChanged
+        shouldUpdateState(t) {
+            return t.changeFlags.propsOrDataChanged
         }
-        updateState(e) {
+        updateState(t) {
             let r = this.getAttributeManager(),
                 {
                     dataChanged: s
-                } = e.changeFlags;
+                } = t.changeFlags;
             if (s && r)
                 if (Array.isArray(s))
                     for (let i of s) r.invalidateAll(i);
                 else r.invalidateAll();
             if (r) {
                 let {
                     props: i
-                } = e, n = this.internalState.hasPickingBuffer, o = Number.isInteger(i.highlightedObjectIndex) || i.pickable || i.extensions.some(a => a.getNeedsPickingBuffer.call(this, a));
+                } = t, n = this.internalState.hasPickingBuffer, o = Number.isInteger(i.highlightedObjectIndex) || i.pickable || i.extensions.some(a => a.getNeedsPickingBuffer.call(this, a));
                 if (n !== o) {
                     this.internalState.hasPickingBuffer = o;
                     let {
                         pickingColors: a,
                         instancePickingColors: c
                     } = r.attributes, l = a || c;
                     l && (o && l.constant && (l.constant = !1, r.invalidate(l.id)), !l.value && !o && (l.constant = !0, l.value = [0, 0, 0]))
                 }
             }
         }
-        finalizeState(e) {
+        finalizeState(t) {
             for (let s of this.getModels()) s.destroy();
             let r = this.getAttributeManager();
             r && r.finalize(), this.context && this.context.resourceManager.unsubscribe({
                 consumerId: this.id
             }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize())
         }
-        draw(e) {
-            for (let r of this.getModels()) r.draw(e)
+        draw(t) {
+            for (let r of this.getModels()) r.draw(t)
         }
         getPickingInfo({
-            info: e,
+            info: t,
             mode: r,
             sourceLayer: s
         }) {
             let {
                 index: i
-            } = e;
-            return i >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[i]), e
+            } = t;
+            return i >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[i]), t
         }
-        raiseError(e, r) {
-            r && (e = new Error(`${r}: ${e.message}`, {
-                cause: e
-            })), this.props.onError?.(e) || this.context?.onError?.(e, this)
+        raiseError(t, r) {
+            r && (t = new Error(`${r}: ${t.message}`, {
+                cause: t
+            })), this.props.onError?.(t) || this.context?.onError?.(t, this)
         }
-        getNeedsRedraw(e = {
+        getNeedsRedraw(t = {
             clearRedrawFlags: !1
         }) {
-            return this._getNeedsRedraw(e)
+            return this._getNeedsRedraw(t)
         }
         needsUpdate() {
             return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1
         }
         hasUniformTransition() {
             return this.internalState?.uniformTransitions.active || !1
         }
-        activateViewport(e) {
+        activateViewport(t) {
             if (!this.internalState) return;
             let r = this.internalState.viewport;
-            this.internalState.viewport = e, (!r || !G1({
+            this.internalState.viewport = t, (!r || !ex({
                 oldViewport: r,
-                viewport: e
+                viewport: t
             })) && (this.setChangeFlags({
                 viewportChanged: !0
             }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update())
         }
-        invalidateAttribute(e = "all") {
+        invalidateAttribute(t = "all") {
             let r = this.getAttributeManager();
-            r && (e === "all" ? r.invalidateAll() : r.invalidate(e))
+            r && (t === "all" ? r.invalidateAll() : r.invalidate(t))
         }
-        updateAttributes(e) {
+        updateAttributes(t) {
             let r = !1;
-            for (let s in e) e[s].layoutChanged() && (r = !0);
-            for (let s of this.getModels()) this._setModelAttributes(s, e, r)
+            for (let s in t) t[s].layoutChanged() && (r = !0);
+            for (let s of this.getModels()) this._setModelAttributes(s, t, r)
         }
         _updateAttributes() {
-            let e = this.getAttributeManager();
-            if (!e) return;
+            let t = this.getAttributeManager();
+            if (!t) return;
             let r = this.props,
                 s = this.getNumInstances(),
                 i = this.getStartIndices();
-            e.update({
+            t.update({
                 data: r.data,
                 numInstances: s,
                 startIndices: i,
                 props: r,
                 transitions: r.transitions,
                 buffers: r.data.attributes,
                 context: this
             });
-            let n = e.getChangedAttributes({
+            let n = t.getChangedAttributes({
                 clearChangedFlags: !0
             });
             this.updateAttributes(n)
         }
         _updateAttributeTransition() {
-            let e = this.getAttributeManager();
-            e && e.updateTransition()
+            let t = this.getAttributeManager();
+            t && t.updateTransition()
         }
         _updateUniformTransition() {
             let {
-                uniformTransitions: e
+                uniformTransitions: t
             } = this.internalState;
-            if (e.active) {
-                let r = e.update(),
+            if (t.active) {
+                let r = t.update(),
                     s = Object.create(this.props);
                 for (let i in r) Object.defineProperty(s, i, {
                     value: r[i]
                 });
                 return s
             }
             return this.props
         }
-        calculateInstancePickingColors(e, {
+        calculateInstancePickingColors(t, {
             numInstances: r
         }) {
-            if (e.constant) return;
-            let s = Math.floor(mt.length / 4);
+            if (t.constant) return;
+            let s = Math.floor(me.length / 4);
             if (this.internalState.usesPickingColorCache = !0, s < r) {
-                r > g_ && W.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), mt = Mt.allocate(mt, r, {
+                r > gg && W.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), me = Me.allocate(me, r, {
                     size: 4,
                     copy: !0,
-                    maxCount: Math.max(r, g_)
+                    maxCount: Math.max(r, gg)
                 });
-                let i = Math.floor(mt.length / 4),
+                let i = Math.floor(me.length / 4),
                     n = [];
-                for (let o = s; o < i; o++) this.encodePickingColor(o, n), mt[o * 4 + 0] = n[0], mt[o * 4 + 1] = n[1], mt[o * 4 + 2] = n[2]
+                for (let o = s; o < i; o++) this.encodePickingColor(o, n), me[o * 4 + 0] = n[0], me[o * 4 + 1] = n[1], me[o * 4 + 2] = n[2]
             }
-            e.value = mt.subarray(0, r * 4)
+            t.value = me.subarray(0, r * 4)
         }
-        _setModelAttributes(e, r, s = !1) {
+        _setModelAttributes(t, r, s = !1) {
             if (!Object.keys(r).length) return;
             if (s) {
                 let a = this.getAttributeManager();
-                e.setBufferLayout(a.getBufferLayouts()), r = a.getAttributes()
+                t.setBufferLayout(a.getBufferLayouts()), r = a.getAttributes()
             }
-            let i = e.userData?.excludeAttributes || {},
+            let i = t.userData?.excludeAttributes || {},
                 n = {},
                 o = {};
             for (let a in r) {
                 if (i[a]) continue;
                 let c = r[a].getValue();
                 for (let l in c) {
-                    let h = c[l];
-                    h instanceof K ? r[a].settings.isIndexed ? e.setIndexBuffer(h) : n[l] = h : h && (o[l] = h)
+                    let f = c[l];
+                    f instanceof K ? r[a].settings.isIndexed ? t.setIndexBuffer(f) : n[l] = f : f && (o[l] = f)
                 }
             }
-            e.setAttributes(n), e.setConstantAttributes(o)
+            t.setAttributes(n), t.setConstantAttributes(o)
         }
-        disablePickingIndex(e) {
+        disablePickingIndex(t) {
             let r = this.props.data;
             if (!("attributes" in r)) {
-                this._disablePickingIndex(e);
+                this._disablePickingIndex(t);
                 return
             }
             let {
                 pickingColors: s,
                 instancePickingColors: i
             } = this.getAttributeManager().attributes, n = s || i, o = n && r.attributes && r.attributes[n.id];
             if (o && o.value) {
                 let a = o.value,
-                    c = this.encodePickingColor(e);
+                    c = this.encodePickingColor(t);
                 for (let l = 0; l < r.length; l++) {
-                    let h = n.getVertexOffset(l);
-                    a[h] === c[0] && a[h + 1] === c[1] && a[h + 2] === c[2] && this._disablePickingIndex(l)
+                    let f = n.getVertexOffset(l);
+                    a[f] === c[0] && a[f + 1] === c[1] && a[f + 2] === c[2] && this._disablePickingIndex(l)
                 }
-            } else this._disablePickingIndex(e)
+            } else this._disablePickingIndex(t)
         }
-        _disablePickingIndex(e) {
+        _disablePickingIndex(t) {
             let {
                 pickingColors: r,
                 instancePickingColors: s
             } = this.getAttributeManager().attributes, i = r || s;
             if (!i) return;
-            let n = i.getVertexOffset(e),
-                o = i.getVertexOffset(e + 1);
+            let n = i.getVertexOffset(t),
+                o = i.getVertexOffset(t + 1);
             i.buffer.write(new Uint8Array(o - n), n)
         }
         restorePickingColors() {
             let {
-                pickingColors: e,
+                pickingColors: t,
                 instancePickingColors: r
-            } = this.getAttributeManager().attributes, s = e || r;
-            s && (this.internalState.usesPickingColorCache && s.value.buffer !== mt.buffer && (s.value = mt.subarray(0, s.value.length)), s.updateSubBuffer({
+            } = this.getAttributeManager().attributes, s = t || r;
+            s && (this.internalState.usesPickingColorCache && s.value.buffer !== me.buffer && (s.value = me.subarray(0, s.value.length)), s.updateSubBuffer({
                 startOffset: 0
             }))
         }
         _initialize() {
-            J(!this.internalState), J(Number.isFinite(this.props.coordinateSystem)), re(q1, this);
-            let e = this._getAttributeManager();
-            e && e.addInstanced({
+            J(!this.internalState), J(Number.isFinite(this.props.coordinateSystem)), rt(Z1, this);
+            let t = this._getAttributeManager();
+            t && t.addInstanced({
                 instancePickingColors: {
                     type: "uint8",
                     size: 4,
                     noAlloc: !0,
                     update: this.calculateInstancePickingColors
                 }
-            }), this.internalState = new gn({
-                attributeManager: e,
+            }), this.internalState = new _n({
+                attributeManager: t,
                 layer: this
             }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
-                get: () => (W.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
-            }), this.internalState.uniformTransitions = new fn(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
+                get: () => (W.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), t)
+            }), this.internalState.uniformTransitions = new hn(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
             for (let r of this.props.extensions) r.initializeState.call(this, this.context, r);
             this.setChangeFlags({
                 dataChanged: "init",
                 propsChanged: "init",
                 viewportChanged: !0,
                 extensionsChanged: !0
             }), this._update()
         }
-        _transferState(e) {
-            re(Q1, this, this === e);
+        _transferState(t) {
+            rt(G1, this, this === t);
             let {
                 state: r,
                 internalState: s
-            } = e;
-            this !== e && (this.internalState = s, this.state = r, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()))
+            } = t;
+            this !== t && (this.internalState = s, this.state = r, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()))
         }
         _update() {
-            let e = this.needsUpdate();
-            if (re(K1, this, e), !e) return;
+            let t = this.needsUpdate();
+            if (rt(Q1, this, t), !t) return;
             let r = this.props,
                 s = this.context,
                 i = this.internalState,
                 n = s.viewport,
                 o = this._updateUniformTransition();
             i.propsInTransition = o, s.viewport = i.viewport || n, this.props = o;
             try {
                 let a = this._getUpdateParams(),
                     c = this.getModels();
                 if (s.device) this.updateState(a);
                 else try {
                     this.updateState(a)
                 } catch {}
-                for (let h of this.props.extensions) h.updateState.call(this, a, h);
+                for (let f of this.props.extensions) f.updateState.call(this, a, f);
                 let l = this.getModels()[0] !== c[0];
                 this._postUpdate(a, l)
             } finally {
                 s.viewport = n, this.props = r, this._clearChangeFlags(), i.needsUpdate = !1, i.resetOldProps()
             }
         }
         _finalize() {
-            re(Z1, this), this.finalizeState(this.context);
-            for (let e of this.props.extensions) e.finalizeState.call(this, this.context, e)
+            rt(J1, this), this.finalizeState(this.context);
+            for (let t of this.props.extensions) t.finalizeState.call(this, this.context, t)
         }
         _drawLayer({
-            renderPass: e,
+            renderPass: t,
             moduleParameters: r = null,
             uniforms: s = {},
             parameters: i = {}
         }) {
             this._updateAttributeTransition();
             let n = this.props,
                 o = this.context;
             this.props = this.internalState.propsInTransition || n;
             let a = this.props.opacity;
             s.opacity = Math.pow(a, 1 / 2.2);
             try {
                 if (r) {
                     let {
-                        isActive: h,
+                        isActive: f,
                         isAttribute: d
                     } = r.picking;
                     this.setModuleParameters(r), this.setShaderModuleProps({
                         picking: {
-                            isActive: h,
+                            isActive: f,
                             isAttribute: d
                         }
                     })
                 }
                 let {
                     getPolygonOffset: c
                 } = this.props, l = c && c(s) || [0, 0];
                 o.device.setParametersWebGL({
                     polygonOffset: l
                 });
-                for (let h of this.getModels()) h.setParameters(i);
+                for (let f of this.getModels()) f.setParameters(i);
                 o.device.withParametersWebGL(i, () => {
-                    let h = {
-                        renderPass: e,
+                    let f = {
+                        renderPass: t,
                         moduleParameters: r,
                         uniforms: s,
                         parameters: i,
                         context: o
                     };
-                    for (let d of this.props.extensions) d.draw.call(this, h, d);
-                    this.draw(h)
+                    for (let d of this.props.extensions) d.draw.call(this, f, d);
+                    this.draw(f)
                 })
             } finally {
                 this.props = n
             }
         }
         getChangeFlags() {
             return this.internalState?.changeFlags
         }
-        setChangeFlags(e) {
+        setChangeFlags(t) {
             if (!this.internalState) return;
             let {
                 changeFlags: r
             } = this.internalState;
-            for (let i in e)
-                if (e[i]) {
+            for (let i in t)
+                if (t[i]) {
                     let n = !1;
                     switch (i) {
                         case "dataChanged":
-                            let o = e[i],
+                            let o = t[i],
                                 a = r[i];
                             o && Array.isArray(a) && (r.dataChanged = Array.isArray(o) ? a.concat(o) : o, n = !0);
                         default:
-                            r[i] || (r[i] = e[i], n = !0)
+                            r[i] || (r[i] = t[i], n = !0)
                     }
-                    n && re(Y1, this, i, e)
+                    n && rt(K1, this, i, t)
                 } let s = !!(r.dataChanged || r.updateTriggersChanged || r.propsChanged || r.extensionsChanged);
             r.propsOrDataChanged = s, r.somethingChanged = s || r.viewportChanged || r.stateChanged
         }
         _clearChangeFlags() {
             this.internalState.changeFlags = {
                 dataChanged: !1,
                 propsChanged: !1,
@@ -23507,52 +23507,52 @@
                 viewportChanged: !1,
                 stateChanged: !1,
                 extensionsChanged: !1,
                 propsOrDataChanged: !1,
                 somethingChanged: !1
             }
         }
-        _diffProps(e, r) {
-            let s = a_(e, r);
+        _diffProps(t, r) {
+            let s = cg(t, r);
             if (s.updateTriggersChanged)
                 for (let i in s.updateTriggersChanged) s.updateTriggersChanged[i] && this.invalidateAttribute(i);
             if (s.transitionsChanged)
-                for (let i in s.transitionsChanged) this.internalState.uniformTransitions.add(i, r[i], e[i], e.transitions?.[i]);
+                for (let i in s.transitionsChanged) this.internalState.uniformTransitions.add(i, r[i], t[i], t.transitions?.[i]);
             return this.setChangeFlags(s)
         }
         validateProps() {
-            o_(this.props)
+            ag(this.props)
         }
-        updateAutoHighlight(e) {
-            this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e)
+        updateAutoHighlight(t) {
+            this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(t)
         }
-        _updateAutoHighlight(e) {
+        _updateAutoHighlight(t) {
             let r = {
-                    highlightedObjectColor: e.picked ? e.color : null
+                    highlightedObjectColor: t.picked ? t.color : null
                 },
                 {
                     highlightColor: s
                 } = this.props;
-            e.picked && typeof s == "function" && (r.highlightColor = s(e)), this.setShaderModuleProps({
+            t.picked && typeof s == "function" && (r.highlightColor = s(t)), this.setShaderModuleProps({
                 picking: r
             }), this.setNeedsRedraw()
         }
         _getAttributeManager() {
-            let e = this.context;
-            return new Ms(e.device, {
+            let t = this.context;
+            return new Ms(t.device, {
                 id: this.props.id,
-                stats: e.stats,
-                timeline: e.timeline
+                stats: t.stats,
+                timeline: t.timeline
             })
         }
-        _postUpdate(e, r) {
+        _postUpdate(t, r) {
             let {
                 props: s,
                 oldProps: i
-            } = e;
+            } = t;
             this.setNeedsRedraw(), this._updateAttributes(), this.state.model?.setInstanceCount(this.getNumInstances());
             let {
                 autoHighlight: o,
                 highlightedObjectIndex: a,
                 highlightColor: c
             } = s;
             if (r || i.autoHighlight !== o || i.highlightedObjectIndex !== a || i.highlightColor !== c) {
@@ -23566,31 +23566,31 @@
             return {
                 props: this.props,
                 oldProps: this.internalState.getOldProps(),
                 context: this.context,
                 changeFlags: this.internalState.changeFlags
             }
         }
-        _getNeedsRedraw(e) {
+        _getNeedsRedraw(t) {
             if (!this.internalState) return !1;
             let r = !1;
             r = r || this.internalState.needsRedraw && this.id;
             let s = this.getAttributeManager(),
-                i = s ? s.getNeedsRedraw(e) : !1;
+                i = s ? s.getNeedsRedraw(t) : !1;
             if (r = r || i, r)
                 for (let n of this.props.extensions) n.onNeedsRedraw.call(this, n);
-            return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, r
+            return this.internalState.needsRedraw = this.internalState.needsRedraw && !t.clearRedrawFlags, r
         }
         _onAsyncPropUpdated() {
             this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate()
         }
     };
-Da.defaultProps = eS, Da.layerName = "Layer";
-var Wr = Da;
-var __ = `#version 300 es
+ka.defaultProps = rx, ka.layerName = "Layer";
+var Wr = ka;
+var mg = `#version 300 es
 #define SHADER_NAME scatterplot-layer-vertex-shader
 in vec3 positions;
 in vec3 instancePositions;
 in vec3 instancePositions64Low;
 in float instanceRadius;
 in float instanceLineWidths;
 in vec4 instanceFillColors;
@@ -23644,15 +23644,15 @@
 }
 vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
 DECKGL_FILTER_COLOR(vFillColor, geometry);
 vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
 DECKGL_FILTER_COLOR(vLineColor, geometry);
 }
 `;
-var m_ = `#version 300 es
+var bg = `#version 300 es
 #define SHADER_NAME scatterplot-layer-fragment-shader
 precision highp float;
 uniform bool filled;
 uniform float stroked;
 uniform bool antialiasing;
 in vec4 vFillColor;
 in vec4 vLineColor;
@@ -23686,16 +23686,16 @@
 } else {
 fragColor = vFillColor;
 }
 fragColor.a *= inCircle;
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var T_ = [0, 0, 0, 255],
-    iS = {
+var yg = [0, 0, 0, 255],
+    ox = {
         radiusUnits: "meters",
         radiusScale: {
             type: "number",
             min: 0,
             value: 1
         },
         radiusMinPixels: {
@@ -23726,27 +23726,27 @@
         },
         stroked: !1,
         filled: !0,
         billboard: !1,
         antialiasing: !0,
         getPosition: {
             type: "accessor",
-            value: t => t.position
+            value: e => e.position
         },
         getRadius: {
             type: "accessor",
             value: 1
         },
         getFillColor: {
             type: "accessor",
-            value: T_
+            value: yg
         },
         getLineColor: {
             type: "accessor",
-            value: T_
+            value: yg
         },
         getLineWidth: {
             type: "accessor",
             value: 1
         },
         strokeWidth: {
             deprecatedFor: "getLineWidth"
@@ -23754,20 +23754,20 @@
         outline: {
             deprecatedFor: "stroked"
         },
         getColor: {
             deprecatedFor: ["getFillColor", "getLineColor"]
         }
     },
-    ka = class ka extends Wr {
+    Da = class Da extends Wr {
         getShaders() {
             return super.getShaders({
-                vs: __,
-                fs: m_,
-                modules: [yi, wi]
+                vs: mg,
+                fs: bg,
+                modules: [yi, Si]
             })
         }
         initializeState() {
             this.getAttributeManager().addInstanced({
                 instancePositions: {
                     size: 3,
                     type: "float64",
@@ -23799,76 +23799,144 @@
                     size: 1,
                     transition: !0,
                     accessor: "getLineWidth",
                     defaultValue: 1
                 }
             })
         }
-        updateState(e) {
-            super.updateState(e), e.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll())
+        updateState(t) {
+            super.updateState(t), t.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll())
         }
         draw({
-            uniforms: e
+            uniforms: t
         }) {
             let {
                 radiusUnits: r,
                 radiusScale: s,
                 radiusMinPixels: i,
                 radiusMaxPixels: n,
                 stroked: o,
                 filled: a,
                 billboard: c,
                 antialiasing: l,
-                lineWidthUnits: h,
+                lineWidthUnits: f,
                 lineWidthScale: d,
                 lineWidthMinPixels: p,
                 lineWidthMaxPixels: m
             } = this.props, y = this.state.model;
-            y.setUniforms(e), y.setUniforms({
+            y.setUniforms(t), y.setUniforms({
                 stroked: o ? 1 : 0,
                 filled: a,
                 billboard: c,
                 antialiasing: l,
-                radiusUnits: Xt[r],
+                radiusUnits: Xe[r],
                 radiusScale: s,
                 radiusMinPixels: i,
                 radiusMaxPixels: n,
-                lineWidthUnits: Xt[h],
+                lineWidthUnits: Xe[f],
                 lineWidthScale: d,
                 lineWidthMinPixels: p,
                 lineWidthMaxPixels: m
             }), y.draw(this.context.renderPass)
         }
         _getModel() {
-            let e = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
-            return new Qt(this.context.device, {
+            let t = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
+            return new Qe(this.context.device, {
                 ...this.getShaders(),
                 id: this.props.id,
                 bufferLayout: this.getAttributeManager().getBufferLayouts(),
                 geometry: new Oi({
                     topology: "triangle-strip",
                     attributes: {
                         positions: {
                             size: 3,
-                            value: new Float32Array(e)
+                            value: new Float32Array(t)
                         }
                     }
                 }),
                 isInstanced: !0
             })
         }
     };
-ka.defaultProps = iS, ka.layerName = "ScatterplotLayer";
-var zr = ka;
+Da.defaultProps = ox, Da.layerName = "ScatterplotLayer";
+var zr = Da;
+var ax = typeof TextDecoder < "u" ? new TextDecoder("utf-8", {
+    ignoreBOM: !0,
+    fatal: !0
+}) : {
+    decode: () => {
+        throw Error("TextDecoder not available")
+    }
+};
+typeof TextDecoder < "u" && ax.decode();
+var Tg = new Array(128).fill(void 0);
+Tg.push(void 0, null, !0, !1);
+var _5 = Tg.length;
+var eh = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : {
+        encode: () => {
+            throw Error("TextEncoder not available")
+        }
+    },
+    g5 = typeof eh.encodeInto == "function" ? function(e, t) {
+        return eh.encodeInto(e, t)
+    } : function(e, t) {
+        let r = eh.encode(e);
+        return t.set(r), {
+            read: e.length,
+            written: r.length
+        }
+    };
+var m5 = Object.freeze({
+        UNCOMPRESSED: 0,
+        0: "UNCOMPRESSED",
+        SNAPPY: 1,
+        1: "SNAPPY",
+        GZIP: 2,
+        2: "GZIP",
+        BROTLI: 3,
+        3: "BROTLI",
+        LZ4: 4,
+        4: "LZ4",
+        ZSTD: 5,
+        5: "ZSTD",
+        LZ4_RAW: 6,
+        6: "LZ4_RAW"
+    }),
+    b5 = Object.freeze({
+        PLAIN: 0,
+        0: "PLAIN",
+        PLAIN_DICTIONARY: 1,
+        1: "PLAIN_DICTIONARY",
+        RLE: 2,
+        2: "RLE",
+        BIT_PACKED: 3,
+        3: "BIT_PACKED",
+        DELTA_BINARY_PACKED: 4,
+        4: "DELTA_BINARY_PACKED",
+        DELTA_LENGTH_BYTE_ARRAY: 5,
+        5: "DELTA_LENGTH_BYTE_ARRAY",
+        DELTA_BYTE_ARRAY: 6,
+        6: "DELTA_BYTE_ARRAY",
+        RLE_DICTIONARY: 7,
+        7: "RLE_DICTIONARY",
+        BYTE_STREAM_SPLIT: 8,
+        8: "BYTE_STREAM_SPLIT"
+    }),
+    y5 = Object.freeze({
+        V1: 0,
+        0: "V1",
+        V2: 1,
+        1: "V2"
+    });
 console.log("here!!!");
 console.log("deck.gl", ir);
 
-function nS({
-    model: t,
-    el: e
+function cx({
+    model: e,
+    el: t
 }) {
     let r = document.createElement("div");
     r.style.height = "800px";
     let s = new ir({
         parent: r,
         controller: !0,
         initialViewState: {
@@ -23884,22 +23952,22 @@
             }],
             getFillColor: i => i.color,
             getRadius: i => i.radius,
             pickable: !0,
             onClick: i => console.log("hi hi hi", i)
         })]
     });
-    return e.appendChild(r), () => s.finalize()
+    return t.appendChild(r), () => s.finalize()
 }
-var p5 = {
-    render: nS
+var R5 = {
+    render: cx
 };
 export {
-    p5 as
-    default, nS as render
+    R5 as
+    default, cx as render
 };
 /*! Bundled license information:
 
 hammerjs/hammer.js:
   (*! Hammer.JS - v2.0.7 - 2016-04-22
    * http://hammerjs.github.io/
    *
```

### Comparing `celldega-0.0.0/README.md` & `celldega-0.1.0/README.md`

 * *Files identical despite different names*

### Comparing `celldega-0.0.0/pyproject.toml` & `celldega-0.1.0/pyproject.toml`

 * *Files 11% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 [build-system]
 requires = ["hatchling"]
 build-backend = "hatchling.build"
 
 [project]
 name = "celldega"
-version = "0.0.0"
+version = "0.1.0"
 dependencies = ["anywidget"]
 readme = "README.md"
 
 [project.optional-dependencies]
 dev = ["watchfiles", "jupyterlab"]
 
 # automatically add the dev feature to the default env (e.g., hatch shell)
```

### Comparing `celldega-0.0.0/PKG-INFO` & `celldega-0.1.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: celldega
-Version: 0.0.0
+Version: 0.1.0
 Requires-Dist: anywidget
 Provides-Extra: dev
 Requires-Dist: jupyterlab; extra == 'dev'
 Requires-Dist: watchfiles; extra == 'dev'
 Description-Content-Type: text/markdown
 
 # celldega
```

